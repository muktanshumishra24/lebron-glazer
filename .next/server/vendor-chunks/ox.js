"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs?.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nfunction format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_2__.formatAbiItem(abiConstructor);\n}\n/** @internal */\nfunction from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */\nfunction fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDcEI7QUFDaEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBb0I7QUFDL0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksaUJBQWlCO0FBQzdCLFdBQVcsMkNBQVU7QUFDckIsVUFBVSxxREFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ087QUFDUCxXQUFXLDZDQUFZO0FBQ3ZCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQXFCLEdBQUcscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzP2U0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUNvbnN0cnVjdG9yLCBvcHRpb25zXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpKSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGJ5dGVjb2RlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhYmlDb25zdHJ1Y3Rvci5pbnB1dHM/Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhLnJlcGxhY2UoYnl0ZWNvZGUsICcweCcpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlDb25zdHJ1Y3Rvci5pbnB1dHMsIGRhdGEpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlDb25zdHJ1Y3Rvciwgb3B0aW9uc10gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSksIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBieXRlY29kZSwgYXJncyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGV4LmNvbmNhdChieXRlY29kZSwgYWJpQ29uc3RydWN0b3IuaW5wdXRzPy5sZW5ndGggJiYgYXJncz8ubGVuZ3RoXG4gICAgICAgID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBhcmdzKVxuICAgICAgICA6ICcweCcpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChhYmlDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpQ29uc3RydWN0b3IpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUNvbnN0cnVjdG9yKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSkge1xuICAgIGNvbnN0IGl0ZW0gPSBhYmkuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnY29uc3RydWN0b3InKTtcbiAgICBpZiAoIWl0ZW0pXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLk5vdEZvdW5kRXJyb3IoeyBuYW1lOiAnY29uc3RydWN0b3InIH0pO1xuICAgIHJldHVybiBpdGVtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpQ29uc3RydWN0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiConstructor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiFunction.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: () => (/* binding */ decodeData),\n/* harmony export */   decodeResult: () => (/* binding */ decodeResult),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeResult: () => (/* binding */ encodeResult),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeData(...parameters) {\n    const [abiFunction, data] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [fromAbi(abi, name), data];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) < 4)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs?.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) <= 4)\n        return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(data, 4));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [fromAbi(abi, name), data, options];\n        }\n        return parameters;\n    })();\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeData(...parameters) {\n    const [abiFunction, args = []] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [fromAbi(abi, name, { args }), args];\n        }\n        const [abiFunction, args] = parameters;\n        return [abiFunction, args];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args,\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(item.inputs, args) : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(selector, data) : selector;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [fromAbi(abi, name), output, options];\n        }\n        return parameters;\n    })();\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nfunction format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_3__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nfunction from(abiFunction, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nfunction getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUZ1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDcEI7QUFDaEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLFlBQVk7QUFDeEIsUUFBUSx5Q0FBUTtBQUNoQixrQkFBa0IsaUVBQWdDLEdBQUcsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5Q0FBUTtBQUNoQjtBQUNBLFdBQVcscURBQW9CLGNBQWMsMENBQVM7QUFDdEQ7QUFDQTtBQUNPO0FBQ1AsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLHFEQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQyxxREFBb0I7QUFDdkQsa0JBQWtCLDJDQUFVO0FBQzVCO0FBQ0E7QUFDTztBQUNQLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcscURBQW9CO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNBLDhGQUE4RixpQ0FBaUM7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQixpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFdBQVcsNkNBQVk7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsU0FBUyxrQkFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixnREFBZTtBQUNoQztBQUNBLGtCQUFrQixzREFBcUIsR0FBRyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGlDQUFpQztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9DQUFvQztBQUMxRTtBQUNPO0FBQ1AsV0FBVyxvREFBbUI7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUZ1bmN0aW9uLmpzPzcyYTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZURhdGEoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgZGF0YV0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZSwgZGF0YV0gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSksIGRhdGFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGlmIChIZXguc2l6ZShkYXRhKSA8IDQpXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcih7IGRhdGEgfSk7XG4gICAgaWYgKGFiaUZ1bmN0aW9uLmlucHV0cz8ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgZGF0YSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPD0gNClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoaXRlbS5pbnB1dHMsIEhleC5zbGljZShkYXRhLCA0KSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJlc3VsdCguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUZ1bmN0aW9uLCBkYXRhLCBvcHRpb25zID0ge31dID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWUsIGRhdGEsIG9wdGlvbnNdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmksIG5hbWUpLCBkYXRhLCBvcHRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9KSgpO1xuICAgIGNvbnN0IHZhbHVlcyA9IEFiaVBhcmFtZXRlcnMuZGVjb2RlKGFiaUZ1bmN0aW9uLm91dHB1dHMsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHZhbHVlcyAmJiBPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModmFsdWVzKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRGF0YSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUZ1bmN0aW9uLCBhcmdzID0gW11dID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWUsIGFyZ3NdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmksIG5hbWUsIHsgYXJncyB9KSwgYXJnc107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2FiaUZ1bmN0aW9uLCBhcmdzXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHJldHVybiBbYWJpRnVuY3Rpb24sIGFyZ3NdO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgYWJpRnVuY3Rpb24ubmFtZSwge1xuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgfSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGl0ZW0pO1xuICAgIGNvbnN0IGRhdGEgPSBhcmdzLmxlbmd0aCA+IDAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShpdGVtLmlucHV0cywgYXJncykgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRhdGEgPyBIZXguY29uY2F0KHNlbGVjdG9yLCBkYXRhKSA6IHNlbGVjdG9yO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSZXN1bHQoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgb3V0cHV0LCBvcHRpb25zID0ge31dID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWUsIG91dHB1dCwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSksIG91dHB1dCwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZXMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYWJpRnVuY3Rpb24ub3V0cHV0cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW291dHB1dF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkpXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICBpZiAoYXMgPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZW5jb2RlKGFiaUZ1bmN0aW9uLm91dHB1dHMsIHZhbHVlcyk7XG59XG4vKipcbiAqIEZvcm1hdHMgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufSBpbnRvIGEgKipIdW1hbiBSZWFkYWJsZSBBQkkgRnVuY3Rpb24qKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpRnVuY3Rpb24uZm9ybWF0KHtcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAqICAgbmFtZTogJ2FwcHJvdmUnLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqICAgb3V0cHV0czogW3sgdHlwZTogJ2Jvb2wnIH1dLFxuICogfSlcbiAqXG4gKiBmb3JtYXR0ZWRcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgRnVuY3Rpb24gdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBBQkkgRnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUZ1bmN0aW9uKTtcbn1cbi8qKlxuICogUGFyc2VzIGFuIGFyYml0cmFyeSAqKkpTT04gQUJJIEZ1bmN0aW9uKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgRnVuY3Rpb24qKiBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gQUJJc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFwcHJvdmUgPSBBYmlGdW5jdGlvbi5mcm9tKHtcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAqICAgbmFtZTogJ2FwcHJvdmUnLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqICAgb3V0cHV0czogW3sgdHlwZTogJ2Jvb2wnIH1dLFxuICogfSlcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEh1bWFuIFJlYWRhYmxlIEFCSXNcbiAqXG4gKiBBIEh1bWFuIFJlYWRhYmxlIEFCSSBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCBBQkkgb2JqZWN0OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFwcHJvdmUgPSBBYmlGdW5jdGlvbi5mcm9tKFxuICogICAnZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50KSByZXR1cm5zIChib29sKScgLy8gWyFjb2RlIGhsXVxuICogKVxuICpcbiAqIGFwcHJvdmVcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBgc3RydWN0YHMgYWxvbmcgd2l0aCB5b3VyIGRlZmluaXRpb25zOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFwcHJvdmUgPSBBYmlGdW5jdGlvbi5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnZnVuY3Rpb24gYXBwcm92ZShGb28gZm9vKSByZXR1cm5zIChib29sKScsXG4gKiBdKVxuICpcbiAqIGFwcHJvdmVcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIGFiaUZ1bmN0aW9uIC0gVGhlIEFCSSBGdW5jdGlvbiB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFR5cGVkIEFCSSBGdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWJpRnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBBYmlJdGVtLmZyb20oYWJpRnVuY3Rpb24sIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhbiB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uQWJpRnVuY3Rpb259IGZyb20gYW4ge0BsaW5rIG94I0FiaS5BYml9IGdpdmVuIGEgbmFtZSBhbmQgb3B0aW9uYWwgYXJndW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRXh0cmFjdGluZyBieSBOYW1lXG4gKlxuICogQUJJIEZ1bmN0aW9ucyBjYW4gYmUgZXh0cmFjdGVkIGJ5IHRoZWlyIG5hbWUgdXNpbmcgdGhlIGBuYW1lYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICpcbiAqIGNvbnN0IGl0ZW0gPSBBYmlGdW5jdGlvbi5mcm9tQWJpKGFiaSwgJ2ZvbycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgU2VsZWN0b3JcbiAqXG4gKiBBQkkgRnVuY3Rpb25zIGNhbiBiZSBleHRyYWN0IGJ5IHRoZWlyIHNlbGVjdG9yIHdoZW4ge0BsaW5rIG94I0hleC5IZXh9IGlzIHByb3ZpZGVkIHRvIGBuYW1lYC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKiBjb25zdCBpdGVtID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICcweDA5NWVhN2IzJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBFeHRyYWN0aW5nIHZpYSBhIGhleCBzZWxlY3RvciBpcyB1c2VmdWwgd2hlbiBleHRyYWN0aW5nIGFuIEFCSSBGdW5jdGlvbiBmcm9tIGFuIGBldGhfY2FsbGAgUlBDIHJlc3BvbnNlIG9yXG4gKiBmcm9tIGEgVHJhbnNhY3Rpb24gYGlucHV0YC5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIChvciBzZWxlY3Rvcikgb2YgdGhlIEFCSSBpdGVtIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhY3Rpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBBQkkgaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChpdGVtLnR5cGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLk5vdEZvdW5kRXJyb3IoeyBuYW1lLCB0eXBlOiAnZnVuY3Rpb24nIH0pO1xuICAgIHJldHVybiBpdGVtO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgWzQtYnl0ZSBzZWxlY3Rvcl0oaHR0cHM6Ly9zb2xpZGl0eS1ieS1leGFtcGxlLm9yZy9mdW5jdGlvbi1zZWxlY3Rvci8pIGZvciBhbiB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uQWJpRnVuY3Rpb259LlxuICpcbiAqIFVzZWZ1bCBmb3IgY29tcHV0aW5nIGZ1bmN0aW9uIHNlbGVjdG9ycyBmb3IgY2FsbGRhdGEuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNlbGVjdG9yID0gQWJpRnVuY3Rpb24uZ2V0U2VsZWN0b3IoJ2Z1bmN0aW9uIG93bmVyT2YodWludDI1NiB0b2tlbklkKScpXG4gKiAvLyBAbG9nOiAnMHg2MzUyMjExZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUZ1bmN0aW9uLmdldFNlbGVjdG9yKHtcbiAqICAgaW5wdXRzOiBbeyB0eXBlOiAndWludDI1NicgfV0sXG4gKiAgIG5hbWU6ICdvd25lck9mJyxcbiAqICAgb3V0cHV0czogW10sXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICogICB0eXBlOiAnZnVuY3Rpb24nXG4gKiB9KVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgaXRlbSB0byBjb21wdXRlIHRoZSBzZWxlY3RvciBmb3IuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3QgNCBieXRlcyBvZiB0aGUge0BsaW5rIG94I0hhc2guKGtlY2NhazI1NjpmdW5jdGlvbil9IGhhc2ggb2YgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yKGFiaUl0ZW0pIHtcbiAgICByZXR1cm4gQWJpSXRlbS5nZXRTZWxlY3RvcihhYmlJdGVtKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUZ1bmN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiFunction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiItem.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: () => (/* binding */ AmbiguityError),\n/* harmony export */   InvalidSelectorSizeError: () => (/* binding */ InvalidSelectorSizeError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   getSignatureHash: () => (/* binding */ getSignatureHash)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js\");\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nfunction format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nfunction from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSelector(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignature(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignatureHash(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_4__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nclass AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nclass NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nclass InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0c7QUFDSjtBQUNGO0FBQ2tCO0FBQ2xEO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxzRkFBc0YseUJBQXlCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFvQjtBQUN2QztBQUNBLG1CQUFtQixpREFBb0I7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0IsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLFNBQVMsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDRCQUE0QjtBQUN4QyxVQUFVO0FBQ1YsdUJBQXVCLDZDQUFZLFNBQVMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMENBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0MsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0NBQWtDLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQW9CO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1FQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0MsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDBDQUFTO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFxQjtBQUNwQyxLQUFLO0FBQ0wsV0FBVyxvRUFBMkI7QUFDdEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLCtDQUFjLENBQUMsK0NBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsaURBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU8sVUFBVSxvRUFBMkIsQ0FBQyxrREFBcUIsYUFBYTtBQUNwRyxxQkFBcUIsT0FBTyxVQUFVLG9FQUEyQixDQUFDLGtEQUFxQixhQUFhO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLFNBQVM7QUFDVCxxQkFBcUIsS0FBSyxFQUFFLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsaURBQWdCO0FBQzlELGtCQUFrQixNQUFNO0FBQ3hCLHNFQUFzRSx5Q0FBUSxRQUFRLFVBQVUsS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUl0ZW0uanM/YWU4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2FiaUl0ZW0uanMnO1xuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19IGludG8gYSAqKkh1bWFuIFJlYWRhYmxlIEFCSSBJdGVtKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpSXRlbS5mb3JtYXQoe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9KVxuICpcbiAqIGZvcm1hdHRlZFxuICogLy8gICAgXj9cbiAqXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBBQkkgSXRlbSAgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUl0ZW0pIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gYXJiaXRyYXJ5ICoqSlNPTiBBQkkgSXRlbSoqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEl0ZW0qKiBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9KVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgQUJJc1xuICpcbiAqIEEgSHVtYW4gUmVhZGFibGUgQUJJIGNhbiBiZSBwYXJzZWQgaW50byBhIHR5cGVkIEFCSSBvYmplY3Q6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKFxuICogICAnZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50KSByZXR1cm5zIChib29sKScgLy8gWyFjb2RlIGhsXVxuICogKVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBgc3RydWN0YHMgYWxvbmcgd2l0aCB5b3VyIGRlZmluaXRpb25zOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhYmlJdGVtXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBJdGVtIHRvIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHR5cGVkIEFCSSBJdGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlJdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXBhcmUgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhYmlJdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpSXRlbShhYmlJdGVtKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhYmlJdGVtID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpSXRlbShhYmlJdGVtKTtcbiAgICAgICAgcmV0dXJuIGFiaUl0ZW07XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChpdGVtKSB9IDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGFuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19IGZyb20gYW4ge0BsaW5rIG94I0FiaS5BYml9IGdpdmVuIGEgbmFtZSBhbmQgb3B0aW9uYWwgYXJndW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBBQkkgSXRlbXMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICpcbiAqIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCAnVHJhbnNmZXInKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEl0ZW1zIGNhbiBiZSBleHRyYWN0IGJ5IHRoZWlyIHNlbGVjdG9yIHdoZW4ge0BsaW5rIG94I0hleC5IZXh9IGlzIHByb3ZpZGVkIHRvIGBuYW1lYC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEV4dHJhY3RpbmcgdmlhIGEgaGV4IHNlbGVjdG9yIGlzIHVzZWZ1bCB3aGVuIGV4dHJhY3RpbmcgYW4gQUJJIEl0ZW0gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSxcbiAqIGEgVHJhbnNhY3Rpb24gYGlucHV0YCwgb3IgZnJvbSBFdmVudCBMb2cgYHRvcGljc2AuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncyA9IFtdLCBwcmVwYXJlID0gdHJ1ZSB9ID0gKG9wdGlvbnMgPz9cbiAgICAgICAge30pO1xuICAgIGNvbnN0IGlzU2VsZWN0b3IgPSBIZXgudmFsaWRhdGUobmFtZSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGFiaUl0ZW1zID0gYWJpLmZpbHRlcigoYWJpSXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXNTZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBhYmlJdGVtLnR5cGUgPT09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNlbGVjdG9yKGFiaUl0ZW0pID09PSBIZXguc2xpY2UobmFtZSwgMCwgNCk7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZXZlbnQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pID09PSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbmFtZScgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLm5hbWUgPT09IG5hbWU7XG4gICAgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoeyBuYW1lOiBuYW1lIH0pO1xuICAgIGlmIChhYmlJdGVtcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5hYmlJdGVtc1swXSxcbiAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW1zWzBdKSB9IDoge30pLFxuICAgICAgICB9O1xuICAgIGxldCBtYXRjaGVkQWJpSXRlbTtcbiAgICBmb3IgKGNvbnN0IGFiaUl0ZW0gb2YgYWJpSXRlbXMpIHtcbiAgICAgICAgaWYgKCEoJ2lucHV0cycgaW4gYWJpSXRlbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWFiaUl0ZW0uaW5wdXRzIHx8IGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSB9IDoge30pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFiaUl0ZW0uaW5wdXRzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChhYmlJdGVtLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGFyZ3MuZXZlcnkoKGFyZywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9ICdpbnB1dHMnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFhYmlQYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLmlzQXJnT2ZUeXBlKGFyZywgYWJpUGFyYW1ldGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYW1iaWd1aXR5IGFnYWluc3QgYWxyZWFkeSBtYXRjaGVkIHBhcmFtZXRlcnMgKGUuZy4gYGFkZHJlc3NgIHZzIGBieXRlczIwYCkuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0gJiZcbiAgICAgICAgICAgICAgICAnaW5wdXRzJyBpbiBtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgIG1hdGNoZWRBYmlJdGVtLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFtYmlndW91c1R5cGVzID0gaW50ZXJuYWwuZ2V0QW1iaWd1b3VzVHlwZXMoYWJpSXRlbS5pbnB1dHMsIG1hdGNoZWRBYmlJdGVtLmlucHV0cywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKGFtYmlndW91c1R5cGVzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFtYmlndW91c1R5cGVzWzBdLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtOiBtYXRjaGVkQWJpSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFtYmlndW91c1R5cGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZWRBYmlJdGVtID0gYWJpSXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRBYmlJdGVtO1xuICAgICAgICBjb25zdCBbYWJpSXRlbSwgLi4ub3ZlcmxvYWRzXSA9IGFiaUl0ZW1zO1xuICAgICAgICByZXR1cm4geyAuLi5hYmlJdGVtLCBvdmVybG9hZHMgfTtcbiAgICB9KSgpO1xuICAgIGlmICghYWJpSXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoeyBuYW1lOiBuYW1lIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZV0gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIGZyb21BYmkoYWJpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBIZXguc2xpY2UoZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSwgMCwgNCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhYmlJdGVtID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBhYmlJdGVtO1xuICAgICAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduYXR1cmVIYXNoKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWVdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBmcm9tQWJpKGFiaSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgfSkoKTtcbiAgICBpZiAodHlwZW9mIGFiaUl0ZW0gIT09ICdzdHJpbmcnICYmICdoYXNoJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaGFzaClcbiAgICAgICAgcmV0dXJuIGFiaUl0ZW0uaGFzaDtcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoZ2V0U2lnbmF0dXJlKGFiaUl0ZW0pKSk7XG59XG4vKipcbiAqIFRocm93cyB3aGVuIGFtYmlndW91cyB0eXBlcyBhcmUgZm91bmQgb24gb3ZlcmxvYWRlZCBBQkkgaXRlbXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oWydmdW5jdGlvbiBmb28oYWRkcmVzcyknLCAnZnVuY3Rpb24gZm9vKGJ5dGVzMjApJ10pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2ZvbycsIHtcbiAqICAgYXJnczogWycweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uQW1iaWd1aXR5RXJyb3I6IEZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy5cbiAqIC8vIEBlcnJvcjogYGJ5dGVzMjBgIGluIGBmb28oYnl0ZXMyMClgLCBhbmRcbiAqIC8vIEBlcnJvcjogYGFkZHJlc3NgIGluIGBmb28oYWRkcmVzcylgXG4gKiAvLyBAZXJyb3I6IFRoZXNlIHR5cGVzIGVuY29kZSBkaWZmZXJlbnRseSBhbmQgY2Fubm90IGJlIGRpc3Rpbmd1aXNoZWQgYXQgcnVudGltZS5cbiAqIC8vIEBlcnJvcjogUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgdHlwZXMgZnJvbSB0aGUgQUJJLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGZvbyhieXRlczIwKScgLy8gWyFjb2RlIC0tXVxuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnZm9vJywge1xuICogICBhcmdzOiBbJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSddLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcjogRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLlxuICogLy8gQGVycm9yOiBgYnl0ZXMyMGAgaW4gYGZvbyhieXRlczIwKWAsIGFuZFxuICogLy8gQGVycm9yOiBgYWRkcmVzc2AgaW4gYGZvbyhhZGRyZXNzKWBcbiAqIC8vIEBlcnJvcjogVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlxuICogLy8gQGVycm9yOiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQW1iaWd1aXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgIHN1cGVyKCdGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuJywge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWJpdHlwZSB0byBhZGQgc3VwcG9ydCBmb3Igc2lnbmF0dXJlLWZvcm1hdHRlZCBBQkkgaXRlbXMuXG4gICAgICAgICAgICAgICAgYFxcYCR7eC50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeC5hYmlJdGVtKSl9XFxgLCBhbmRgLFxuICAgICAgICAgICAgICAgIGBcXGAke3kudHlwZX1cXGAgaW4gXFxgJHtpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoYWJpdHlwZS5mb3JtYXRBYmlJdGVtKHkuYWJpSXRlbSkpfVxcYGAsXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgJ1RoZXNlIHR5cGVzIGVuY29kZSBkaWZmZXJlbnRseSBhbmQgY2Fubm90IGJlIGRpc3Rpbmd1aXNoZWQgYXQgcnVudGltZS4nLFxuICAgICAgICAgICAgICAgICdSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLkFtYmlndWl0eUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIGFuIEFCSSBpdGVtIGlzIG5vdCBmb3VuZCBpbiB0aGUgQUJJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2JheicpXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uTm90Rm91bmRFcnJvcjogQUJJIGZ1bmN0aW9uIHdpdGggbmFtZSBcImJhelwiIG5vdCBmb3VuZC5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIEVuc3VyZSB0aGUgQUJJIGl0ZW0gZXhpc3RzIG9uIHRoZSBBQkkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknLFxuICogICAnZnVuY3Rpb24gYmF6KGJvb2wpJyAvLyBbIWNvZGUgKytdXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdiYXonKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBuYW1lLCBkYXRhLCB0eXBlID0gJ2l0ZW0nLCB9KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggbmFtZSBcIiR7bmFtZX1cImA7XG4gICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCB3aXRoIGRhdGEgXCIke2RhdGF9XCJgO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KSgpO1xuICAgICAgICBzdXBlcihgQUJJICR7dHlwZX0ke3NlbGVjdG9yfSBub3QgZm91bmQuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLk5vdEZvdW5kRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gdGhlIHNlbGVjdG9yIHNpemUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnMHhhYWEnKVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcjogU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAyIGJ5dGVzIChcIjB4YWFhXCIpLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBzZWxlY3RvciBzaXplIGlzIDQgYnl0ZXMuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICcweDdhZjgyYjFhJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoYFNlbGVjdG9yIHNpemUgaXMgaW52YWxpZC4gRXhwZWN0ZWQgNCBieXRlcy4gUmVjZWl2ZWQgJHtIZXguc2l6ZShkYXRhKX0gYnl0ZXMgKFwiJHtkYXRhfVwiKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n            parameters: parameters,\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_4__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size, 10),\n                    value: value,\n                });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nfunction format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nclass DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nclass ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nclass ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nclass BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nclass LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nclass InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nclass InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDSjtBQUNFO0FBQ047QUFDd0I7QUFDVDtBQUNMO0FBQzFDO0FBQ08sOENBQThDO0FBQ3JELFlBQVksd0NBQXdDO0FBQ3BELDZDQUE2Qyw4Q0FBYTtBQUMxRCxtQkFBbUIsdURBQWE7QUFDaEMsUUFBUSwyQ0FBVTtBQUNsQjtBQUNBLFFBQVEsMkNBQVUsV0FBVywyQ0FBVTtBQUN2QztBQUNBLG9EQUFvRCw4Q0FBYTtBQUNqRTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLGtDQUFrQyx1RUFBd0I7QUFDMUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkMsU0FBUywyQkFBMkI7QUFDcEMsU0FBUywrQkFBK0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQix5RUFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiw4REFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBYztBQUMxQixtQkFBbUIsNENBQVc7QUFDOUI7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQVcsQ0FBQyxnREFBZTtBQUM5QyxvQ0FBb0Msc0RBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBYztBQUNqQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0NBQXNDLG9EQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsbUJBQW1CLDZDQUFZO0FBQy9CO0FBQ0Esc0NBQXNDLG9EQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJDQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHdEQUEyQjtBQUN0QztBQUNBO0FBQ0EsNkZBQTZGLHFDQUFxQztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQscUNBQXFDO0FBQ2xHO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQixpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsdURBQTBCO0FBQ3pDO0FBQ0EsZUFBZSx1REFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDTyxvQ0FBb0MsaURBQWdCO0FBQzNELGtCQUFrQix5QkFBeUI7QUFDM0MsOEJBQThCLE1BQU07QUFDcEM7QUFDQSw0QkFBNEIsd0RBQTJCLGFBQWE7QUFDcEUsMkJBQTJCLE1BQU0sR0FBRyxNQUFNO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsaURBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsaURBQWdCO0FBQzlELGtCQUFrQixvQ0FBb0M7QUFDdEQsa0RBQWtELEtBQUssa0JBQWtCLGVBQWUsZUFBZSxZQUFZO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxpREFBZ0I7QUFDNUQsa0JBQWtCLHNCQUFzQjtBQUN4QyxnQ0FBZ0MsTUFBTSxVQUFVLHlDQUFRLFFBQVEsdUNBQXVDLGFBQWE7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVELHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RDtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLGlEQUFnQjtBQUN0RDtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpUGFyYW1ldGVycy5qcz85OGVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG5pbXBvcnQgKiBhcyBTb2xpZGl0eSBmcm9tICcuL1NvbGlkaXR5LmpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHBhcmFtZXRlcnMsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQXJyYXknLCBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoZGF0YSkgOiBkYXRhO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUoYnl0ZXMpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSA9PT0gMCAmJiBwYXJhbWV0ZXJzLmxlbmd0aCA+IDApXG4gICAgICAgIHRocm93IG5ldyBaZXJvRGF0YUVycm9yKCk7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpICYmIEJ5dGVzLnNpemUoYnl0ZXMpIDwgMzIpXG4gICAgICAgIHRocm93IG5ldyBEYXRhU2l6ZVRvb1NtYWxsRXJyb3Ioe1xuICAgICAgICAgICAgZGF0YTogdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IEhleC5mcm9tQnl0ZXMoZGF0YSksXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZShieXRlcyksXG4gICAgICAgIH0pO1xuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWVzID0gYXMgPT09ICdBcnJheScgPyBbXSA6IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJhbSA9IHBhcmFtZXRlcnNbaV07XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihjb25zdW1lZCk7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gaW50ZXJuYWwuZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICBpZiAoYXMgPT09ICdBcnJheScpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWVzW3BhcmFtLm5hbWUgPz8gaV0gPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIHByaW1pdGl2ZSB2YWx1ZXMgaW50byBBQkkgZW5jb2RlZCBkYXRhIGFzIHBlciB0aGUgW0FwcGxpY2F0aW9uIEJpbmFyeSBJbnRlcmZhY2UgKEFCSSkgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpUGFyYW1ldGVycy5lbmNvZGUoXG4gKiAgIEFiaVBhcmFtZXRlcnMuZnJvbShbJ3N0cmluZycsICd1aW50JywgJ2Jvb2wnXSksXG4gKiAgIFsnd2FnbWknLCA0MjBuLCB0cnVlXSxcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSlNPTiBQYXJhbWV0ZXJzXG4gKlxuICogU3BlY2lmeSAqKkpTT04gQUJJKiogUGFyYW1ldGVycyBhcyBzY2hlbWE6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpUGFyYW1ldGVycy5lbmNvZGUoXG4gKiAgIFtcbiAqICAgICB7IHR5cGU6ICdzdHJpbmcnLCBuYW1lOiAnbmFtZScgfSxcbiAqICAgICB7IHR5cGU6ICd1aW50JywgbmFtZTogJ2FnZScgfSxcbiAqICAgICB7IHR5cGU6ICdib29sJywgbmFtZTogJ2lzT3duZXInIH0sXG4gKiAgIF0sXG4gKiAgIFsnd2FnbWknLCA0MjBuLCB0cnVlXSxcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIHNldCBvZiBBQkkgcGFyYW1ldGVycyB0byBlbmNvZGUsIGluIHRoZSBzaGFwZSBvZiB0aGUgYGlucHV0c2Agb3IgYG91dHB1dHNgIGF0dHJpYnV0ZSBvZiBhbiBBQkkgSXRlbS4gVGhlc2UgcGFyYW1ldGVycyBtdXN0IGluY2x1ZGUgdmFsaWQgW0FCSSB0eXBlc10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L3R5cGVzLmh0bWwpLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXQgb2YgcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIEFCSSB0eXBlcyBkZWZpbmVkIGluIGBwYXJhbWV0ZXJzYC5cbiAqIEByZXR1cm5zIEFCSSBlbmNvZGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUocGFyYW1ldGVycywgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBpZiAocGFyYW1ldGVycy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBwYXJhbWV0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAvLyBQcmVwYXJlIHRoZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSBkeW5hbWljIHR5cGVzIHRvIGVuY29kZS5cbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBpbnRlcm5hbC5wcmVwYXJlUGFyYW1ldGVycyh7XG4gICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGludGVybmFsLmVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIEVuY29kZXMgYW4gYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlcyB0byBhIFtwYWNrZWQgQUJJIGVuY29kaW5nXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvYWJpLXNwZWMuaHRtbCNub24tc3RhbmRhcmQtcGFja2VkLW1vZGUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVuY29kZWQgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZVBhY2tlZChcbiAqICAgWydhZGRyZXNzJywgJ3N0cmluZyddLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsICdoZWxsbyB3b3JsZCddLFxuICogKVxuICogLy8gQGxvZzogJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHlwZXMgLSBTZXQgb2YgQUJJIHR5cGVzIHRvIHBhY2sgZW5jb2RlLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXQgb2YgcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIEFCSSB0eXBlcyBkZWZpbmVkIGluIGB0eXBlc2AuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBwYWNrZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVBhY2tlZCh0eXBlcywgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHR5cGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBkYXRhLnB1c2goZW5jb2RlUGFja2VkLmVuY29kZSh0eXBlLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5kYXRhKTtcbn1cbihmdW5jdGlvbiAoZW5jb2RlUGFja2VkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBlbmNvZGUodHlwZSwgdmFsdWUsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdmFsdWU7XG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChhZGRyZXNzLnRvTG93ZXJDYXNlKCksIGlzQXJyYXkgPyAzMiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSksIGlzQXJyYXkgPyAzMiA6IDEpO1xuICAgICAgICBjb25zdCBpbnRNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuaW50ZWdlclJlZ2V4KTtcbiAgICAgICAgaWYgKGludE1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGJhc2VUeXBlLCBiaXRzID0gJzI1NiddID0gaW50TWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KGJpdHMsIDEwKSAvIDg7XG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21OdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBpc0FycmF5ID8gMzIgOiBzaXplLFxuICAgICAgICAgICAgICAgIHNpZ25lZDogYmFzZVR5cGUgPT09ICdpbnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXNNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYnl0ZXNSZWdleCk7XG4gICAgICAgIGlmIChieXRlc01hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIHNpemVdID0gYnl0ZXNNYXRjaDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApICE9PSAodmFsdWUubGVuZ3RoIC0gMikgLyAyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZFJpZ2h0KHZhbHVlLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5hcnJheVJlZ2V4KTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgY2hpbGRUeXBlXSA9IGFycmF5TWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVuY29kZShjaGlsZFR5cGUsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgICAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgZW5jb2RlUGFja2VkLmVuY29kZSA9IGVuY29kZTtcbn0pKGVuY29kZVBhY2tlZCB8fCAoZW5jb2RlUGFja2VkID0ge30pKTtcbi8qKlxuICogRm9ybWF0cyB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy5BYmlQYXJhbWV0ZXJzfSBpbnRvICoqSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnMqKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlQYXJhbWV0ZXJzLmZvcm1hdChbXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICB9LFxuICogICB7XG4gKiAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICB9LFxuICogXSlcbiAqXG4gKiBmb3JtYXR0ZWRcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIEFCSSBQYXJhbWV0ZXJzIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIFBhcmFtZXRlcnMgIC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbn1cbi8qKlxuICogUGFyc2VzIGFyYml0cmFyeSAqKkpTT04gQUJJIFBhcmFtZXRlcnMqKiBvciAqKkh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzKiogaW50byB0eXBlZCB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy5BYmlQYXJhbWV0ZXJzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gUGFyYW1ldGVyc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbShbXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICB9LFxuICogICB7XG4gKiAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICB9LFxuICogXSlcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBQYXJhbWV0ZXJzXG4gKlxuICogSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnMgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc306XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50JylcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oW1xuICogICAnc3RydWN0IEZvbyB7IGFkZHJlc3Mgc3BlbmRlcjsgdWludDI1NiBhbW91bnQ7IH0nLCAvLyBbIWNvZGUgaGxdXG4gKiAgICdGb28gZm9vLCBhZGRyZXNzIGJhcicsXG4gKiBdKVxuICpcbiAqIHBhcmFtZXRlcnNcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBUaGUgQUJJIFBhcmFtZXRlcnMgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQUJJIFBhcmFtZXRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSAmJiB0eXBlb2YgcGFyYW1ldGVyc1swXSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHRoZSBkYXRhIHNpemUgaXMgdG9vIHNtYWxsIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4p2MIDIgYnl0ZXNcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3I6IERhdGEgc2l6ZSBvZiAyIGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5cbiAqIC8vIEBlcnJvcjogUGFyYW1zOiAodWludDI1NilcbiAqIC8vIEBlcnJvcjogRGF0YTogICAweDAxMGYgKDIgYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGEgdmFsaWQgZGF0YSBzaXplLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIDMyIGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFTaXplVG9vU21hbGxFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZGF0YSwgcGFyYW1ldGVycywgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgRGF0YSBzaXplIG9mICR7c2l6ZX0gYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBQYXJhbXM6ICgke2FiaXR5cGUuZm9ybWF0QWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKX0pYCxcbiAgICAgICAgICAgICAgICBgRGF0YTogICAke2RhdGF9ICgke3NpemV9IGJ5dGVzKWAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHplcm8gZGF0YSBpcyBwcm92aWRlZCwgYnV0IGRhdGEgaXMgZXhwZWN0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCB6ZXJvIGRhdGFcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3I6IERhdGEgc2l6ZSBvZiAyIGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5cbiAqIC8vIEBlcnJvcjogUGFyYW1zOiAodWludDI1NilcbiAqIC8vIEBlcnJvcjogRGF0YTogICAweDAxMGYgKDIgYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIHZhbGlkIGRhdGEuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgMzIgYnl0ZXNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgWmVyb0RhdGFFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ2Fubm90IGRlY29kZSB6ZXJvIGRhdGEgKFwiMHhcIikgd2l0aCBBQkkgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuWmVyb0RhdGFFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgbGVuZ3RoIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ3VpbnQyNTZbM10nKSwgW1s2OW4sIDQyMG5dXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgZXhwZWN0ZWQ6IDMgIOKGkSDinYwgbGVuZ3RoOiAyXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yOiBBQkkgZW5jb2RpbmcgYXJyYXkgbGVuZ3RoIG1pc21hdGNoXG4gKiAvLyBAZXJyb3I6IGZvciB0eXBlIGB1aW50MjU2WzNdYC4gRXhwZWN0ZWQ6IGAzYC4gR2l2ZW46IGAyYC5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYW4gYXJyYXkgb2YgdGhlIGNvcnJlY3QgbGVuZ3RoLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ3VpbnQyNTZbM10nXSksIFtbNjluLCA0MjBuLCA2OW5dXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSBsZW5ndGg6IDNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYEFycmF5IGxlbmd0aCBtaXNtYXRjaCBmb3IgdHlwZSBcXGAke3R5cGV9XFxgLiBFeHBlY3RlZDogXFxgJHtleHBlY3RlZExlbmd0aH1cXGAuIEdpdmVuOiBcXGAke2dpdmVuTGVuZ3RofVxcYC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBzaXplIG9mIHRoZSBieXRlcyB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCdieXRlczgnKSwgW1snMHhkZWFkYmVlZmRlYWRiZWVmZGVhZGJlZWYnXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIGV4cGVjdGVkOiA4IGJ5dGVzICDihpEg4p2MIHNpemU6IDEyIGJ5dGVzXG4gKiAvLyBAZXJyb3I6IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3I6IFNpemUgb2YgYnl0ZXMgXCIweGRlYWRiZWVmZGVhZGJlZWZkZWFkYmVlZlwiXG4gKiAvLyBAZXJyb3I6IChieXRlczEyKSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBzaXplIChieXRlczgpLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIGJ5dGVzIHZhbHVlIG9mIHRoZSBjb3JyZWN0IHNpemUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsnYnl0ZXM4J10pLCBbJzB4ZGVhZGJlZWZkZWFkYmVlZiddKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSBzaXplOiA4IGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkU2l6ZSwgdmFsdWUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgb2YgYnl0ZXMgXCIke3ZhbHVlfVwiIChieXRlcyR7SGV4LnNpemUodmFsdWUpfSkgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXMke2V4cGVjdGVkU2l6ZX0pLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBsZW5ndGggb2YgdGhlIHZhbHVlcyB0byBlbmNvZGUgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgQUJJIHBhcmFtZXRlcnMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ3N0cmluZycsICd1aW50MjU2J10pLCBbJ2hlbGxvJ10pXG4gKiAvLyBAZXJyb3I6IExlbmd0aE1pc21hdGNoRXJyb3I6IEFCSSBlbmNvZGluZyBwYXJhbXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC5cbiAqIC8vIEBlcnJvcjogRXhwZWN0ZWQgbGVuZ3RoIChwYXJhbXMpOiAyXG4gKiAvLyBAZXJyb3I6IEdpdmVuIGxlbmd0aCAodmFsdWVzKTogMVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyB0aGUgY29ycmVjdCBudW1iZXIgb2YgdmFsdWVzIHRvIGVuY29kZS5cbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGEgW3ZhbGlkIEFCSSB0eXBlXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9kZXZlbG9wL2FiaS1zcGVjLmh0bWwjdHlwZXMpLlxuICovXG5leHBvcnQgY2xhc3MgTGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRMZW5ndGgsIGdpdmVuTGVuZ3RoLCB9KSB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgICdBQkkgZW5jb2RpbmcgcGFyYW1ldGVycy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoLicsXG4gICAgICAgICAgICBgRXhwZWN0ZWQgbGVuZ3RoIChwYXJhbWV0ZXJzKTogJHtleHBlY3RlZExlbmd0aH1gLFxuICAgICAgICAgICAgYEdpdmVuIGxlbmd0aCAodmFsdWVzKTogJHtnaXZlbkxlbmd0aH1gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuTGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGEgdmFsaWQgYXJyYXkgYXMgc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ3VpbnQyNTZbM10nXSksIFs2OV0pXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGFuIGFycmF5IHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFycmF5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGEgdmFsaWQgYXJyYXkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHRoZSBBQkkgcGFyYW1ldGVyIHR5cGUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAnbG9sJyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4p2MIGludmFsaWQgdHlwZVxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3I6IFR5cGUgYGxvbGAgaXMgbm90IGEgdmFsaWQgQUJJIFR5cGUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHN1cGVyKGBUeXBlIFxcYCR7dHlwZX1cXGAgaXMgbm90IGEgdmFsaWQgQUJJIFR5cGUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"(ssr)/./node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nfunction checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address))\n        return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (optionally checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: true\n * })\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nfunction isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nclass InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nclass InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nclass InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNBO0FBQ0o7QUFDVTtBQUM1QyxxQ0FBcUMsR0FBRztBQUN4QztBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsZ0RBQWU7QUFDdkIsZUFBZSxnREFBZTtBQUM5QixzQkFBc0IsZUFBZTtBQUNyQztBQUNBLGlCQUFpQiwrQ0FBYyxDQUFDLGlEQUFnQixnQkFBZ0IsYUFBYTtBQUM3RTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QyxJQUFJLGdEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx5QkFBeUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNPLDhDQUE4QztBQUNyRCxvQkFBb0IsK0NBQWMsTUFBTSxnREFBZSxxQkFBcUI7QUFDNUUscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLGVBQWU7QUFDdEMsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsZ0JBQWdCO0FBQ2xDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsaURBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanM/MTU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIENhY2hlcyBmcm9tICcuL0NhY2hlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgUHVibGljS2V5IGZyb20gJy4vUHVibGljS2V5LmpzJztcbmNvbnN0IGFkZHJlc3NSZWdleCA9IC9eMHhbYS1mQS1GMC05XXs0MH0kLztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhkZWFkYmVlZlwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQgaWYgaXQgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBc3NlcnRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgfSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGVja3N1bSh2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENoZWNrc3VtRXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNoZWNrc3VtIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmNoZWNrc3VtKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gY29tcHV0ZSB0aGUgY2hlY2tzdW0gZm9yLlxuICogQHJldHVybnMgVGhlIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja3N1bShhZGRyZXNzKSB7XG4gICAgaWYgKENhY2hlcy5jaGVja3N1bS5oYXMoYWRkcmVzcykpXG4gICAgICAgIHJldHVybiBDYWNoZXMuY2hlY2tzdW0uZ2V0KGFkZHJlc3MpO1xuICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgaGV4QWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmZyb21TdHJpbmcoaGV4QWRkcmVzcyksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgY29uc3QgY2hhcmFjdGVycyA9IGhleEFkZHJlc3Muc3BsaXQoJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGFzaFtpID4+IDFdID4+IDQgPj0gOCAmJiBjaGFyYWN0ZXJzW2ldKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gY2hhcmFjdGVyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaFtpID4+IDFdICYgMHgwZikgPj0gOCAmJiBjaGFyYWN0ZXJzW2kgKyAxXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpICsgMV0gPSBjaGFyYWN0ZXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAweCR7Y2hhcmFjdGVycy5qb2luKCcnKX1gO1xuICAgIENhY2hlcy5jaGVja3N1bS5zZXQoYWRkcmVzcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZ2lmaWVkIGFkZHJlc3MgdG8gYSB0eXBlZCAob3B0aW9uYWxseSBjaGVja3N1bW1lZCkge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5mcm9tKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJywge1xuICogICBjaGVja3N1bTogdHJ1ZVxuICogfSlcbiAqIC8vIEBsb2c6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJ2hlbGxvJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZEFkZHJlc3NFcnJvcjogQWRkcmVzcyBcIjB4YVwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIEFuIGFkZHJlc3Mgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSB0eXBlZCBBZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb252ZXJzaW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGVja3N1bTogY2hlY2tzdW1WYWwgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBhc3NlcnQoYWRkcmVzcyk7XG4gICAgaWYgKGNoZWNrc3VtVmFsKVxuICAgICAgICByZXR1cm4gY2hlY2tzdW0oYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIEVDRFNBIHB1YmxpYyBrZXkgdG8gYW4ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbShcbiAqICAgJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScsXG4gKiApXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KHB1YmxpY0tleSlcbiAqIC8vIEBsb2c6ICcweGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIEVDRFNBIHB1YmxpYyBrZXkgdG8gY29udmVydCB0byBhbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29udmVyc2lvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUHVibGljS2V5KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IEhhc2gua2VjY2FrMjU2KGAweCR7UHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoNCl9YCkuc3Vic3RyaW5nKDI2KTtcbiAgICByZXR1cm4gZnJvbShgMHgke2FkZHJlc3N9YCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30gYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuaXNFcXVhbChcbiAqICAgJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsXG4gKiAgICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiApXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmlzRXF1YWwoXG4gKiAgICcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnLFxuICogICAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFmJ1xuICogKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzQSAtIFRoZSBmaXJzdCBhZGRyZXNzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYWRkcmVzc0IgLSBUaGUgc2Vjb25kIGFkZHJlc3MgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFkZHJlc3NlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGFkZHJlc3NBLCBhZGRyZXNzQikge1xuICAgIGFzc2VydChhZGRyZXNzQSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGFzc2VydChhZGRyZXNzQiwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIHJldHVybiBhZGRyZXNzQS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzQi50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgYSB2YWxpZCB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLnZhbGlkYXRlKCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENoZWNrIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoYWRkcmVzcywgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4MTIzJylcbiAqIC8vIEBlcnJvcjogQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIGAweDEyM2AgaXMgaW52YWxpZC5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFkZHJlc3NFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcywgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcihgQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZEFkZHJlc3NFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgaXMgbm90IGEgMjAgYnl0ZSAoNDAgaGV4YWRlY2ltYWwgY2hhcmFjdGVyKSB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW5wdXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkSW5wdXRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDaGVja3N1bUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGRvZXMgbm90IG1hdGNoIGl0cyBjaGVja3N1bSBjb3VudGVycGFydC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZENoZWNrc3VtRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === '0x' ? 0 : Number(chainId),\n        nonce: nonce === '0x' ? 0n : BigInt(nonce),\n    };\n    if (yParity && r && s)\n        args = { ...args, ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([yParity, r, s]) };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization, { presign: true });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nfunction hash(authorization, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat('0x05', _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign\n        ? {\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: authorization.nonce,\n        }\n        : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nfunction toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : '0x',\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : '0x',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nfunction toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0Y7QUFDQTtBQUNZO0FBQzVDO0FBQ0Esc0dBQXNHLHFDQUFxQztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4QkFBOEI7QUFDcEMsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFDQUFxQztBQUN0RDtBQUNPLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCLE9BQU8scUNBQXFDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNPO0FBQ1AsWUFBWSwwQkFBMEI7QUFDdEMsc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQyxPQUFPLDRCQUE0QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEIsT0FBTyxxQ0FBcUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3REO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZLG9EQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLE9BQU8sNEJBQTRCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQSxxRUFBcUUscUNBQXFDO0FBQzFHLGlEQUFpRCxtQ0FBbUM7QUFDcEY7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDTztBQUNQLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDTyx5Q0FBeUM7QUFDaEQsWUFBWSxVQUFVO0FBQ3RCLFdBQVcsK0NBQWMsQ0FBQywyQ0FBVSxTQUFTLDRDQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDLE9BQU8sMkJBQTJCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBYztBQUMvQixlQUFlLCtDQUFjO0FBQzdCLFdBQVcsZ0RBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QixPQUFPLCtCQUErQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0MsT0FBTyw2QkFBNkI7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDTztBQUNQLFlBQVksMEJBQTBCO0FBQ3RDLHNCQUFzQixrREFBaUI7QUFDdkM7QUFDQSxrQkFBa0IsK0NBQWM7QUFDaEM7QUFDQSxnQkFBZ0IsK0NBQWM7QUFDOUIsd0JBQXdCLGtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCLE9BQU8saUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BdXRob3JpemF0aW9uLmpzPzc0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiBvYmplY3QgaW50byBhIHR5cGVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBBbiBBdXRob3JpemF0aW9uIGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBjYW4gYmUgYXR0YWNoZWQgd2l0aCB0aGUgYHNpZ25hdHVyZWAgb3B0aW9uLiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgc2lnbmluZ1xuICogYW4gQXV0aG9yaXphdGlvbiB3aXRoIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQXV0aG9yaXphdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGF1dGhvcml6YXRpb24uY2hhaW5JZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tUnBjKGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7IC4uLmF1dGhvcml6YXRpb24sIC4uLm9wdGlvbnMuc2lnbmF0dXJlIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVJwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbi5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdFJwY30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21ScGNMaXN0KFt7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbkxpc3QgLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uIGxpc3QuXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcChmcm9tUnBjKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGV9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MydcbiAqIF0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogM25cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnLFxuICogICAnMHgxJyxcbiAqICAgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsXG4gKiAgICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnLFxuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW2NoYWluSWQsIGFkZHJlc3MsIG5vbmNlLCB5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBjaGFpbklkID09PSAnMHgnID8gMCA6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IG5vbmNlID09PSAnMHgnID8gMG4gOiBCaWdJbnQobm9uY2UpLFxuICAgIH07XG4gICAgaWYgKHlQYXJpdHkgJiYgciAmJiBzKVxuICAgICAgICBhcmdzID0geyAuLi5hcmdzLCAuLi5TaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgfTtcbiAgICByZXR1cm4gZnJvbShhcmdzKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGVMaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZUxpc3QgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdCh0dXBsZUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0dXBsZSBvZiB0dXBsZUxpc3QpXG4gICAgICAgIGxpc3QucHVzaChmcm9tVHVwbGUodHVwbGUpKTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gaW4gW0VJUC03NzAyIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKTogYGtlY2NhazI1NignMHgwNScgfHwgcmxwKFtjaGFpbl9pZCwgYWRkcmVzcywgbm9uY2VdKSlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgY29tcHV0aW5nIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LiBUaGlzIHBheWxvYWRcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byBzaWduaW5nIGZ1bmN0aW9ucyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gaGFzaChhdXRob3JpemF0aW9uLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUocHJlc2lnblxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IGF1dGhvcml6YXRpb24uY2hhaW5JZCxcbiAgICAgICAgICAgIG5vbmNlOiBhdXRob3JpemF0aW9uLm5vbmNlLFxuICAgICAgICB9XG4gICAgICAgIDogYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogSGV4LmZyb21OdW1iZXIobm9uY2UpLFxuICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIEFuIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBMaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCh0b1JwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjaGFpbklkID8gSGV4LmZyb21OdW1iZXIoY2hhaW5JZCkgOiAnMHgnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl8yID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGVMaXN0KGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0dXBsZUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgbGlzdClcbiAgICAgICAgdHVwbGVMaXN0LnB1c2godG9UdXBsZShhdXRob3JpemF0aW9uKSk7XG4gICAgcmV0dXJuIHR1cGxlTGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFDYztBQUM5QztBQUNBLGdCQUFnQiw2QkFBNkIsT0FBTyx1Q0FBdUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJEQUEyRCxtREFBa0I7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0MsT0FBTyw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQWM7QUFDekMsU0FBUztBQUNUO0FBQ0EseUJBQXlCLCtDQUFjO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLCtDQUFjO0FBQ3BDLFNBQVM7QUFDVDtBQUNBLG9CQUFvQiwrQ0FBYztBQUNsQyxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsK0NBQWM7QUFDdEMsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLCtDQUFjO0FBQ2hDLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCxpREFBZ0I7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzPzJlNTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFdpdGhkcmF3YWwgZnJvbSAnLi9XaXRoZHJhd2FsLmpzJztcbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLlJwY30gdG8gYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJsb2NrT3ZlcnJpZGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvY2tPdmVycmlkZXMgPSBCbG9ja092ZXJyaWRlcy5mcm9tUnBjKHtcbiAqICAgYmFzZUZlZVBlckdhczogJzB4MScsXG4gKiAgIGJsb2JCYXNlRmVlOiAnMHgyJyxcbiAqICAgZmVlUmVjaXBpZW50OiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgZ2FzTGltaXQ6ICcweDQnLFxuICogICBudW1iZXI6ICcweDUnLFxuICogICBwcmV2UmFuZGFvOiAnMHg2JyxcbiAqICAgdGltZTogJzB4MTIzNDU2Nzg5MCcsXG4gKiAgIHdpdGhkcmF3YWxzOiBbXG4gKiAgICAge1xuICogICAgICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgICBhbW91bnQ6ICcweDEnLFxuICogICAgICAgaW5kZXg6ICcweDAnLFxuICogICAgICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHJwY0Jsb2NrT3ZlcnJpZGVzIC0gVGhlIFJQQyBibG9jayBvdmVycmlkZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuQmxvY2tPdmVycmlkZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhycGNCbG9ja092ZXJyaWRlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSAmJiB7XG4gICAgICAgICAgICBibG9iQmFzZUZlZTogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQgJiYge1xuICAgICAgICAgICAgZmVlUmVjaXBpZW50OiBycGNCbG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgJiYge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyICYmIHtcbiAgICAgICAgICAgIG51bWJlcjogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLm51bWJlciksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMudGltZSAmJiB7XG4gICAgICAgICAgICB0aW1lOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IHJwY0Jsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLmZyb21ScGMpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuQmxvY2tPdmVycmlkZXN9IHRvIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvY2tPdmVycmlkZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBibG9ja092ZXJyaWRlcyA9IEJsb2NrT3ZlcnJpZGVzLnRvUnBjKHtcbiAqICAgYmFzZUZlZVBlckdhczogMW4sXG4gKiAgIGJsb2JCYXNlRmVlOiAybixcbiAqICAgZmVlUmVjaXBpZW50OiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgZ2FzTGltaXQ6IDRuLFxuICogICBudW1iZXI6IDVuLFxuICogICBwcmV2UmFuZGFvOiA2bixcbiAqICAgdGltZTogNzgxODc0OTM1MjBuLFxuICogICB3aXRoZHJhd2FsczogW1xuICogICAgIHtcbiAqICAgICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgICAgYW1vdW50OiAxbixcbiAqICAgICAgIGluZGV4OiAwLFxuICogICAgICAgdmFsaWRhdG9ySW5kZXg6IDEsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYmxvY2tPdmVycmlkZXMgLSBUaGUgYmxvY2sgb3ZlcnJpZGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLlJwY30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhibG9ja092ZXJyaWRlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBibG9iQmFzZUZlZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQgPT09ICdzdHJpbmcnICYmIHtcbiAgICAgICAgICAgIGZlZVJlY2lwaWVudDogYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50LFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5nYXNMaW1pdCA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0KSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMubnVtYmVyID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBudW1iZXI6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLm51bWJlciksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8gPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIHByZXZSYW5kYW86IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8pLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy50aW1lID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICB0aW1lOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy50aW1lKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihibG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XG4gICAgICAgICAgICB3aXRoZHJhd2FsczogYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKFdpdGhkcmF3YWwudG9ScGMpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxvY2tPdmVycmlkZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = (nibbleLeft << 4) | nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNwQjtBQUNOO0FBQ2dCO0FBQ0U7QUFDaEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNPLHdDQUF3QztBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLFlBQVkscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ08sb0NBQW9DO0FBQzNDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsUUFBUSx3REFBdUI7QUFDL0IsY0FBYyw2Q0FBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQywyQkFBMkIsZ0VBQXlCO0FBQ3BELDRCQUE0QixnRUFBeUI7QUFDckQ7QUFDQSxzQkFBc0IsaURBQWdCLDRCQUE0QixpQkFBaUIsRUFBRSxpQkFBaUIsUUFBUSxVQUFVO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDTztBQUNQLGdCQUFnQiwrQ0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsUUFBUSwwREFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hELDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNPO0FBQ1AsV0FBVyx3RUFBVTtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLGtDQUFrQyxzQkFBc0I7QUFDeEQsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNPO0FBQ1AsV0FBVyxtREFBWSxVQUFVLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLGtDQUFrQyxzQkFBc0I7QUFDeEQsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNPO0FBQ1AsV0FBVyxtREFBWSxVQUFVLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Qsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ08sOENBQThDO0FBQ3JELFlBQVksU0FBUztBQUNyQixJQUFJLGlFQUEwQjtBQUM5QjtBQUNBO0FBQ0EsUUFBUSwrREFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQztBQUM1QyxZQUFZLE9BQU87QUFDbkI7QUFDQSxRQUFRLDBEQUFtQjtBQUMzQixnQkFBZ0IsOENBQWE7QUFDN0IsV0FBVyw2Q0FBWTtBQUN2QjtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFFBQVEsMERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0IsY0FBYyxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNPLGtDQUFrQztBQUN6QyxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQztBQUM1QyxZQUFZLE9BQU87QUFDbkI7QUFDQSxRQUFRLDBEQUFtQjtBQUMzQixnQkFBZ0IsOENBQWE7QUFDN0IsV0FBVyw2Q0FBWTtBQUN2QjtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQztBQUM1QyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFFBQVEsMERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QyxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ087QUFDUCxXQUFXLG9EQUFhLFVBQVUsYUFBYTtBQUMvQztBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNPO0FBQ1AsV0FBVyxvREFBYSxVQUFVLGNBQWM7QUFDaEQ7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxpREFBZ0I7QUFDOUQ7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQ0FBb0MsaURBQWdCO0FBQzNEO0FBQ0EseUJBQXlCLDRCQUE0QiwrQ0FBYyxnQkFBZ0IsZUFBZSxhQUFhO0FBQy9HO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsaURBQWdCO0FBQ3ZELGtCQUFrQixvQkFBb0I7QUFDdEMsc0NBQXNDLFFBQVEsMEJBQTBCLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLHVCQUF1Qiw4Q0FBOEMsY0FBYyxPQUFPLCtCQUErQixLQUFLO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyxpQkFBaUIsNkJBQTZCLEVBQUU7QUFDaEQ7QUFDQSw0QkFBNEIsVUFBVSxLQUFLLDhCQUE4QixXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQnl0ZXMuanM/OTlmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWxfaGV4IGZyb20gJy4vaW50ZXJuYWwvaGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbmNvbnN0IGRlY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vKipcbiAqIEFzc2VydHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmFzc2VydCgnYWJjJylcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yOlxuICogLy8gQGVycm9yOiBWYWx1ZSBgXCJhYmNcImAgb2YgdHlwZSBgc3RyaW5nYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLlxuICogLy8gQGVycm9yOiBCeXRlcyB2YWx1ZXMgbXVzdCBiZSBvZiB0eXBlIGBVaW50OEFycmF5YC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKCEoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiB2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gMSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnVWludDhBcnJheScpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZXMgdHdvIG9yIG1vcmUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYnl0ZXMgPSBCeXRlcy5jb25jYXQoXG4gKiAgIEJ5dGVzLmZyb20oWzFdKSxcbiAqICAgQnl0ZXMuZnJvbShbNjldKSxcbiAqICAgQnl0ZXMuZnJvbShbNDIwLCA2OV0pLFxuICogKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbIDEsIDY5LCA0MjAsIDY5IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBWYWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBDb25jYXRlbmF0ZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGFyciBvZiB2YWx1ZXMpIHtcbiAgICAgICAgbGVuZ3RoICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGluZGV4ID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSB2YWx1ZXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgZnJvbSBhIGBVaW50OEFycmF5YCwgYSBoZXggc3RyaW5nLCBvciBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2Vycy5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUbyBpbnN0YW50aWF0ZSBmcm9tIGEgKipCb29sZWFuKiosICoqU3RyaW5nKiosIG9yICoqTnVtYmVyKiosIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBCeXRlcy5mcm9tQm9vbGVhbmBcbiAqXG4gKiAtIGBCeXRlcy5mcm9tU3RyaW5nYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21OdW1iZXJgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb20oWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyMjIsIDE3MywgMTkwLCAyMzldKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgdW5zaWduZWQgOC1iaXQgaW50ZWdlcnMgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUFycmF5KFsyNTUsIDEyNCwgNSwgNF0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyNTUsIDEyNCwgNSwgNF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHZhbHVlIDogbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgYm9vbGVhbiB2YWx1ZSBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQm9vbGVhbih0cnVlKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMV0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDFdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQm9vbGVhbiB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQm9vbGVhbih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgYnl0ZXNbMF0gPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGJ5dGVzLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21IZXgoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21IZXgoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGhleCA9IHZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2hleC5hc3NlcnRTaXplKHZhbHVlLCBzaXplKTtcbiAgICAgICAgaGV4ID0gSGV4LnBhZFJpZ2h0KHZhbHVlLCBzaXplKTtcbiAgICB9XG4gICAgbGV0IGhleFN0cmluZyA9IGhleC5zbGljZSgyKTtcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIpXG4gICAgICAgIGhleFN0cmluZyA9IGAwJHtoZXhTdHJpbmd9YDtcbiAgICBjb25zdCBsZW5ndGggPSBoZXhTdHJpbmcubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBqID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgbmliYmxlTGVmdCA9IGludGVybmFsLmNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgaWYgKG5pYmJsZUxlZnQgPT09IHVuZGVmaW5lZCB8fCBuaWJibGVSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBieXRlIHNlcXVlbmNlIChcIiR7aGV4U3RyaW5nW2ogLSAyXX0ke2hleFN0cmluZ1tqIC0gMV19XCIgaW4gXCIke2hleFN0cmluZ31cIikuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbaW5kZXhdID0gKG5pYmJsZUxlZnQgPDwgNCkgfCBuaWJibGVSaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogNCB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmcm9tSGV4KGhleCk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gd29ybGQhJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5pc0VxdWFsKEJ5dGVzLmZyb20oWzFdKSwgQnl0ZXMuZnJvbShbMV0pKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsyXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzQSAtIEZpcnN0IHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gYnl0ZXNCIC0gU2Vjb25kIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB2YWx1ZXMgYXJlIGVxdWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXNBLCBieXRlc0IpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhieXRlc0EsIGJ5dGVzQik7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tKFsxXSksIDQpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAwLCAxXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBTaXplIHRvIHBhZCB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0by5cbiAqIEByZXR1cm5zIFBhZGRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZFJpZ2h0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJ5dGVzID0gQnl0ZXMucmFuZG9tKDMyKVxuICogLy8gQGxvZzogVWludDhBcnJheShbLi4uIHgzMl0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gTGVuZ3RoIG9mIHRoZSByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGxlbmd0aCkpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zaXplKEJ5dGVzLmZyb20oWzEsIDIsIDMsIDRdKSlcbiAqIC8vIEBsb2c6IDRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKFxuICogICBCeXRlcy5mcm9tKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSksXG4gKiAgIDEsXG4gKiAgIDQsXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyLCAzLCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHBhcmFtIHN0YXJ0IC0gU3RhcnQgb2Zmc2V0LlxuICogQHBhcmFtIGVuZCAtIEVuZCBvZmZzZXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNsaWNlIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBTbGljZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IHZhbHVlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBiaWdpbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQmlnSW50KEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCBiaWdpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBIZXgudG9CaWdJbnQoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1MZWZ0KGJ5dGVzXyk7XG4gICAgfVxuICAgIGlmIChieXRlc18ubGVuZ3RoID4gMSB8fCBieXRlc19bMF0gPiAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yKGJ5dGVzXyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oYnl0ZXNfWzBdKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9IZXgoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvTnVtYmVyKEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b051bWJlcihoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltUmlnaHQoYnl0ZXNfKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ5dGVzXyk7XG59XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1MZWZ0KEJ5dGVzLmZyb20oWzAsIDAsIDAsIDAsIDEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFRyaW1tZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50cmltUmlnaHQoQnl0ZXMuZnJvbShbMSwgMiwgMywgMCwgMCwgMCwgMF0pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKCcweCcpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIGJ5dGVzIHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFs1XSkpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcjogQnl0ZXMgdmFsdWUgYFs1XWAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGJ5dGVzIGFycmF5IG11c3QgY29udGFpbiBhIHNpbmdsZSBieXRlIG9mIGVpdGhlciBhIGAwYCBvciBgMWAgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcXGAke2J5dGVzfVxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb20oJ2ZvbycpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcjogVmFsdWUgYGZvb2Agb2YgdHlwZSBgc3RyaW5nYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0J5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYEJ5dGVzYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDggfSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgc2xpY2Ugb2Zmc2V0IGlzIG91dC1vZi1ib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSwgNClcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yOiBTbGljZSBzdGFydGluZyBhdCBvZmZzZXQgYDRgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IGAzYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHRoZSBwYWRkaW5nIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZExlZnQoQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJyksIDgpXG4gKiAvLyBAZXJyb3I6IFtCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEJ5dGVzIHNpemUgKGAxMmApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgOGApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192),\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nfunction clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0NhY2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDM0M7QUFDQSxnQ0FBZ0Msb0RBQU07QUFDdEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0NhY2hlcy5qcz9lZDUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExydU1hcCB9IGZyb20gJy4vaW50ZXJuYWwvbHJ1LmpzJztcbmNvbnN0IGNhY2hlcyA9IHtcbiAgICBjaGVja3N1bTogLyojX19QVVJFX18qLyBuZXcgTHJ1TWFwKDgxOTIpLFxufTtcbmV4cG9ydCBjb25zdCBjaGVja3N1bSA9IGNhY2hlcy5jaGVja3N1bTtcbi8qKlxuICogQ2xlYXJzIGFsbCBnbG9iYWwgY2FjaGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ2FjaGVzIH0gZnJvbSAnb3gnXG4gKiBDYWNoZXMuY2xlYXIoKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIE9iamVjdC52YWx1ZXMoY2FjaGVzKSlcbiAgICAgICAgY2FjaGUuY2xlYXIoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    static setStaticOptions(options) {\n        BaseError.prototype.docsOrigin = options.docsOrigin;\n        BaseError.prototype.showVersion = options.showVersion;\n        BaseError.prototype.version = options.version;\n    }\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = options.docsOrigin ?? BaseError.prototype.docsOrigin;\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const showVersion = Boolean(options.version ?? BaseError.prototype.showVersion);\n        const version = options.version ?? BaseError.prototype.version;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath || showVersion\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                    showVersion ? `Version: ${version}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsOrigin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"showVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsOrigin = docsBaseUrl;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n        this.showVersion = showVersion;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nObject.defineProperty(BaseError, \"defaultStaticOptions\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        docsOrigin: 'https://oxlib.sh',\n        showVersion: false,\n        version: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`,\n    }\n});\n(() => {\n    BaseError.setStaticOptions(BaseError.defaultStaticOptions);\n})();\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCx1Q0FBdUMsS0FBSztBQUM1Qyw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFVLEdBQUc7QUFDcEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9FcnJvcnMuanM/Y2U2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRWZXJzaW9uIH0gZnJvbSAnLi9pbnRlcm5hbC9lcnJvcnMuanMnO1xuLyoqXG4gKiBCYXNlIGVycm9yIGNsYXNzIGluaGVyaXRlZCBieSBhbGwgZXJyb3JzIHRocm93biBieSBveC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVycm9ycyB9IGZyb20gJ294J1xuICogdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXRpYyBzZXRTdGF0aWNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS5kb2NzT3JpZ2luID0gb3B0aW9ucy5kb2NzT3JpZ2luO1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLnNob3dWZXJzaW9uID0gb3B0aW9ucy5zaG93VmVyc2lvbjtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS52ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UuZGV0YWlscylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgJ2RldGFpbHMnIGluIG9wdGlvbnMuY2F1c2UgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jYXVzZS5kZXRhaWxzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2U/Lm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRldGFpbHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NQYXRoID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRvY3NQYXRoIHx8IG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc0Jhc2VVcmwgPSBvcHRpb25zLmRvY3NPcmlnaW4gPz8gQmFzZUVycm9yLnByb3RvdHlwZS5kb2NzT3JpZ2luO1xuICAgICAgICBjb25zdCBkb2NzID0gYCR7ZG9jc0Jhc2VVcmx9JHtkb2NzUGF0aCA/PyAnJ31gO1xuICAgICAgICBjb25zdCBzaG93VmVyc2lvbiA9IEJvb2xlYW4ob3B0aW9ucy52ZXJzaW9uID8/IEJhc2VFcnJvci5wcm90b3R5cGUuc2hvd1ZlcnNpb24pO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uID8/IEJhc2VFcnJvci5wcm90b3R5cGUudmVyc2lvbjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm1ldGFNZXNzYWdlcyA/IFsnJywgLi4ub3B0aW9ucy5tZXRhTWVzc2FnZXNdIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgfHwgZG9jc1BhdGggfHwgc2hvd1ZlcnNpb25cbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPyBgRGV0YWlsczogJHtkZXRhaWxzfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGRvY3NQYXRoID8gYFNlZTogJHtkb2NzfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHNob3dWZXJzaW9uID8gYFZlcnNpb246ICR7dmVyc2lvbn1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zLmNhdXNlID8geyBjYXVzZTogb3B0aW9ucy5jYXVzZSB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NPcmlnaW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvcnRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3dWZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0Jhc2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICAgICAgICB0aGlzLmRvY3NPcmlnaW4gPSBkb2NzQmFzZVVybDtcbiAgICAgICAgdGhpcy5kb2NzUGF0aCA9IGRvY3NQYXRoO1xuICAgICAgICB0aGlzLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgICAgICAgdGhpcy5zaG93VmVyc2lvbiA9IHNob3dWZXJzaW9uO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbiAgICB3YWxrKGZuKSB7XG4gICAgICAgIHJldHVybiB3YWxrKHRoaXMsIGZuKTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLCBcImRlZmF1bHRTdGF0aWNPcHRpb25zXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZToge1xuICAgICAgICBkb2NzT3JpZ2luOiAnaHR0cHM6Ly9veGxpYi5zaCcsXG4gICAgICAgIHNob3dWZXJzaW9uOiBmYWxzZSxcbiAgICAgICAgdmVyc2lvbjogYG94QCR7Z2V0VmVyc2lvbigpfWAsXG4gICAgfVxufSk7XG4oKCkgPT4ge1xuICAgIEJhc2VFcnJvci5zZXRTdGF0aWNPcHRpb25zKEJhc2VFcnJvci5kZWZhdWx0U3RhdGljT3B0aW9ucyk7XG59KSgpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gd2FsayhlcnIsIGZuKSB7XG4gICAgaWYgKGZuPy4oZXJyKSlcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmICdjYXVzZScgaW4gZXJyICYmIGVyci5jYXVzZSlcbiAgICAgICAgcmV0dXJuIHdhbGsoZXJyLmNhdXNlLCBmbik7XG4gICAgcmV0dXJuIGZuID8gbnVsbCA6IGVycjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ0o7QUFDTDtBQUMxQjtBQUNKO0FBQ2hDO0FBQ0EsOEVBQThFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsOERBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0Isa0VBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsNkVBQTZFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsNERBQVksQ0FBQywyQ0FBVTtBQUN6QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWSxXQUFXLHlDQUFRO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IYXNoLmpzPzBkNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmlwZW1kMTYwIGFzIG5vYmxlX3JpcGVtZDE2MCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwJztcbmltcG9ydCB7IGtlY2Nha18yNTYgYXMgbm9ibGVfa2VjY2FrMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiBhcyBub2JsZV9zaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtLZWNjYWsyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0zKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBga2VjY2FrXzI1NmAgZnJvbSBbYEBub2JsZS9oYXNoZXNgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcyksIGFuIGF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGhhc2hpbmcgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NignMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkNGZkNGUxODkxMzIyNzMwMzY0NDlmYzllMTExOThjNzM5MTYxYjRjMDExNmE5YTJkY2NkZmExYzQ5MjAwNmYxJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDYWxjdWxhdGUgSGFzaCBvZiBhIFN0cmluZ1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSlcbiAqIC8vIEBsb2c6ICcweDNlYTJmMWQwYWJmM2ZjNjZjZjI5ZWViYjcwY2JkNGU3ZmU3NjJlZjhhMDliY2MwNmM4ZWRmNjQxMjMwYWZlYzAnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbmZpZ3VyZSBSZXR1cm4gVHlwZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnLCB7IGFzOiAnQnl0ZXMnIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEtlY2NhazI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX2tlY2NhazI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbUmlwZW1kMTYwXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SSVBFTUQpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGByaXBlbWQxNjBgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5yaXBlbWQxNjAoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4MjI2ODIxYzJmNTQyM2UxMWZlOWFmNjhiZDI4NWMyNDlkYjJlNGI1YSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgUmlwZW1kMTYwIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfcmlwZW1kMTYwKEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtTaGEyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0yNTYpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGBzaGEyNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5zaGEyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4NWY3OGMzMzI3NGU0M2ZhOWRlNTY1OTI2NWMxZDkxN2UyNWMwMzcyMmRjYjBiOGQyN2RiOGQ1ZmVhYTgxMzk1MydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgU2hhMjU2IGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfc2hhMjU2KEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhhc2ggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqXG4gKiBIYXNoLnZhbGlkYXRlKCcweDNlYTJmMWQwYWJmM2ZjNjZjZjI5ZWViYjcwY2JkNGU3ZmU3NjJlZjhhMDliY2MwNmM4ZWRmNjQxMjMwYWZlYzAnKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBIZXgudmFsaWRhdGUodmFsdWUpICYmIEhleC5zaXplKHZhbHVlKSA9PT0gMzI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNFO0FBQ2dCO0FBQ1I7QUFDWjtBQUNsQztBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDTztBQUNQLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsNEJBQTRCLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0MseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ08sd0NBQXdDO0FBQy9DLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0EsUUFBUSx3REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCLGNBQWMsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTyxzQ0FBc0M7QUFDN0M7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQSxRQUFRLHdEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNPLHVDQUF1QztBQUM5QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsRUFBRSxPQUFPO0FBQ2pELG9CQUFvQixTQUFTLEVBQUUsT0FBTztBQUN0QztBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sRUFBRSxPQUFPO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ08sdUNBQXVDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLDZCQUE2QixrQkFBa0I7QUFDL0MsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNPO0FBQ1AsV0FBVyx3RUFBVSxDQUFDLDhDQUFhLFFBQVEsOENBQWE7QUFDeEQ7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDTztBQUNQLFdBQVcsaURBQVksVUFBVSxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDTztBQUNQLFdBQVcsaURBQVksVUFBVSxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ087QUFDUCxxQkFBcUIsNkNBQVk7QUFDakM7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDTyw4Q0FBOEM7QUFDckQsWUFBWSxTQUFTO0FBQ3JCLElBQUksK0RBQTBCO0FBQzlCLHdCQUF3QjtBQUN4QjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLFFBQVEsNkRBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTztBQUNQLFdBQVcsa0RBQWEsVUFBVSxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6Qyx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ087QUFDUCxXQUFXLGtEQUFhLFVBQVUsY0FBYztBQUNoRDtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFVBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsUUFBUSx3REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixVQUFVO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDO0FBQ0EsUUFBUSx3REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLGNBQWMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDTyxrQ0FBa0M7QUFDekMsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFVBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksT0FBTztBQUNuQixnQkFBZ0IsOENBQWE7QUFDN0I7QUFDQSxRQUFRLDBEQUF5QjtBQUNqQyxnQkFBZ0IsZ0RBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDTyxxQ0FBcUM7QUFDNUMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsaURBQWdCO0FBQzVELGtCQUFrQixnQ0FBZ0M7QUFDbEQsMEJBQTBCLE1BQU0sbUJBQW1CLFdBQVcsU0FBUyxXQUFXLEVBQUUsa0NBQWtDLGdCQUFnQixZQUFZLElBQUksVUFBVSxJQUFJLG1CQUFtQixJQUFJLEtBQUs7QUFDaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsaURBQWdCO0FBQzVEO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQ7QUFDQSx5QkFBeUIsNEJBQTRCLCtDQUFjLGdCQUFnQixlQUFlLGFBQWE7QUFDL0csbUVBQW1FLE9BQU87QUFDMUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLGlEQUFnQjtBQUMxRDtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaURBQWdCO0FBQ3hEO0FBQ0EsOEJBQThCLE1BQU0sd0JBQXdCLGtCQUFrQjtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RCxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNDQUFzQyxRQUFRLDBCQUEwQixVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyx1QkFBdUIsOENBQThDLGNBQWMsT0FBTywrQkFBK0IsS0FBSztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcz83YjQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsX2J5dGVzIGZyb20gJy4vaW50ZXJuYWwvYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBoZXhlcyA9IC8qI19fUFVSRV9fKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEFzc2VydHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJ2FiYycpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRIZXhWYWx1ZVR5cGVFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYFwiYWJjXCJgIG9mIHR5cGUgYHN0cmluZ2AgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5cbiAqIC8vIEBlcnJvcjogSGV4IHR5cGVzIG11c3QgYmUgcmVwcmVzZW50ZWQgYXMgYFwiMHhcXCR7c3RyaW5nfVwiYC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoIS9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byBvciBtb3JlIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5jb25jYXQoJzB4MTIzJywgJzB4NDU2JylcbiAqIC8vIEBsb2c6ICcweDEyMzQ1NidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIHJldHVybiBgMHgke3ZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5yZXBsYWNlKCcweCcsICcnKSwgJycpfWA7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBmcm9tIGEgaGV4IHN0cmluZyBvciB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEhleC5mcm9tQm9vbGVhbmBcbiAqXG4gKiAtIGBIZXguZnJvbVN0cmluZ2BcbiAqXG4gKiAtIGBIZXguZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbSgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICpcbiAqIEhleC5mcm9tKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJvb2xlYW4gaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbih0cnVlKVxuICogLy8gQGxvZzogJzB4MSdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4oZmFsc2UpXG4gKiAvLyBAbG9nOiAnMHgwJ1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbih0cnVlLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJvb2xlYW4gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJvb2xlYW4odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhleCA9IGAweCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXModmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHJpbmcgKz0gaGV4ZXNbdmFsdWVbaV1dO1xuICAgIGNvbnN0IGhleCA9IGAweCR7c3RyaW5nfWA7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIG9yIGJpZ2ludCBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogJzB4MWE0J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgb3IgYmlnaW50IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlXyA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgbGV0IG1heFZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICBtYXhWYWx1ZSA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4gLSAxbikpIC0gMW47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heFZhbHVlID0gMm4gKiogKEJpZ0ludChzaXplKSAqIDhuKSAtIDFuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFZhbHVlID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG4gICAgY29uc3QgbWluVmFsdWUgPSB0eXBlb2YgbWF4VmFsdWUgPT09ICdiaWdpbnQnICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcbiAgICBpZiAoKG1heFZhbHVlICYmIHZhbHVlXyA+IG1heFZhbHVlKSB8fCB2YWx1ZV8gPCBtaW5WYWx1ZSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gJ24nIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgIG1heDogbWF4VmFsdWUgPyBgJHttYXhWYWx1ZX0ke3N1ZmZpeH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluOiBgJHttaW5WYWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSAoc2lnbmVkICYmIHZhbHVlXyA8IDAgPyBCaWdJbnQuYXNVaW50TihzaXplICogOCwgQmlnSW50KHZhbHVlXykpIDogdmFsdWVfKS50b1N0cmluZygxNik7XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmdWYWx1ZX1gO1xuICAgIGlmIChzaXplKVxuICAgICAgICByZXR1cm4gcGFkTGVmdChoZXgsIHNpemUpO1xuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKlxuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoZW5jb2Rlci5lbmNvZGUodmFsdWUpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5pc0VxdWFsKCcweGRlYWRiZWVmJywgJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC5pc0VxdWFsKCcweGRhJywgJzB4YmEnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXhBIC0gVGhlIGZpcnN0IHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBoZXhCIC0gVGhlIHNlY29uZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGhleEEsIGhleEIpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhCeXRlcy5mcm9tSGV4KGhleEEpLCBCeXRlcy5mcm9tSGV4KGhleEIpKTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0aGUgbGVmdCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkTGVmdCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDAwMDAxMjM0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkUmlnaHQoJzB4MTIzNCcsIDQpXG4gKiAvLyBAbG9nOiAnMHgxMjM0MDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBvdXRwdXQgaGV4IHZhbHVlLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGV4ID0gSGV4LnJhbmRvbSgzMilcbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5yYW5kb20obGVuZ3RoKSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2xpY2UoJzB4MDEyMzQ1Njc4OScsIDEsIDQpXG4gKiAvLyBAbG9nOiAnMHgyMzQ1NjcnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHNsaWNlLlxuICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0IG9mZnNldCAoaW4gYnl0ZXMpLlxuICogQHBhcmFtIGVuZCAtIFRoZSBlbmQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2xpY2VkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IGAweCR7dmFsdWVcbiAgICAgICAgLnJlcGxhY2UoJzB4JywgJycpXG4gICAgICAgIC5zbGljZSgoc3RhcnQgPz8gMCkgKiAyLCAoZW5kID8/IHZhbHVlLmxlbmd0aCkgKiAyKX1gO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSAoaW4gYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnNpemUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBnZXQgdGhlIHNpemUgb2YuXG4gKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbn1cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRyaW1MZWZ0KCcweDAwMDAwMDAwZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuLyoqXG4gKiBUcmltcyB0cmFpbGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRyaW1SaWdodCgnMHhkZWFkYmVlZjAwMDAwMDAwJylcbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0cmltLlxuICogQHJldHVybnMgVGhlIHRyaW1tZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBCaWdJbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9CaWdJbnQoJzB4MWE0JylcbiAqIC8vIEBsb2c6IDQyMG5cbiAqXG4gKiBIZXgudG9CaWdJbnQoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIEJpZ0ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWUgPSBCaWdJbnQoaGV4KTtcbiAgICBpZiAoIXNpZ25lZClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNpemUgPSAoaGV4Lmxlbmd0aCAtIDIpIC8gMjtcbiAgICBjb25zdCBtYXhfdW5zaWduZWQgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuKSkgLSAxbjtcbiAgICBjb25zdCBtYXhfc2lnbmVkID0gbWF4X3Vuc2lnbmVkID4+IDFuO1xuICAgIGlmICh2YWx1ZSA8PSBtYXhfc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlIC0gbWF4X3Vuc2lnbmVkIC0gMW47XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweDAxJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Cb29sZWFuKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgaGV4XyA9IHRyaW1MZWZ0KGhleCk7XG4gICAgaWYgKGhleF8gPT09ICcweCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4MScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleCk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gSGV4LnRvQnl0ZXMoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b051bWJlcignMHgxYTQnKVxuICogLy8gQGxvZzogNDIwXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiA0MjBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIG51bWJlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzaWduZWQgJiYgIXNpemUpXG4gICAgICAgIHJldHVybiBOdW1iZXIoaGV4KTtcbiAgICByZXR1cm4gTnVtYmVyKHRvQmlnSW50KGhleCwgb3B0aW9ucykpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCEnXG4gKlxuICogSGV4LnRvU3RyaW5nKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCB7XG4gKiAgc2l6ZTogMzIsXG4gKiB9KVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuZnJvbUhleChoZXgpO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2J5dGVzLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICBieXRlcyA9IEJ5dGVzLnRyaW1SaWdodChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC52YWxpZGF0ZShCeXRlcy5mcm9tKFsxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBveCNIZXguSGV4fSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUsIHsgc3RyaWN0IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaW50ZWdlciBpcyBvdXQgb2YgcmFuZ2UsIGFuZCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBoZXggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAxODI3Mzg5MTI3MzEyODM3MTI5MzcxMjkpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yOiBOdW1iZXIgXFxgNC4yMDE4MjczODkxMjczMTI2ZSsyNlxcYCBpcyBub3QgaW4gc2FmZSB1bnNpZ25lZCBpbnRlZ2VyIHJhbmdlIChgMGAgdG8gYDkwMDcxOTkyNTQ3NDA5OTFgKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgTnVtYmVyIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBpbiBzYWZlJHtzaXplID8gYCAke3NpemUgKiA4fS1iaXRgIDogJyd9JHtzaWduZWQgPyAnIHNpZ25lZCcgOiAnIHVuc2lnbmVkJ30gaW50ZWdlciByYW5nZSAke21heCA/IGAoXFxgJHttaW59XFxgIHRvIFxcYCR7bWF4fVxcYClgIDogYChhYm92ZSBcXGAke21pbn1cXGApYH1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4YScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yOiBIZXggdmFsdWUgYFwiMHhhXCJgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uXG4gKiAvLyBAZXJyb3I6IFRoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaGV4KSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke2hleH1cIlxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KDEpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4VHlwZUVycm9yOiBWYWx1ZSBgMWAgb2YgdHlwZSBgbnVtYmVyYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4VHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydIZXggdHlwZXMgbXVzdCBiZSByZXByZXNlbnRlZCBhcyBgXCIweCR7c3RyaW5nfVwiYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleFR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCcweDAxMjM0NTY3ODlhYmNkZWZnJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yOiBWYWx1ZSBgMHgwMTIzNDU2Nzg5YWJjZGVmZ2AgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEhleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdIZXggdmFsdWVzIG11c3Qgc3RhcnQgd2l0aCBgXCIweFwiYCBhbmQgY29udGFpbiBvbmx5IGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VmFsdWVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGlzIGFuIG9kZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21IZXgoJzB4YWJjZGUnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZExlbmd0aEVycm9yOiBIZXggdmFsdWUgYFwiMHhhYmNkZVwiYCBpcyBhbiBvZGQgbGVuZ3RoICg1IG5pYmJsZXMpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkTGVuZ3RoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHt2YWx1ZX1cIlxcYCBpcyBhbiBvZGQgbGVuZ3RoICgke3ZhbHVlLmxlbmd0aCAtIDJ9IG5pYmJsZXMpLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydJdCBtdXN0IGJlIGFuIGV2ZW4gbGVuZ3RoLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkTGVuZ3RoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgdGhlIHZhbHVlIGV4Y2VlZHMgdGhlIGV4cGVjdGVkIG1heCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBIZXguU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplT3ZlcmZsb3dFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2xpY2Ugb2Zmc2V0IGV4Y2VlZHMgdGhlIGJvdW5kcyBvZiB0aGUgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2xpY2UoJzB4MDEyMzQ1Njc4OScsIDYpXG4gKiAvLyBAZXJyb3I6IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNmAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDVgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgcGFkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkTGVmdCgnMHgxYTRlMTJhNDVhMjEzMjMxMjNhYWE4N2E4OTdhODk3YTg5OGE2NTY3YTU3OGE4NjdhOTg3NzhhNjY3YTg1YTg3NWE4N2E2YTc4N2E2NWE2NzVhNmE5JywgMzIpXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEhleCBzaXplIChgNDNgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoYDMyYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSw2QkFBNkIsZ0ZBQWdGO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLGdGQUFnRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFLQUFxSztBQUNySztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanM/M2E3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiaWdJbnRTdWZmaXggPSAnI19fYmlnaW50Jztcbi8qKlxuICogUGFyc2VzIGEgSlNPTiBzdHJpbmcsIHdpdGggc3VwcG9ydCBmb3IgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBKc29uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QganNvbiA9IEpzb24ucGFyc2UoJ3tcImZvb1wiOlwiYmFyXCIsXCJiYXpcIjpcIjY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwI19fYmlnaW50XCJ9JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgZm9vOiAnYmFyJyxcbiAqIC8vIEBsb2c6ICAgYmF6OiA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMG5cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcGFyYW0gcmV2aXZlciAtIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHRzLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cmluZywgcmV2aXZlcikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZywgKGtleSwgdmFsdWVfKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVfO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aChiaWdJbnRTdWZmaXgpKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5zbGljZSgwLCAtYmlnSW50U3VmZml4Lmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyByZXZpdmVyKGtleSwgdmFsdWUpIDogdmFsdWU7XG4gICAgfSk7XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgdmFsdWUgdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24sIHdpdGggc3VwcG9ydCBmb3IgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBKc29uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QganNvbiA9IEpzb24uc3RyaW5naWZ5KHtcbiAqICAgZm9vOiAnYmFyJyxcbiAqICAgYmF6OiA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMG4sXG4gKiB9KVxuICogLy8gQGxvZzogJ3tcImZvb1wiOlwiYmFyXCIsXCJiYXpcIjpcIjY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwI19fYmlnaW50XCJ9J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0cmluZ2lmeS5cbiAqIEBwYXJhbSByZXBsYWNlciAtIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHRzLiBJdCBpcyBwYXNzZWQgdGhlIGtleSBhbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LCBhbmQgbXVzdCByZXR1cm4gdGhlIHZhbHVlIHRvIGJlIHVzZWQgaW4gdGhlIEpTT04gc3RyaW5nLiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZSBwcm9wZXJ0eSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBKU09OIHN0cmluZy5cbiAqIEBwYXJhbSBzcGFjZSAtIEEgc3RyaW5nIG9yIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBKU09OIHN0cmluZy4gSWYgaXQgaXMgYSBudW1iZXIsIGl0IGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byB1c2UgYXMgaW5kZW50YXRpb247IGlmIGl0IGlzIGEgc3RyaW5nIChlLmcuIGAnXFx0J2ApLCBpdCB1c2VzIHRoZSBzdHJpbmcgYXMgdGhlIGluZGVudGF0aW9uIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRoZSBKU09OIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgYmlnSW50U3VmZml4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgc3BhY2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SnNvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nfunction from(value) {\n    const publicKey = (() => {\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value))\n            return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, { size: 1 }) : '0x', _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (_error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nclass InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nclass InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nclass InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nclass InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1B1YmxpY0tleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNFO0FBQ047QUFDRTtBQUNsQztBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksYUFBYTtBQUN6QixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCLGVBQWUsNkJBQTZCLEdBQUcscUJBQXFCLE1BQU0saUJBQWlCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUDtBQUNBLFlBQVksNkNBQVk7QUFDeEI7QUFDQSxZQUFZLCtDQUFjO0FBQzFCO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEIsUUFBUSxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsOENBQWE7QUFDaEM7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEIsUUFBUSxrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0EseUJBQXlCLDBDQUFTO0FBQ2xDLHlCQUF5QiwwQ0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBUztBQUN2Qyx5QkFBeUIsMENBQVM7QUFDbEMseUJBQXlCLDBDQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBUztBQUNuQyxxQkFBcUIsMENBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QixJQUFJLHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0NBQXdDO0FBQy9DLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEIsSUFBSSxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QztBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLHVCQUF1QjtBQUNuQyx1QkFBdUIsMkNBQVUsaUJBQWlCLCtDQUFjLFdBQVcsU0FBUyxVQUFVLCtDQUFjLE1BQU0sVUFBVTtBQUM1SDtBQUNBLDRCQUE0QiwrQ0FBYyxNQUFNLFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsaURBQWdCO0FBQ2xELGtCQUFrQixXQUFXO0FBQzdCLHlCQUF5QiwrQ0FBYyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaURBQWdCO0FBQ3hELGtCQUFrQixlQUFlO0FBQ2pDLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLGlEQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw2Q0FBNkMsaURBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QyxpREFBZ0I7QUFDaEUsa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBUSxDQUFDLHlDQUFRLGNBQWM7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QdWJsaWNLZXkuanM/OTUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBQdWJsaWNLZXkuYXNzZXJ0KHtcbiAqICAgcHJlZml4OiA0LFxuICogICB5OiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiB9KVxuICogLy8gQGVycm9yOiBQdWJsaWNLZXkuSW52YWxpZEVycm9yOiBWYWx1ZSBcXGB7XCJ5XCI6XCIxXCJ9XFxgIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuXG4gKiAvLyBAZXJyb3I6IFB1YmxpYyBrZXkgbXVzdCBjb250YWluOlxuICogLy8gQGVycm9yOiAtIGFuIGB4YCBhbmQgYHByZWZpeGAgdmFsdWUgKGNvbXByZXNzZWQpXG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IG9iamVjdCB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNvbXByZXNzZWQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyBwcmVmaXgsIHgsIHkgfSA9IHB1YmxpY0tleTtcbiAgICAvLyBVbmNvbXByZXNzZWRcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gZmFsc2UgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByZWZpeEVycm9yKHtcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENvbXByZXNzZWRcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdHJ1ZSB8fFxuICAgICAgICAodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gMyAmJiBwcmVmaXggIT09IDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByZWZpeEVycm9yKHtcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVbmtub3duL2ludmFsaWRcbiAgICB0aHJvdyBuZXcgSW52YWxpZEVycm9yKHsgcHVibGljS2V5IH0pO1xufVxuLyoqXG4gKiBDb21wcmVzc2VzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBjb21wcmVzc2VkID0gUHVibGljS2V5LmNvbXByZXNzKHB1YmxpY0tleSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDMsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB0byBjb21wcmVzcy5cbiAqIEByZXR1cm5zIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzcyhwdWJsaWNLZXkpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHB1YmxpY0tleTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXg6IHkgJSAybiA9PT0gMG4gPyAyIDogMyxcbiAgICAgICAgeCxcbiAgICB9O1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB0eXBlZCB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gb2JqZWN0IGZyb20gYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0sIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG9yIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSgnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBwdWJsaWMga2V5IHZhbHVlIHRvIGluc3RhbnRpYXRlLlxuICogQHJldHVybnMgVGhlIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleCh2YWx1ZSk7XG4gICAgICAgIGlmIChCeXRlcy52YWxpZGF0ZSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHgsIHkgfSA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHR5cGVvZiB5ID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4ID8/IDB4MDQsIHgsIHkgfTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB4IH07XG4gICAgfSkoKTtcbiAgICBhc3NlcnQocHVibGljS2V5KTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEyOCwgMywgMTMxLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiBmcm9tSGV4KEhleC5mcm9tQnl0ZXMocHVibGljS2V5KSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb21IZXgoJzB4ODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NTM1NDdmMTFjYTg2OTY2NDZmMmYzYWNiMDhlMzEwMTZhZmFjMjNlNjMwYzVkMTFmNTlmNjFmZWY1N2IwZDJhYTUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBEZXNlcmlhbGl6aW5nIGEgQ29tcHJlc3NlZCBQdWJsaWMgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tSGV4KCcweDAzODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogMyxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHB1YmxpY0tleSkge1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzIgJiZcbiAgICAgICAgcHVibGljS2V5Lmxlbmd0aCAhPT0gMTMwICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDY4KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IoeyBwdWJsaWNLZXkgfSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDEzMCkge1xuICAgICAgICBjb25zdCB4ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IHkgPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMzIsIDY0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXg6IDQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDEzMikge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBOdW1iZXIoSGV4LnNsaWNlKHB1YmxpY0tleSwgMCwgMSkpO1xuICAgICAgICBjb25zdCB4ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDEsIDMzKSk7XG4gICAgICAgIGNvbnN0IHkgPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMzMsIDY1KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICBjb25zdCB4ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDEsIDMzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB4LFxuICAgIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgYnl0ZXMgPSBQdWJsaWNLZXkudG9CeXRlcyhwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEyOCwgMywgMTMxLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleChwdWJsaWNLZXksIG9wdGlvbnMpKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhleCA9IFB1YmxpY0tleS50b0hleChwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweDA0ODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NTM1NDdmMTFjYTg2OTY2NDZmMmYzYWNiMDhlMzEwMTZhZmFjMjNlNjMwYzVkMTFmNTlmNjFmZWY1N2IwZDJhYTUnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgY29uc3QgeyBwcmVmaXgsIHgsIHkgfSA9IHB1YmxpY0tleTtcbiAgICBjb25zdCB7IGluY2x1ZGVQcmVmaXggPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHB1YmxpY0tleV8gPSBIZXguY29uY2F0KGluY2x1ZGVQcmVmaXggPyBIZXguZnJvbU51bWJlcihwcmVmaXgsIHsgc2l6ZTogMSB9KSA6ICcweCcsIEhleC5mcm9tTnVtYmVyKHgsIHsgc2l6ZTogMzIgfSksIFxuICAgIC8vIElmIHRoZSBwdWJsaWMga2V5IGlzIG5vdCBjb21wcmVzc2VkLCBhZGQgdGhlIHkgY29vcmRpbmF0ZS5cbiAgICB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcgPyBIZXguZnJvbU51bWJlcih5LCB7IHNpemU6IDMyIH0pIDogJzB4Jyk7XG4gICAgcmV0dXJuIHB1YmxpY0tleV87XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS4gUmV0dXJucyBgdHJ1ZWAgaWYgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBQdWJsaWNLZXkudmFsaWRhdGUoe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHk6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IG9iamVjdCB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChwdWJsaWNLZXksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHB1YmxpYyBrZXkgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIFB1YmxpY0tleS5hc3NlcnQoeyB5OiAxbiB9KVxuICogLy8gQGVycm9yOiBQdWJsaWNLZXkuSW52YWxpZEVycm9yOiBWYWx1ZSBge1wieVwiOjFufWAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5cbiAqIC8vIEBlcnJvcjogUHVibGljIGtleSBtdXN0IGNvbnRhaW46XG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZClcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAsIGB5YCwgYW5kIGBwcmVmaXhgIHZhbHVlICh1bmNvbXByZXNzZWQpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHVibGljS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7SnNvbi5zdHJpbmdpZnkocHVibGljS2V5KX1cXGAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnUHVibGljIGtleSBtdXN0IGNvbnRhaW46JyxcbiAgICAgICAgICAgICAgICAnLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKScsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4LCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBQcmVmaXggXCIke3ByZWZpeH1cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBwcmVmaXggZm9yIGEgY29tcHJlc3NlZCBwdWJsaWMga2V5LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDIgb3IgMyBmb3IgY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4IGZvciBhbiB1bmNvbXByZXNzZWQgcHVibGljIGtleS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDQgZm9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBzZXJpYWxpemVkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3B1YmxpY0tleX1cXGAgaXMgYW4gaW52YWxpZCBwdWJsaWMga2V5IHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiAzMyBieXRlcyAoY29tcHJlc3NlZCArIHByZWZpeCksIDY0IGJ5dGVzICh1bmNvbXByZXNzZWQpIG9yIDY1IGJ5dGVzICh1bmNvbXByZXNzZWQgKyBwcmVmaXgpLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20ocHVibGljS2V5KSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVibGljS2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nfunction toBytes(value) {\n    return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value) {\n    return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nfunction to(value, to) {\n    const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */\n/** @internal */\nfunction decodeRlpCursor(cursor, to = 'Hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromBytes(bytes, options = {}) {\n    const { as = 'Bytes' } = options;\n    return from(bytes, { as });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromHex(hex, options = {}) {\n    const { as = 'Hex' } = options;\n    return from(hex, { as });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length <= 0xff)\n        return 1;\n    if (length <= 0xff_ff)\n        return 2;\n    if (length <= 0xff_ff_ff)\n        return 3;\n    if (length <= 0xff_ff_ff_ff)\n        return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JscC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDTjtBQUNlO0FBQy9DO0FBQ0EseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFzQjtBQUNoRCxtQkFBbUIsOENBQWE7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsdURBQWE7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0IsOENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFnQjtBQUM5QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCLElBQUksa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxLQUFLO0FBQ2pCO0FBQ0EsbUJBQW1CLHVEQUFhO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxlQUFlO0FBQzNCLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ08sa0NBQWtDO0FBQ3pDLFlBQVksYUFBYTtBQUN6Qix1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQWdCO0FBQzlCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9SbHAuanM/OWVhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgQ3Vyc29yIGZyb20gJy4vaW50ZXJuYWwvY3Vyc29yLmpzJztcbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUmxwIH0gZnJvbSAnb3gnXG4gKiBSbHAudG9CeXRlcygnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gVWludDhBcnJheShbMTM5LCAxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSwgIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdCeXRlcycpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvSGV4KCcweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcpXG4gKiAvLyAweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIHJldHVybiB0byh2YWx1ZSwgJ0hleCcpO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBJbnRlcm5hbFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gdG8odmFsdWUsIHRvKSB7XG4gICAgY29uc3QgdG9fID0gdG8gPz8gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycpO1xuICAgIGNvbnN0IGJ5dGVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAzICYmIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnZhbGlkTGVuZ3RoRXJyb3IodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUoYnl0ZXMsIHtcbiAgICAgICAgcmVjdXJzaXZlUmVhZExpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG9fKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvID0gJ0hleCcpIHtcbiAgICBpZiAoY3Vyc29yLmJ5dGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICh0byA9PT0gJ0hleCcgPyBIZXguZnJvbUJ5dGVzKGN1cnNvci5ieXRlcykgOiBjdXJzb3IuYnl0ZXMpO1xuICAgIGNvbnN0IHByZWZpeCA9IGN1cnNvci5yZWFkQnl0ZSgpO1xuICAgIGlmIChwcmVmaXggPCAweDgwKVxuICAgICAgICBjdXJzb3IuZGVjcmVtZW50UG9zaXRpb24oMSk7XG4gICAgLy8gYnl0ZXNcbiAgICBpZiAocHJlZml4IDwgMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkTGVuZ3RoKGN1cnNvciwgcHJlZml4LCAweDgwKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhieXRlcykgOiBieXRlcyk7XG4gICAgfVxuICAgIC8vIGxpc3RcbiAgICBjb25zdCBsZW5ndGggPSByZWFkTGVuZ3RoKGN1cnNvciwgcHJlZml4LCAweGMwKTtcbiAgICByZXR1cm4gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkTGVuZ3RoKGN1cnNvciwgcHJlZml4LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAweDgwICYmIHByZWZpeCA8IDB4ODApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChwcmVmaXggPD0gb2Zmc2V0ICsgNTUpXG4gICAgICAgIHJldHVybiBwcmVmaXggLSBvZmZzZXQ7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyAxKVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50OCgpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMilcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDE2KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyAzKVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MjQoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDQpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQzMigpO1xuICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdJbnZhbGlkIFJMUCBwcmVmaXgnKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkTGlzdChjdXJzb3IsIGxlbmd0aCwgdG8pIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci5wb3NpdGlvbjtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zaXRpb24gLSBwb3NpdGlvbiA8IGxlbmd0aClcbiAgICAgICAgdmFsdWUucHVzaChkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0bykpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbSgnMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JywgeyBhczogJ0hleCcgfSlcbiAqIC8vIEBsb2c6IDB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKlxuICogUmxwLmZyb20oQnl0ZXMuZnJvbShbMTM5LCAxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSwgIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pLCB7IGFzOiAnQnl0ZXMnIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSwgIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIFJMUCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVuY29kYWJsZSA9IGdldEVuY29kYWJsZSh2YWx1ZSk7XG4gICAgY29uc3QgY3Vyc29yID0gQ3Vyc29yLmNyZWF0ZShuZXcgVWludDhBcnJheShlbmNvZGFibGUubGVuZ3RoKSk7XG4gICAgZW5jb2RhYmxlLmVuY29kZShjdXJzb3IpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGN1cnNvci5ieXRlcyk7XG4gICAgcmV0dXJuIGN1cnNvci5ieXRlcztcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbShbMTM5LCAxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSwgIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIFJMUCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGZyb20oYnl0ZXMsIHsgYXMgfSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb21IZXgoJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcpXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIFJMUCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGZyb20oaGV4LCB7IGFzIH0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBJbnRlcm5hbFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBnZXRFbmNvZGFibGUoYnl0ZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpXG4gICAgICAgIHJldHVybiBnZXRFbmNvZGFibGVMaXN0KGJ5dGVzLm1hcCgoeCkgPT4gZ2V0RW5jb2RhYmxlKHgpKSk7XG4gICAgcmV0dXJuIGdldEVuY29kYWJsZUJ5dGVzKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kYWJsZUxpc3QobGlzdCkge1xuICAgIGNvbnN0IGJvZHlMZW5ndGggPSBsaXN0LnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4Lmxlbmd0aCwgMCk7XG4gICAgY29uc3Qgc2l6ZU9mQm9keUxlbmd0aCA9IGdldFNpemVPZkxlbmd0aChib2R5TGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYm9keUxlbmd0aCA8PSA1NSlcbiAgICAgICAgICAgIHJldHVybiAxICsgYm9keUxlbmd0aDtcbiAgICAgICAgcmV0dXJuIDEgKyBzaXplT2ZCb2R5TGVuZ3RoICsgYm9keUxlbmd0aDtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgZW5jb2RlKGN1cnNvcikge1xuICAgICAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHhjMCArIGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyA1NSArIHNpemVPZkJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQ4KGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDE2KGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDMpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDI0KGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZW5jb2RlIH0gb2YgbGlzdCkge1xuICAgICAgICAgICAgICAgIGVuY29kZShjdXJzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVCeXRlcyhieXRlc09ySGV4KSB7XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgYnl0ZXNPckhleCA9PT0gJ3N0cmluZycgPyBCeXRlcy5mcm9tSGV4KGJ5dGVzT3JIZXgpIDogYnl0ZXNPckhleDtcbiAgICBjb25zdCBzaXplT2ZCeXRlc0xlbmd0aCA9IGdldFNpemVPZkxlbmd0aChieXRlcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIDEgKyBzaXplT2ZCeXRlc0xlbmd0aCArIGJ5dGVzLmxlbmd0aDtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgZW5jb2RlKGN1cnNvcikge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMSAmJiBieXRlc1swXSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweDgwICsgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweDgwICsgNTUgKyBzaXplT2ZCeXRlc0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQ4KGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQnl0ZXNMZW5ndGggPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDE2KGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQnl0ZXNMZW5ndGggPT09IDMpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDI0KGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQzMihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTaXplT2ZMZW5ndGgobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmZfZmYpXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChsZW5ndGggPD0gMHhmZl9mZl9mZilcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmX2ZmX2ZmX2ZmKVxuICAgICAgICByZXR1cm4gNDtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignTGVuZ3RoIGlzIHRvbyBsYXJnZS4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJscC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Rlp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Secp256k1.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Secp256k1.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n\n/** Re-export of noble/curves secp256k1 utilities. */\nconst noble = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nfunction createKeyPair(options = {}) {\n    const { as = 'Hex' } = options;\n    const privateKey = randomPrivateKey({ as });\n    const publicKey = getPublicKey({ privateKey });\n    return {\n        privateKey: privateKey,\n        publicKey,\n    };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nfunction getSharedSecret(options) {\n    const { as = 'Hex', privateKey, publicKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.normPrivateKeyToScalar(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nfunction recoverAddress(options) {\n    return _Address_js__WEBPACK_IMPORTED_MODULE_3__.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload).substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nfunction sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(_Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nfunction verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address)\n        return _Address_js__WEBPACK_IMPORTED_MODULE_3__.isEqual(address, recoverAddress({ payload, signature }));\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(signature, _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toBytes(publicKey), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=Secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWjtBQUNKO0FBQ0o7QUFDaUI7QUFDTDtBQUM1QztBQUNPLGNBQWMsOERBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxhQUFhO0FBQ3pCLDBDQUEwQyxJQUFJO0FBQzlDLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGFBQWE7QUFDekIsa0JBQWtCLDhEQUFTLGdDQUFnQyx5Q0FBUTtBQUNuRSxXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksb0NBQW9DO0FBQ2hELGtCQUFrQiw4REFBUyx5QkFBeUIsZ0RBQWU7QUFDbkUsdUNBQXVDLDhEQUFTLDhCQUE4Qix5Q0FBUTtBQUN0Rix1REFBdUQ7QUFDdkQ7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksYUFBYTtBQUN6QixrQkFBa0IsOERBQVM7QUFDM0I7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHNDQUFzQyw0Q0FBNEM7QUFDbEY7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLGdCQUFnQjtBQUM1QiwyQkFBMkIsOERBQVM7QUFDcEMsOENBQThDLHlDQUFRO0FBQ3RELFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNPO0FBQ1AsWUFBWSxlQUFlLDhEQUFvQiwrQkFBK0I7QUFDOUUsWUFBWSxpQkFBaUIsRUFBRSw4REFBUyxNQUFNLDJDQUFVLFdBQVcsMkNBQVU7QUFDN0U7QUFDQTtBQUNBLGNBQWMseUNBQVE7QUFDdEI7QUFDQSxxQkFBcUIsZ0JBQWdCLElBQUk7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRCxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLCtDQUErQztBQUMzRDtBQUNBLGVBQWUsZ0RBQWUsMkJBQTJCLG9CQUFvQjtBQUM3RSxXQUFXLDhEQUFTLG1CQUFtQiwyQ0FBVSxXQUFXLGtEQUFpQiwyQkFBMkIsMkJBQTJCO0FBQ25JO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TZWNwMjU2azEuanM/MzAyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBFbnRyb3B5IGZyb20gJy4vaW50ZXJuYWwvZW50cm9weS5qcyc7XG5pbXBvcnQgKiBhcyBQdWJsaWNLZXkgZnJvbSAnLi9QdWJsaWNLZXkuanMnO1xuLyoqIFJlLWV4cG9ydCBvZiBub2JsZS9jdXJ2ZXMgc2VjcDI1NmsxIHV0aWxpdGllcy4gKi9cbmV4cG9ydCBjb25zdCBub2JsZSA9IHNlY3AyNTZrMTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzZWNwMjU2azEgRUNEU0Ega2V5IHBhaXIgY29uc2lzdGluZyBvZiBhIHByaXZhdGUga2V5IGFuZCBpdHMgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IFNlY3AyNTZrMS5jcmVhdGVLZXlQYWlyKClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIGtleSBwYWlyLlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBrZXkgcGFpciBjb250YWluaW5nIGJvdGggcHJpdmF0ZSBhbmQgcHVibGljIGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXlQYWlyKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcmFuZG9tUHJpdmF0ZUtleSh7IGFzIH0pO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzZWNwMjU2azEgRUNEU0EgcHVibGljIGtleSBmcm9tIGEgcHJvdmlkZWQgcHJpdmF0ZSBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBTZWNwMjU2azEuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb21wdXRlIHRoZSBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGNvbXB1dGVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbVByaXZhdGVLZXkoSGV4LmZyb20ocHJpdmF0ZUtleSkuc2xpY2UoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIENvbXB1dGVzIGEgc2hhcmVkIHNlY3JldCB1c2luZyBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUtSGVsbG1hbikgYmV0d2VlbiBhIHByaXZhdGUga2V5IGFuZCBhIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXk6IHByaXZhdGVLZXlBIH0gPSBTZWNwMjU2azEuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCB7IHB1YmxpY0tleTogcHVibGljS2V5QiB9ID0gU2VjcDI1NmsxLmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IHNoYXJlZFNlY3JldCA9IFNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQoe1xuICogICBwcml2YXRlS2V5OiBwcml2YXRlS2V5QSxcbiAqICAgcHVibGljS2V5OiBwdWJsaWNLZXlCXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb21wdXRlIHRoZSBzaGFyZWQgc2VjcmV0LlxuICogQHJldHVybnMgVGhlIGNvbXB1dGVkIHNoYXJlZCBzZWNyZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JywgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFB1YmxpY0tleS50b0hleChwdWJsaWNLZXkpLnNsaWNlKDIpKTtcbiAgICBjb25zdCBzaGFyZWRQb2ludCA9IHBvaW50Lm11bHRpcGx5KHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKEhleC5mcm9tKHByaXZhdGVLZXkpLnNsaWNlKDIpKSk7XG4gICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gc2hhcmVkUG9pbnQudG9SYXdCeXRlcyh0cnVlKTsgLy8gY29tcHJlc3NlZCBmb3JtYXRcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhzaGFyZWRTZWNyZXQpO1xuICAgIHJldHVybiBzaGFyZWRTZWNyZXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBFQ0RTQSBwcml2YXRlIGtleSBvbiB0aGUgc2VjcDI1NmsxIGN1cnZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHByaXZhdGUga2V5LlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVByaXZhdGVLZXkob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBhZGRyZXNzIGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IGFkZHJlc3MgPSBTZWNwMjU2azEucmVjb3ZlckFkZHJlc3MoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgcmVjb3ZlcmVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleShyZWNvdmVyUHVibGljS2V5KG9wdGlvbnMpKTtcbn1cbi8qKlxuICogUmVjb3ZlcnMgdGhlIHNpZ25pbmcgcHVibGljIGtleSBmcm9tIHRoZSBzaWduZWQgcGF5bG9hZCBhbmQgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBTZWNwMjU2azEucmVjb3ZlclB1YmxpY0tleSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSByZWNvdmVyZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShCaWdJbnQociksIEJpZ0ludChzKSkuYWRkUmVjb3ZlcnlCaXQoeVBhcml0eSk7XG4gICAgY29uc3QgcG9pbnQgPSBzaWduYXR1cmVfLnJlY292ZXJQdWJsaWNLZXkoSGV4LmZyb20ocGF5bG9hZCkuc3Vic3RyaW5nKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuLyoqXG4gKiBTaWducyB0aGUgcGF5bG9hZCB3aXRoIHRoZSBwcm92aWRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgRUNEU0Ege0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBleHRyYUVudHJvcHkgPSBFbnRyb3B5LmV4dHJhRW50cm9weSwgaGFzaCwgcGF5bG9hZCwgcHJpdmF0ZUtleSwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCByZWNvdmVyeSB9ID0gc2VjcDI1NmsxLnNpZ24oQnl0ZXMuZnJvbShwYXlsb2FkKSwgQnl0ZXMuZnJvbShwcml2YXRlS2V5KSwge1xuICAgICAgICBleHRyYUVudHJvcHk6IHR5cGVvZiBleHRyYUVudHJvcHkgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBleHRyYUVudHJvcHlcbiAgICAgICAgICAgIDogSGV4LmZyb20oZXh0cmFFbnRyb3B5KS5zbGljZSgyKSxcbiAgICAgICAgbG93UzogdHJ1ZSxcbiAgICAgICAgLi4uKGhhc2ggPyB7IHByZWhhc2g6IHRydWUgfSA6IHt9KSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5OiByZWNvdmVyeSxcbiAgICB9O1xufVxuLyoqXG4gKiBWZXJpZmllcyBhIHBheWxvYWQgd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFZlcmlmeSB3aXRoIEV0aGVyZXVtIEFkZHJlc3NcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IFNlY3AyNTZrMS52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGFkZHJlc3M6ICcweGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5IHdpdGggUHVibGljIEtleVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gJzB4Li4uJ1xuICogY29uc3QgcHVibGljS2V5ID0gU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgdmVyaWZpZWQgPSBTZWNwMjU2azEudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdmVyaWZpY2F0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgaGFzaCwgcGF5bG9hZCwgcHVibGljS2V5LCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGFkZHJlc3MpXG4gICAgICAgIHJldHVybiBBZGRyZXNzLmlzRXF1YWwoYWRkcmVzcywgcmVjb3ZlckFkZHJlc3MoeyBwYXlsb2FkLCBzaWduYXR1cmUgfSkpO1xuICAgIHJldHVybiBzZWNwMjU2azEudmVyaWZ5KHNpZ25hdHVyZSwgQnl0ZXMuZnJvbShwYXlsb2FkKSwgUHVibGljS2V5LnRvQnl0ZXMocHVibGljS2V5KSwgLi4uKGhhc2ggPyBbeyBwcmVoYXNoOiB0cnVlLCBsb3dTOiB0cnVlIH1dIDogW10pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nfunction extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nfunction from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nfunction toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nfunction toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nfunction toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nfunction vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nfunction yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nclass MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nclass InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nclass InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nclass InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nclass InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNoQjtBQUNFO0FBQ047QUFDRTtBQUNRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLFlBQVk7QUFDeEI7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQsMENBQTBDLG9EQUFtQjtBQUM3RCxrQ0FBa0Msb0JBQW9CO0FBQ3RELDBDQUEwQyxvREFBbUI7QUFDN0Qsa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLDZCQUE2Qiw2QkFBNkI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUCxtQkFBbUIsOENBQWE7QUFDaEM7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsNkJBQTZCLDZCQUE2QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUDtBQUNBLCtDQUErQyxXQUFXO0FBQzFELHFCQUFxQiwwQ0FBUztBQUM5QixxQkFBcUIsMENBQVM7QUFDOUI7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCLGVBQWUsNkJBQTZCLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCLE1BQU0saUJBQWlCO0FBQy9LO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ087QUFDUCxzQkFBc0IsOENBQWE7QUFDbkM7QUFDQTtBQUNBLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDTztBQUNQLFlBQVksT0FBTyxFQUFFLDhEQUFTLG1CQUFtQix5Q0FBUTtBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWUsMkJBQTJCLFFBQVEsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0IsUUFBUSw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLE1BQU0sNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pELGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEIsSUFBSSxxQkFBcUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCLElBQUksaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUFVLENBQUMsK0NBQWMsTUFBTSxVQUFVLEdBQUcsK0NBQWMsTUFBTSxVQUFVO0FBQ2pHO0FBQ0E7QUFDQSxVQUFVLCtDQUFjLGtDQUFrQyxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQiw4REFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLDhEQUFTO0FBQzdCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QixRQUFRLDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFLGNBQWM7QUFDZDtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RCwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCLFFBQVEsdUJBQXVCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pELDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDTztBQUNQLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsV0FBVywrQ0FBYyxNQUFNLFVBQVU7QUFDekMsV0FBVywrQ0FBYyxNQUFNLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QixpQkFBaUIsMEJBQTBCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNPO0FBQ1AsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBWSxDQUFDLCtDQUFjO0FBQ3JELDBCQUEwQiw2Q0FBWSxDQUFDLCtDQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDTyx5Q0FBeUMsaURBQWdCO0FBQ2hFLGtCQUFrQixXQUFXO0FBQzdCLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIseUNBQVEsQ0FBQyx5Q0FBUSxjQUFjO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08scUNBQXFDLGlEQUFnQjtBQUM1RCxrQkFBa0IsV0FBVztBQUM3Qiw2QkFBNkIsK0NBQWMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsaURBQWdCO0FBQ25ELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaWduYXR1cmUuanM/NTcwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIFNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5hc3NlcnQoe1xuICogICByOiAtNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGVycm9yOiBJbnZhbGlkU2lnbmF0dXJlUkVycm9yOlxuICogLy8gQGVycm9yOiBWYWx1ZSBgLTU0OS4uLm5gIGlzIGFuIGludmFsaWQgciB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyByZWNvdmVyZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAocmVjb3ZlcmVkICYmIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChzaWduYXR1cmUuciA8IDBuIHx8IHNpZ25hdHVyZS5yID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnIgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5zIDwgMG4gfHwgc2lnbmF0dXJlLnMgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUucyB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMCAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21CeXRlcyhuZXcgVWludDhBcnJheShbMTI4LCAzLCAxMzEsIC4uLl0pKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tSGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNIZXguSGV4fSBzaWduYXR1cmUgaW50byBhIHN0cnVjdHVyZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21IZXgoJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYycpXG4gKiAvLyBAbG9nOiB7IHI6IDUyMzEuLi5uLCBzOiAzNTIyLi4ubiwgeVBhcml0eTogMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwICYmIHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoSGV4LnNsaWNlKHNpZ25hdHVyZSwgMCwgMzIpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDMyLCA2NCkpO1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB5UGFyaXR5ID0gTnVtYmVyKGAweCR7c2lnbmF0dXJlLnNsaWNlKDEzMCl9YCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeVBhcml0eSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZUb1lQYXJpdHkoeVBhcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgaWYgKHR5cGVvZiB5UGFyaXR5ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzLFxuICAgICAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gZnJvbSBhbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgbWF5IGluY2x1ZGUgc2lnbmF0dXJlIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5leHRyYWN0KHtcbiAqICAgYmF6OiAnYmFycnknLFxuICogICBmb286ICdiYXInLFxuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqICAgemVicmE6ICdzdHJpcGVzJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJiaXRyYXJ5IG9iamVjdCB0byBleHRyYWN0IHRoZSBzaWduYXR1cmUgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHR5cGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBvYmplY3QgZnJvbSBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSwge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MDEnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBMZWdhY3lcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqICAgdjogMjcsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAvLyBAbG9nOiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdmFsdWUgdG8gaW5zdGFudGlhdGUuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFudGlhdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tUnBjKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUudilcbiAgICAgICAgICAgIHJldHVybiBmcm9tTGVnYWN5KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgLi4uKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHsgeVBhcml0eTogc2lnbmF0dXJlLnlQYXJpdHkgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZV8pO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJCeXRlcyhuZXcgVWludDhBcnJheShbMTMyLCA1MSwgMjMsIC4uLl0pKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tRGVySGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJIZXgoJzB4MzA0NDAyMjA2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmMDIyMDRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbURFUihIZXguZnJvbShzaWduYXR1cmUpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4geyByLCBzIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUuZnJvbUxlZ2FjeSh7IHI6IDFuLCBzOiAybiwgdjogMjggfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB5UGFyaXR5OiB2VG9ZUGFyaXR5KHNpZ25hdHVyZS52KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ScGMoe1xuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeVBhcml0eSA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUudiA/IE51bWJlcihzaWduYXR1cmUudikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB5UGFyaXR5ID0gc2lnbmF0dXJlLnlQYXJpdHkgPyBOdW1iZXIoc2lnbmF0dXJlLnlQYXJpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInICYmIHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHlQYXJpdHkgPSB2VG9ZUGFyaXR5KHYpO1xuICAgICAgICBpZiAodHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG4gICAgICAgIHJldHVybiB5UGFyaXR5O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogQmlnSW50KHNpZ25hdHVyZS5yKSxcbiAgICAgICAgczogQmlnSW50KHNpZ25hdHVyZS5zKSxcbiAgICAgICAgeVBhcml0eSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21UdXBsZShbJzB4MDEnLCAnMHg3YicsICcweDFjOCddKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiAxMjNuLFxuICogLy8gQGxvZzogICBzOiA0NTZuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW3lQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICByOiByID09PSAnMHgnID8gMG4gOiBCaWdJbnQociksXG4gICAgICAgIHM6IHMgPT09ICcweCcgPyAwbiA6IEJpZ0ludChzKSxcbiAgICAgICAgeVBhcml0eTogeVBhcml0eSA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoeVBhcml0eSksXG4gICAgfSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b0J5dGVzKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMDIsIDE2LCAxMCwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleChzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9IZXgoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6ICcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlKTtcbiAgICBjb25zdCByID0gc2lnbmF0dXJlLnI7XG4gICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBIZXguY29uY2F0KEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksIFxuICAgIC8vIElmIHRoZSBzaWduYXR1cmUgaXMgcmVjb3ZlcmVkLCBhZGQgdGhlIHJlY292ZXJ5IGJ5dGUgdG8gdGhlIHNpZ25hdHVyZS5cbiAgICB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICdudW1iZXInXG4gICAgICAgID8gSGV4LmZyb21OdW1iZXIoeVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSksIHsgc2l6ZTogMSB9KVxuICAgICAgICA6ICcweCcpO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVyQnl0ZXMoc2lnbmF0dXJlKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTMyLCA1MSwgMjMsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBzaWcudG9ERVJSYXdCeXRlcygpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVySGV4KHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6ICcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBgMHgke3NpZy50b0RFUkhleCgpfWA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUudG9MZWdhY3koeyByOiAxbiwgczogMm4sIHlQYXJpdHk6IDEgfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB2OiAyOCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHY6IHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9ScGMoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHM6IEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09IDAgPyAnMHgwJyA6ICcweDEnLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGEgc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBiZSB1c2VkIGZvciBzaWduYXR1cmVzIGluIFRyYW5zYWN0aW9uIEVudmVsb3BlcywgRUlQLTc3MDIgQXV0aG9yaXphdGlvbiBMaXN0cywgZXRjLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlVHVwbGUgPSBTaWduYXR1cmUudG9UdXBsZSh7XG4gKiAgIHI6IDEyM24sXG4gKiAgIHM6IDQ1Nm4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzogW3lQYXJpdHk6ICcweDAxJywgcjogJzB4N2InLCBzOiAnMHgxYzgnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeVBhcml0eSA/ICcweDAxJyA6ICcweCcsXG4gICAgICAgIHIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihyKSksXG4gICAgICAgIHMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzKSksXG4gICAgXTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgU2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlLnZhbGlkYXRlKHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB5UGFyaXR5ID0gU2lnbmF0dXJlLnZUb1lQYXJpdHkoMjgpXG4gKiAvLyBAbG9nOiAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSBFQ0RTQSBgdmAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgeVBhcml0eWAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2VG9ZUGFyaXR5KHYpIHtcbiAgICBpZiAodiA9PT0gMCB8fCB2ID09PSAyNylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHYgPT09IDEgfHwgdiA9PT0gMjgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh2ID49IDM1KVxuICAgICAgICByZXR1cm4gdiAlIDIgPT09IDAgPyAxIDogMDtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFZFcnJvcih7IHZhbHVlOiB2IH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEVDRFNBIGB2YCB2YWx1ZSB0byBhIGB5UGFyaXR5YCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHYgPSBTaWduYXR1cmUueVBhcml0eVRvVigxKVxuICogLy8gQGxvZzogMjhcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB5UGFyaXR5IC0gVGhlIEVDRFNBIGB5UGFyaXR5YCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGB2YCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlQYXJpdHlUb1YoeVBhcml0eSkge1xuICAgIGlmICh5UGFyaXR5ID09PSAwKVxuICAgICAgICByZXR1cm4gMjc7XG4gICAgaWYgKHlQYXJpdHkgPT09IDEpXG4gICAgICAgIHJldHVybiAyODtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiB5UGFyaXR5IH0pO1xufVxuLyoqIFRocm93biB3aGVuIHRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZSBpcyBvZiBhbiBpbnZhbGlkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3NpZ25hdHVyZX1cXGAgaXMgYW4gaW52YWxpZCBzaWduYXR1cmUgc2l6ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQ6IDY0IGJ5dGVzIG9yIDY1IGJ5dGVzLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20oc2lnbmF0dXJlKSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaXMgbWlzc2luZyBlaXRoZXIgYW4gYHJgLCBgc2AsIG9yIGB5UGFyaXR5YCBwcm9wZXJ0eS4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzaW5nUHJvcGVydGllc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgU2lnbmF0dXJlIFxcYCR7SnNvbi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1cXGAgaXMgbWlzc2luZyBlaXRoZXIgYW4gXFxgclxcYCwgXFxgc1xcYCwgb3IgXFxgeVBhcml0eVxcYCBwcm9wZXJ0eS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5NaXNzaW5nUHJvcGVydGllc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgcmAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFJFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCByIHZhbHVlLiByIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkUkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgc2AgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBzIHZhbHVlLiBzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgeVBhcml0eWAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFlQYXJpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB5LXBhcml0eSB2YWx1ZS4gWS1wYXJpdHkgbXVzdCBiZSAwIG9yIDEuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFlQYXJpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHZgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRWRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgdiB2YWx1ZS4gdiBtdXN0IGJlIDI3LCAyOCBvciA+PTM1LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRWRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Tb2xpZGl0eS5qcz85NzhhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBhcnJheVJlZ2V4ID0gL14oLiopXFxbKFswLTldKilcXF0kLztcbi8vIGBieXRlczxNPmA6IGJpbmFyeSB0eXBlIG9mIGBNYCBieXRlcywgYDAgPCBNIDw9IDMyYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTU1XG5leHBvcnQgY29uc3QgYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xuLy8gYCh1KWludDxNPmA6ICh1bilzaWduZWQgaW50ZWdlciB0eXBlIG9mIGBNYCBiaXRzLCBgMCA8IE0gPD0gMjU2YCwgYE0gJSA4ID09IDBgXG4vLyBodHRwczovL3JlZ2V4ci5jb20vNnY4aHBcbmV4cG9ydCBjb25zdCBpbnRlZ2VyUmVnZXggPSAvXih1P2ludCkoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbmV4cG9ydCBjb25zdCBtYXhJbnQ4ID0gMm4gKiogKDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTYgPSAybiAqKiAoMTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQgPSAybiAqKiAoMjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MzIgPSAybiAqKiAoMzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NDAgPSAybiAqKiAoNDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NDggPSAybiAqKiAoNDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NTYgPSAybiAqKiAoNTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NjQgPSAybiAqKiAoNjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NzIgPSAybiAqKiAoNzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50ODAgPSAybiAqKiAoODBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50ODggPSAybiAqKiAoODhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50OTYgPSAybiAqKiAoOTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTA0ID0gMm4gKiogKDEwNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMTIgPSAybiAqKiAoMTEybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEyMCA9IDJuICoqICgxMjBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTI4ID0gMm4gKiogKDEyOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMzYgPSAybiAqKiAoMTM2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE0NCA9IDJuICoqICgxNDRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTUyID0gMm4gKiogKDE1Mm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNjAgPSAybiAqKiAoMTYwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2OCA9IDJuICoqICgxNjhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTc2ID0gMm4gKiogKDE3Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxODQgPSAybiAqKiAoMTg0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE5MiA9IDJuICoqICgxOTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjAwID0gMm4gKiogKDIwMG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMDggPSAybiAqKiAoMjA4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIxNiA9IDJuICoqICgyMTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjI0ID0gMm4gKiogKDIyNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMzIgPSAybiAqKiAoMjMybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0MCA9IDJuICoqICgyNDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQ4ID0gMm4gKiogKDI0OG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNTYgPSAybiAqKiAoMjU2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1pbkludDggPSAtKDJuICoqICg4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTYgPSAtKDJuICoqICgxNm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDI0ID0gLSgybiAqKiAoMjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQzMiA9IC0oMm4gKiogKDMybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NDAgPSAtKDJuICoqICg0MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDQ4ID0gLSgybiAqKiAoNDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ1NiA9IC0oMm4gKiogKDU2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NjQgPSAtKDJuICoqICg2NG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDcyID0gLSgybiAqKiAoNzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4MCA9IC0oMm4gKiogKDgwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50ODggPSAtKDJuICoqICg4OG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDk2ID0gLSgybiAqKiAoOTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMDQgPSAtKDJuICoqICgxMDRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMTIgPSAtKDJuICoqICgxMTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMjAgPSAtKDJuICoqICgxMjBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMjggPSAtKDJuICoqICgxMjhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMzYgPSAtKDJuICoqICgxMzZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNDQgPSAtKDJuICoqICgxNDRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNTIgPSAtKDJuICoqICgxNTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNjAgPSAtKDJuICoqICgxNjBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNjggPSAtKDJuICoqICgxNjhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNzYgPSAtKDJuICoqICgxNzZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxODQgPSAtKDJuICoqICgxODRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxOTIgPSAtKDJuICoqICgxOTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMDAgPSAtKDJuICoqICgyMDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMDggPSAtKDJuICoqICgyMDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMTYgPSAtKDJuICoqICgyMTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMjQgPSAtKDJuICoqICgyMjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMzIgPSAtKDJuICoqICgyMzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNDAgPSAtKDJuICoqICgyNDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNDggPSAtKDJuICoqICgyNDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNTYgPSAtKDJuICoqICgyNTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtYXhVaW50OCA9IDJuICoqIDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2ID0gMm4gKiogMTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0ID0gMm4gKiogMjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDMyID0gMm4gKiogMzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDQwID0gMm4gKiogNDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDQ4ID0gMm4gKiogNDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDU2ID0gMm4gKiogNTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDY0ID0gMm4gKiogNjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDcyID0gMm4gKiogNzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDgwID0gMm4gKiogODBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDg4ID0gMm4gKiogODhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDk2ID0gMm4gKiogOTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEwNCA9IDJuICoqIDEwNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTEyID0gMm4gKiogMTEybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMjAgPSAybiAqKiAxMjBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEyOCA9IDJuICoqIDEyOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTM2ID0gMm4gKiogMTM2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNDQgPSAybiAqKiAxNDRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE1MiA9IDJuICoqIDE1Mm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTYwID0gMm4gKiogMTYwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNjggPSAybiAqKiAxNjhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE3NiA9IDJuICoqIDE3Nm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTg0ID0gMm4gKiogMTg0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxOTIgPSAybiAqKiAxOTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIwMCA9IDJuICoqIDIwMG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjA4ID0gMm4gKiogMjA4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMTYgPSAybiAqKiAyMTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIyNCA9IDJuICoqIDIyNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjMyID0gMm4gKiogMjMybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNDAgPSAybiAqKiAyNDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0OCA9IDJuICoqIDI0OG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjU2ID0gMm4gKiogMjU2biAtIDFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29saWRpdHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0EsZUFBZSx5QkFBeUIsT0FBTywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0MsT0FBTyx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCLGVBQWUsK0NBQWM7QUFDN0Isd0JBQXdCLCtDQUFjO0FBQ3RDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dpdGhkcmF3YWwuanM/MzdjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNXaXRoZHJhd2FsLlJwY30gdG8gYW4ge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXaXRoZHJhd2FsIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgd2l0aGRyYXdhbCA9IFdpdGhkcmF3YWwuZnJvbVJwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogICBhbW91bnQ6ICcweDYyMDMyMycsXG4gKiAgIGluZGV4OiAnMHgwJyxcbiAqICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAvLyBAbG9nOiAgIGFtb3VudDogNjQyMzMzMW4sXG4gKiAvLyBAbG9nOiAgIGluZGV4OiAwLFxuICogLy8gQGxvZzogICB2YWxpZGF0b3JJbmRleDogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdpdGhkcmF3YWwgLSBUaGUgUlBDIHdpdGhkcmF3YWwgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMod2l0aGRyYXdhbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLndpdGhkcmF3YWwsXG4gICAgICAgIGFtb3VudDogQmlnSW50KHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IE51bWJlcih3aXRoZHJhd2FsLmluZGV4KSxcbiAgICAgICAgdmFsaWRhdG9ySW5kZXg6IE51bWJlcih3aXRoZHJhd2FsLnZhbGlkYXRvckluZGV4KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9IHRvIGFuIHtAbGluayBveCNXaXRoZHJhd2FsLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXaXRoZHJhd2FsIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgd2l0aGRyYXdhbCA9IFdpdGhkcmF3YWwudG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqICAgYW1vdW50OiA2NDIzMzMxbixcbiAqICAgaW5kZXg6IDAsXG4gKiAgIHZhbGlkYXRvckluZGV4OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAvLyBAbG9nOiAgIGFtb3VudDogJzB4NjIwMzIzJyxcbiAqIC8vIEBsb2c6ICAgaW5kZXg6ICcweDAnLFxuICogLy8gQGxvZzogICB2YWxpZGF0b3JJbmRleDogJzB4MScsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2l0aGRyYXdhbCAtIFRoZSBXaXRoZHJhd2FsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMgV2l0aGRyYXdhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiB3aXRoZHJhd2FsLmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC5hbW91bnQpLFxuICAgICAgICBpbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBIZXguZnJvbU51bWJlcih3aXRoZHJhd2FsLnZhbGlkYXRvckluZGV4KSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2l0aGRyYXdhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: () => (/* binding */ getAmbiguousTypes),\n/* harmony export */   isArgOfType: () => (/* binding */ isArgOfType),\n/* harmony export */   normalizeSignature: () => (/* binding */ normalizeSignature)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */\nfunction normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nfunction isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDRjtBQUN2QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFnQixRQUFRLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxTQUFTLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsR0FBRztBQUNwRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBZ0I7QUFDdkM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx1QkFBdUIsaURBQWdCO0FBQ3ZDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaUl0ZW0uanM/OWU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL0Vycm9ycy5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGxldCBhY3RpdmUgPSB0cnVlO1xuICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgbGV0IHZhbGlkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHNpZ25hdHVyZVtpXTtcbiAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvciwgd2Ugd2FudCB0byByZWFjdGl2YXRlLlxuICAgICAgICBpZiAoWycoJywgJyknLCAnLCddLmluY2x1ZGVzKGNoYXIpKVxuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIFwibGV2ZWxcIiB0b2tlbiwgd2Ugd2FudCB0byBpbmNyZW1lbnQvZGVjcmVtZW50LlxuICAgICAgICBpZiAoY2hhciA9PT0gJygnKVxuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgaWYgKGNoYXIgPT09ICcpJylcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBhY3RpdmUsIHdlIGRvbid0IHdhbnQgdG8gbXV0YXRlIHRoZSByZXN1bHQuXG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vIElmIGxldmVsID09PSAwLCB3ZSBhcmUgYXQgdGhlIGRlZmluaXRpb24gbGV2ZWwuXG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcgJyAmJiBbJ2V2ZW50JywgJ2Z1bmN0aW9uJywgJ2Vycm9yJywgJyddLmluY2x1ZGVzKHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgZGVmaW5pdGlvbiwgd2UgbXVzdCBiZSBmaW5pc2hlZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIHNwYWNlc1xuICAgICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yLCBhbmQgdGhlIGN1cnJlbnQgc2VjdGlvbiBpc24ndCBlbXB0eSwgd2Ugd2FudCB0byBkZWFjdGl2YXRlLlxuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZVtpIC0gMV0gIT09ICcsJyAmJiBjdXJyZW50ICE9PSAnLCcgJiYgY3VycmVudCAhPT0gJywoJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgfVxuICAgIGlmICghdmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdVbmFibGUgdG8gbm9ybWFsaXplIHNpZ25hdHVyZS4nKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJnT2ZUeXBlKGFyZywgYWJpUGFyYW1ldGVyKSB7XG4gICAgY29uc3QgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVyVHlwZSA9IGFiaVBhcmFtZXRlci50eXBlO1xuICAgIHN3aXRjaCAoYWJpUGFyYW1ldGVyVHlwZSkge1xuICAgICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJztcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgaWYgKGFiaVBhcmFtZXRlclR5cGUgPT09ICd0dXBsZScgJiYgJ2NvbXBvbmVudHMnIGluIGFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhYmlQYXJhbWV0ZXIuY29tcG9uZW50cykuZXZlcnkoKGNvbXBvbmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJnT2ZUeXBlKE9iamVjdC52YWx1ZXMoYXJnKVtpbmRleF0sIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBgKHUpaW50PE0+YDogKHVuKXNpZ25lZCBpbnRlZ2VyIHR5cGUgb2YgYE1gIGJpdHMsIGAwIDwgTSA8PSAyNTZgLCBgTSAlIDggPT0gMGBcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcmVnZXhyLmNvbS82djhocFxuICAgICAgICAgICAgaWYgKC9edT9pbnQoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnbnVtYmVyJyB8fCBhcmdUeXBlID09PSAnYmlnaW50JztcbiAgICAgICAgICAgIC8vIGBieXRlczxNPmA6IGJpbmFyeSB0eXBlIG9mIGBNYCBieXRlcywgYDAgPCBNIDw9IDMyYFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTU1XG4gICAgICAgICAgICBpZiAoL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgICAgIC8vIGZpeGVkLWxlbmd0aCAoYDx0eXBlPltNXWApIGFuZCBkeW5hbWljIChgPHR5cGU+W11gKSBhcnJheXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcmVnZXhyLmNvbS82dmE2aVxuICAgICAgICAgICAgaWYgKC9bYS16XStbMS05XXswLDN9KFxcW1swLTldezAsfVxcXSkrJC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShhcmcpICYmXG4gICAgICAgICAgICAgICAgICAgIGFyZy5ldmVyeSgoeCkgPT4gaXNBcmdPZlR5cGUoeCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWJpUGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wIG9mZiBgW11gIG9yIGBbTV1gIGZyb20gZW5kIG9mIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFiaVBhcmFtZXRlclR5cGUucmVwbGFjZSgvKFxcW1swLTldezAsfVxcXSkkLywgJycpLFxuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFtYmlndW91c1R5cGVzKHNvdXJjZVBhcmFtZXRlcnMsIHRhcmdldFBhcmFtZXRlcnMsIGFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlckluZGV4IGluIHNvdXJjZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlUGFyYW1ldGVyID0gc291cmNlUGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGNvbnN0IHRhcmdldFBhcmFtZXRlciA9IHRhcmdldFBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdO1xuICAgICAgICBpZiAoc291cmNlUGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgIHRhcmdldFBhcmFtZXRlci50eXBlID09PSAndHVwbGUnICYmXG4gICAgICAgICAgICAnY29tcG9uZW50cycgaW4gc291cmNlUGFyYW1ldGVyICYmXG4gICAgICAgICAgICAnY29tcG9uZW50cycgaW4gdGFyZ2V0UGFyYW1ldGVyKVxuICAgICAgICAgICAgcmV0dXJuIGdldEFtYmlndW91c1R5cGVzKHNvdXJjZVBhcmFtZXRlci5jb21wb25lbnRzLCB0YXJnZXRQYXJhbWV0ZXIuY29tcG9uZW50cywgYXJnc1twYXJhbWV0ZXJJbmRleF0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtzb3VyY2VQYXJhbWV0ZXIudHlwZSwgdGFyZ2V0UGFyYW1ldGVyLnR5cGVdO1xuICAgICAgICBjb25zdCBhbWJpZ3VvdXMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ2J5dGVzMjAnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnYWRkcmVzcycpICYmIHR5cGVzLmluY2x1ZGVzKCdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ2J5dGVzJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgaWYgKGFtYmlndW91cylcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/** @internal */\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))), 32];\n}\n/** @internal */\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeBool(cursor) {\n    return [_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data), 32];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [value, 32];\n}\n/** @internal */\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, { signed })\n            : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nfunction prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */\nfunction encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize, 10),\n            value,\n        });\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value) };\n}\n/** @internal */\nfunction encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value)) };\n}\n/** @internal */\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nfunction encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDWjtBQUNKO0FBQ0U7QUFDTjtBQUNhO0FBQzlDO0FBQ087QUFDUCxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCLElBQUkseUNBQXlDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RCxjQUFjLCtEQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQztBQUNsRCxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLHlDQUF5QyxpREFBZ0I7QUFDekQsaUJBQWlCLDhDQUFhLENBQUMsNENBQVc7QUFDMUM7QUFDQTtBQUNPO0FBQ1AsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksZ0RBQWUseUJBQXlCLFVBQVU7QUFDOUQ7QUFDQTtBQUNPLHNDQUFzQyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFhO0FBQzdCO0FBQ0Esa0JBQWtCLDhDQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQWMsVUFBVSxRQUFRO0FBQzlDLGNBQWMsK0NBQWMsVUFBVSxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxnQkFBZ0I7QUFDdkQ7QUFDQSxtQkFBbUIsK0NBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBYyxDQUFDLCtDQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsc0NBQXNDO0FBQzFFO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0Qix3REFBd0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQThCO0FBQzVDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25ELGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25ELGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSxrQ0FBa0MsK0NBQWMsNkJBQTZCLFVBQVU7QUFDdkY7QUFDQSwyQkFBMkIseUNBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBVTtBQUNyQjtBQUNBO0FBQ087QUFDUCxZQUFZLG1CQUFtQjtBQUMvQixJQUFJLCtDQUFjLFVBQVUsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSxpQkFBaUIsNENBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBLGtCQUFrQix1RUFBc0M7QUFDeEQ7QUFDQTtBQUNBLHFCQUFxQixlQUFlLEdBQUcsT0FBTztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQWMsOEJBQThCLFVBQVU7QUFDakY7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVLDhCQUE4QixTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QixNQUFNO0FBQzNDO0FBQ0Esc0JBQXNCLHlDQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQVk7QUFDakM7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBVSxDQUFDLDRDQUFXLENBQUMsK0NBQWMsY0FBYyxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxRUFBb0M7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLHlCQUF5Qiw2Q0FBWTtBQUNsRDtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixpREFBZ0IsNEJBQTRCLE1BQU0sV0FBVyxhQUFhO0FBQzVGLGFBQWEseUJBQXlCLDRDQUFXLENBQUMsZ0RBQWU7QUFDakU7QUFDQTtBQUNPLCtCQUErQixjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBYztBQUMvQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUJBQXFCLCtDQUFjO0FBQ25DLGtDQUFrQyx5Q0FBUTtBQUMxQztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsbUJBQW1CLDZDQUFZLENBQUMsMENBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVLENBQUMsNkNBQVksQ0FBQywrQ0FBYyxDQUFDLHlDQUFRLGNBQWMsVUFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBVSw4QkFBOEIsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzP2JiNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9IZXguanMnO1xuaW1wb3J0IHsgaW50ZWdlclJlZ2V4IH0gZnJvbSAnLi4vU29saWRpdHkuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZGVjb2RlQXJyYXkoY3Vyc29yLCB7IC4uLnBhcmFtLCB0eXBlIH0sIHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3R1cGxlJylcbiAgICAgICAgcmV0dXJuIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2FkZHJlc3MnKVxuICAgICAgICByZXR1cm4gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIHsgY2hlY2tzdW06IGNoZWNrc3VtQWRkcmVzcyB9KTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICByZXR1cm4gZGVjb2RlQm9vbChjdXJzb3IpO1xuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpXG4gICAgICAgIHJldHVybiBkZWNvZGVCeXRlcyhjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKVxuICAgICAgICByZXR1cm4gZGVjb2RlTnVtYmVyKGN1cnNvciwgcGFyYW0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRlY29kZVN0cmluZyhjdXJzb3IsIHsgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcihwYXJhbS50eXBlKTtcbn1cbmNvbnN0IHNpemVPZkxlbmd0aCA9IDMyO1xuY29uc3Qgc2l6ZU9mT2Zmc2V0ID0gMzI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hlY2tzdW0gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIGNvbnN0IHdyYXAgPSAoYWRkcmVzcykgPT4gY2hlY2tzdW0gPyBBZGRyZXNzLmNoZWNrc3VtKGFkZHJlc3MpIDogYWRkcmVzcztcbiAgICByZXR1cm4gW3dyYXAoSGV4LmZyb21CeXRlcyhCeXRlcy5zbGljZSh2YWx1ZSwgLTIwKSkpLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIG5vdCBrbm93biBpbiBhZHZhbmNlIChkeW5hbWljIGFycmF5KSxcbiAgICAvLyB0aGlzIG1lYW5zIHdlIHdpbGwgbmVlZCB0byB3b25kZXIgb2ZmIHRvIHRoZSBwb2ludGVyIGFuZCBkZWNvZGUuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGEgZHluYW1pYyB0eXBlLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiBjdXJyZW50IHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZEYXRhID0gc3RhcnQgKyBzaXplT2ZMZW5ndGg7XG4gICAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBmcm9tIHRoZSBvZmZzZXQuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mTGVuZ3RoKSk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhcnJheSBoYXMgYW55IGR5bmFtaWMgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IGR5bmFtaWNDaGlsZCA9IGhhc0R5bmFtaWNDaGlsZChwYXJhbSk7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBvZiB0aGUgY2hpbGRyZW4gaXMgZHluYW1pYywgdGhlbiBhbGwgZWxlbWVudHMgd2lsbCBiZSBvZmZzZXQgcG9pbnRlciwgdGh1cyBzaXplIG9mIG9uZSBzbG90ICgzMiBieXRlcykuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGVsZW1lbnRzIHdpbGwgYmUgdGhlIHNpemUgb2YgdGhlaXIgZW5jb2RpbmcgKGNvbnN1bWVkIGJ5dGVzKS5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydE9mRGF0YSArIChkeW5hbWljQ2hpbGQgPyBpICogMzIgOiBjb25zdW1lZCkpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRPZkRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBrbm93biBpbiBhZHZhbmNlLFxuICAgIC8vIGFuZCB0aGUgbGVuZ3RoIG9mIGFuIGVsZW1lbnQgZGVlcGx5IG5lc3RlZCBpbiB0aGUgYXJyYXkgaXMgbm90IGtub3duLFxuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWxvbmcgdG8gdGhlIG5leHQgc2xvdCAobmV4dCBvZmZzZXQgcG9pbnRlcikuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBpICogMzIpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGFdID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMga25vd24gaW4gYWR2YW5jZSBhbmQgdGhlIGFycmF5IGlzIGRlZXBseSBzdGF0aWMsXG4gICAgLy8gdGhlbiB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBlbGVtZW50IGluIHNlcXVlbmNlLlxuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGF0aWNQb3NpdGlvbiArIGNvbnN1bWVkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZF07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQm9vbChjdXJzb3IpIHtcbiAgICByZXR1cm4gW0J5dGVzLnRvQm9vbGVhbihjdXJzb3IucmVhZEJ5dGVzKDMyKSwgeyBzaXplOiAzMiB9KSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIGNvbnN0IFtfLCBzaXplXSA9IHBhcmFtLnR5cGUuc3BsaXQoJ2J5dGVzJyk7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYnl0ZXMgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgICAgICAvLyBTZXQgcG9zaXRpb24gb2YgdGhlIGN1cnNvciB0byBzdGFydCBvZiBieXRlcyBkYXRhLlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICAgICAgcmV0dXJuIFsnMHgnLCAzMl07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFtIZXguZnJvbUJ5dGVzKGRhdGEpLCAzMl07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gSGV4LmZyb21CeXRlcyhjdXJzb3IucmVhZEJ5dGVzKE51bWJlci5wYXJzZUludChzaXplLCAxMCksIDMyKSk7XG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKSB7XG4gICAgY29uc3Qgc2lnbmVkID0gcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoJ2ludCcpWzFdIHx8ICcyNTYnLCAxMCk7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzaXplID4gNDhcbiAgICAgICAgICAgID8gQnl0ZXMudG9CaWdJbnQodmFsdWUsIHsgc2lnbmVkIH0pXG4gICAgICAgICAgICA6IEJ5dGVzLnRvTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCB9KSxcbiAgICAgICAgMzIsXG4gICAgXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIFR1cGxlcyBjYW4gaGF2ZSB1bm5hbWVkIGNvbXBvbmVudHMgKGkuZS4gdGhleSBhcmUgYXJyYXlzKSwgc28gd2UgbXVzdFxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSB0dXBsZSBpcyBuYW1lZCBvciB1bm5hbWVkLiBJbiB0aGUgY2FzZSBvZiBhIG5hbWVkXG4gICAgLy8gdHVwbGUsIHRoZSB2YWx1ZSB3aWxsIGJlIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRoZSBuYW1lIG9mIHRoZVxuICAgIC8vIGNvbXBvbmVudC4gSW4gdGhlIGNhc2Ugb2YgYW4gdW5uYW1lZCB0dXBsZSwgdGhlIHZhbHVlIHdpbGwgYmUgYW4gYXJyYXkuXG4gICAgY29uc3QgaGFzVW5uYW1lZENoaWxkID0gcGFyYW0uY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgcGFyYW0uY29tcG9uZW50cy5zb21lKCh7IG5hbWUgfSkgPT4gIW5hbWUpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlIHRvIGFuIG9iamVjdCBvciBhbiBhcnJheSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG4gICAgLy8gdHVwbGUgaXMgbmFtZWQgb3IgdW5uYW1lZC5cbiAgICBjb25zdCB2YWx1ZSA9IGhhc1VubmFtZWRDaGlsZCA/IFtdIDoge307XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAvLyBJZiB0aGUgdHVwbGUgaGFzIGEgZHluYW1pYyBjaGlsZCwgd2UgbXVzdCBmaXJzdCBkZWNvZGUgdGhlIG9mZnNldCB0byB0aGVcbiAgICAvLyB0dXBsZSBkYXRhLlxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgdHVwbGUgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiByZWZlcmVuY2luZyBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBjb25zdW1lZCk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlW2hhc1VubmFtZWRDaGlsZCA/IGkgOiBjb21wb25lbnQ/Lm5hbWVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSB0dXBsZSBoYXMgc3RhdGljIGNoaWxkcmVuLCB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBjb21wb25lbnRcbiAgICAvLyBpbiBzZXF1ZW5jZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICAvLyBHZXQgb2Zmc2V0IHRvIHN0YXJ0IG9mIHN0cmluZyBkYXRhLlxuICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEgKGVtcHR5IHN0cmluZykuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbJycsIDMyXTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoLCAzMik7XG4gICAgY29uc3QgdmFsdWUgPSBCeXRlcy50b1N0cmluZyhCeXRlcy50cmltTGVmdChkYXRhKSk7XG4gICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVycyh7IGNoZWNrc3VtQWRkcmVzcywgcGFyYW1ldGVycywgdmFsdWVzLCB9KSB7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXJzW2ldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbWV0ZXJzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXIoeyBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSwgcGFyYW1ldGVyOiBwYXJhbWV0ZXJfLCB2YWx1ZSwgfSkge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcl87XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtZXRlci50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZW5jb2RlQXJyYXkodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVHVwbGUodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUFkZHJlc3ModmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQm9vbGVhbih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50Jyk7XG4gICAgICAgIGNvbnN0IFssICwgc2l6ZSA9ICcyNTYnXSA9IGludGVnZXJSZWdleC5leGVjKHBhcmFtZXRlci50eXBlKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyKHNpemUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGU6IHBhcmFtZXRlci50eXBlIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtZXRlci50eXBlKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKSB7XG4gICAgLy8gMS4gQ29tcHV0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RhdGljIHBhcnQgb2YgdGhlIHBhcmFtZXRlcnMuXG4gICAgbGV0IHN0YXRpY1NpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gSGV4LnNpemUoZW5jb2RlZCk7XG4gICAgfVxuICAgIC8vIDIuIFNwbGl0IHRoZSBwYXJhbWV0ZXJzIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhcnRzLlxuICAgIGNvbnN0IHN0YXRpY1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljUGFyYW1ldGVycyA9IFtdO1xuICAgIGxldCBkeW5hbWljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goSGV4LmZyb21OdW1iZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplLCB7IHNpemU6IDMyIH0pKTtcbiAgICAgICAgICAgIGR5bmFtaWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XG4gICAgICAgICAgICBkeW5hbWljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAzLiBDb25jYXRlbmF0ZSBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMuXG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uc3RhdGljUGFyYW1ldGVycywgLi4uZHluYW1pY1BhcmFtZXRlcnMpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFkZHJlc3ModmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgQWRkcmVzcy5hc3NlcnQodmFsdWUsIHsgc3RyaWN0OiBjaGVja3N1bSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LnBhZExlZnQodmFsdWUudG9Mb3dlckNhc2UoKSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkeW5hbWljID0gbGVuZ3RoID09PSBudWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yKHZhbHVlKTtcbiAgICBpZiAoIWR5bmFtaWMgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGU6IGAke3BhcmFtZXRlci50eXBlfVske2xlbmd0aH1dYCxcbiAgICAgICAgfSk7XG4gICAgbGV0IGR5bmFtaWNDaGlsZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgIH1cbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gSGV4LmZyb21OdW1iZXIocHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkOiBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoID4gMCA/IEhleC5jb25jYXQobGVuZ3RoLCBkYXRhKSA6IGxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZClcbiAgICAgICAgICAgIHJldHVybiB7IGR5bmFtaWM6IHRydWUsIGVuY29kZWQ6IGRhdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGUgfSkge1xuICAgIGNvbnN0IFssIHBhcmFtZXRlcnNpemVdID0gdHlwZS5zcGxpdCgnYnl0ZXMnKTtcbiAgICBjb25zdCBieXRlc1NpemUgPSBIZXguc2l6ZSh2YWx1ZSk7XG4gICAgaWYgKCFwYXJhbWV0ZXJzaXplKSB7XG4gICAgICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgbm90IGRpdmlzaWJsZSBieSAzMiBieXRlcywgcGFkIHRoZSBlbmRcbiAgICAgICAgLy8gd2l0aCBlbXB0eSBieXRlcyB0byB0aGUgY2VpbGluZyAzMiBieXRlcy5cbiAgICAgICAgaWYgKGJ5dGVzU2l6ZSAlIDMyICE9PSAwKVxuICAgICAgICAgICAgdmFsdWVfID0gSGV4LnBhZFJpZ2h0KHZhbHVlXywgTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIgLyAzMikgKiAzMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkTGVmdChIZXguZnJvbU51bWJlcihieXRlc1NpemUsIHsgc2l6ZTogMzIgfSkpLCB2YWx1ZV8pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYnl0ZXNTaXplICE9PSBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSwgMTApKVxuICAgICAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUsIDEwKSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogSGV4LnBhZFJpZ2h0KHZhbHVlKSB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJvb2xlYW4gdmFsdWU6IFwiJHt2YWx1ZX1cIiAodHlwZTogJHt0eXBlb2YgdmFsdWV9KS4gRXhwZWN0ZWQ6IFxcYHRydWVcXGAgb3IgXFxgZmFsc2VcXGAuYCk7XG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSkpIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBtYXggPSAybiAqKiAoQmlnSW50KHNpemUpIC0gKHNpZ25lZCA/IDFuIDogMG4pKSAtIDFuO1xuICAgICAgICBjb25zdCBtaW4gPSBzaWduZWQgPyAtbWF4IC0gMW4gOiAwbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1pbjogbWluLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgLyA4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4VmFsdWUgPSBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBNYXRoLmNlaWwoSGV4LnNpemUoaGV4VmFsdWUpIC8gMzIpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goSGV4LnBhZFJpZ2h0KEhleC5zbGljZShoZXhWYWx1ZSwgaSAqIDMyLCAoaSArIDEpICogMzIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoSGV4LnBhZFJpZ2h0KEhleC5mcm9tTnVtYmVyKEhleC5zaXplKGhleFZhbHVlKSwgeyBzaXplOiAzMiB9KSksIC4uLnBhcnRzKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVR1cGxlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW1fID0gcGFyYW1ldGVyLmNvbXBvbmVudHNbaV07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBpIDogcGFyYW1fLm5hbWU7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkUGFyYW0gPSBwcmVwYXJlUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1fLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2luZGV4XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWMsXG4gICAgICAgIGVuY29kZWQ6IGR5bmFtaWNcbiAgICAgICAgICAgID8gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycylcbiAgICAgICAgICAgIDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFsoXFxkKyk/XFxdJC8pO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgID8gLy8gUmV0dXJuIGBudWxsYCBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy5cbiAgICAgICAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0NoaWxkKHBhcmFtKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBwYXJhbTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnW10nKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBwYXJhbS5jb21wb25lbnRzPy5zb21lKGhhc0R5bmFtaWNDaGlsZCk7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMgJiZcbiAgICAgICAgaGFzRHluYW1pY0NoaWxkKHtcbiAgICAgICAgICAgIC4uLnBhcmFtLFxuICAgICAgICAgICAgdHlwZTogYXJyYXlDb21wb25lbnRzWzFdLFxuICAgICAgICB9KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3JDO0FBQ087QUFDUCxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQix3REFBdUI7QUFDekMsdUJBQXVCLDJDQUFVO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLDBEQUEwRCwyQ0FBVTtBQUNwRSxrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVU7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0M7QUFDdkMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQztBQUN4QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYnl0ZXMuanM/ZWQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuLi9CeXRlcy5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2l6ZShieXRlcywgc2l6ZV8pIHtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNpemVPdmVyZmxvd0Vycm9yKHtcbiAgICAgICAgICAgIGdpdmVuU2l6ZTogQnl0ZXMuc2l6ZShieXRlcyksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gQnl0ZXMuc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBCeXRlcy5zaXplKHZhbHVlKSAhPT0gZW5kIC0gc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IGVuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgY2hhckNvZGVNYXAgPSB7XG4gICAgemVybzogNDgsXG4gICAgbmluZTogNTcsXG4gICAgQTogNjUsXG4gICAgRjogNzAsXG4gICAgYTogOTcsXG4gICAgZjogMTAyLFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFyQ29kZVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC56ZXJvICYmIGNoYXIgPD0gY2hhckNvZGVNYXAubmluZSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBjaGFyQ29kZU1hcC56ZXJvO1xuICAgIGlmIChjaGFyID49IGNoYXJDb2RlTWFwLkEgJiYgY2hhciA8PSBjaGFyQ29kZU1hcC5GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChjaGFyQ29kZU1hcC5BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGNoYXJDb2RlTWFwLmEgJiYgY2hhciA8PSBjaGFyQ29kZU1hcC5mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChjaGFyQ29kZU1hcC5hIC0gMTApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciwgc2l6ZSA9IDMyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzaXplID09PSAwKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHNpemUpXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogYnl0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6ICdCeXRlcycsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFkRW5kID0gZGlyID09PSAncmlnaHQnO1xuICAgICAgICBwYWRkZWRCeXRlc1twYWRFbmQgPyBpIDogc2l6ZSAtIGkgLSAxXSA9XG4gICAgICAgICAgICBieXRlc1twYWRFbmQgPyBpIDogYnl0ZXMubGVuZ3RoIC0gaSAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFkZGVkQnl0ZXM7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIgPSAnbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRhdGEgPSB2YWx1ZTtcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nfunction create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nclass NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nclass PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nclass RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPLHlCQUF5Qiw2QkFBNkIsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsUUFBUTtBQUMxQiwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxpREFBZ0I7QUFDOUQsa0JBQWtCLGtCQUFrQjtBQUNwQyw0QkFBNEIsU0FBUyx3Q0FBd0MsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDhDQUE4QyxpREFBZ0I7QUFDckUsa0JBQWtCLGNBQWM7QUFDaEMsMkNBQTJDLE1BQU0sdUNBQXVDLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9jdXJzb3IuanM/ZTE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbmNvbnN0IHN0YXRpY0N1cnNvciA9IHtcbiAgICBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICBkYXRhVmlldzogbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksXG4gICAgcG9zaXRpb246IDAsXG4gICAgcG9zaXRpb25SZWFkQ291bnQ6IG5ldyBNYXAoKSxcbiAgICByZWN1cnNpdmVSZWFkQ291bnQ6IDAsXG4gICAgcmVjdXJzaXZlUmVhZExpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgYXNzZXJ0UmVhZExpbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgPj0gdGhpcy5yZWN1cnNpdmVSZWFkTGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgY291bnQ6IHRoaXMucmVjdXJzaXZlUmVhZENvdW50ICsgMSxcbiAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5yZWN1cnNpdmVSZWFkTGltaXQsXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzLmJ5dGVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuYnl0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uIC0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgZ2V0UmVhZENvdW50KHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uUmVhZENvdW50LmdldChwb3NpdGlvbiB8fCB0aGlzLnBvc2l0aW9uKSB8fCAwO1xuICAgIH0sXG4gICAgaW5jcmVtZW50UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5lZ2F0aXZlT2Zmc2V0RXJyb3IoeyBvZmZzZXQgfSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuICAgIGluc3BlY3RCeXRlKHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGVzKGxlbmd0aCwgcG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyBsZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50OChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MTYocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MjQocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAyKTtcbiAgICAgICAgcmV0dXJuICgodGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pIDw8IDgpICtcbiAgICAgICAgICAgIHRoaXMuZGF0YVZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAyKSk7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDMyKHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBwdXNoQnl0ZShieXRlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBieXRlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSxcbiAgICBwdXNoQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgYnl0ZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuYnl0ZXMuc2V0KGJ5dGVzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBieXRlcy5sZW5ndGg7XG4gICAgfSxcbiAgICBwdXNoVWludDgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSxcbiAgICBwdXNoVWludDE2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDEpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICB9LFxuICAgIHB1c2hVaW50MjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMik7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlID4+IDgpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQ4KHRoaXMucG9zaXRpb24gKyAyLCB2YWx1ZSAmIH40Mjk0OTY3MDQwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAzO1xuICAgIH0sXG4gICAgcHVzaFVpbnQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAzKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgfSxcbiAgICByZWFkQnl0ZSgpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RCeXRlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gc2l6ZSA/PyBsZW5ndGg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50OCgpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50OCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MTYoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDE2KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQyNCgpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MjQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAzO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDMyKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQzMigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCByZW1haW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aCAtIHRoaXMucG9zaXRpb247XG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHJldHVybiAoKSA9PiAodGhpcy5wb3NpdGlvbiA9IG9sZFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIF90b3VjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjdXJzaXZlUmVhZExpbWl0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5nZXRSZWFkQ291bnQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvblJlYWRDb3VudC5zZXQodGhpcy5wb3NpdGlvbiwgY291bnQgKyAxKTtcbiAgICAgICAgaWYgKGNvdW50ID4gMClcbiAgICAgICAgICAgIHRoaXMucmVjdXJzaXZlUmVhZENvdW50Kys7XG4gICAgfSxcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGJ5dGVzLCB7IHJlY3Vyc2l2ZVJlYWRMaW1pdCA9IDhfMTkyIH0gPSB7fSkge1xuICAgIGNvbnN0IGN1cnNvciA9IE9iamVjdC5jcmVhdGUoc3RhdGljQ3Vyc29yKTtcbiAgICBjdXJzb3IuYnl0ZXMgPSBieXRlcztcbiAgICBjdXJzb3IuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICBjdXJzb3IucG9zaXRpb25SZWFkQ291bnQgPSBuZXcgTWFwKCk7XG4gICAgY3Vyc29yLnJlY3Vyc2l2ZVJlYWRMaW1pdCA9IHJlY3Vyc2l2ZVJlYWRMaW1pdDtcbiAgICByZXR1cm4gY3Vyc29yO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIE5lZ2F0aXZlT2Zmc2V0RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCB9KSB7XG4gICAgICAgIHN1cGVyKGBPZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGNhbm5vdCBiZSBuZWdhdGl2ZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5OZWdhdGl2ZU9mZnNldEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBsZW5ndGgsIHBvc2l0aW9uIH0pIHtcbiAgICAgICAgc3VwZXIoYFBvc2l0aW9uIFxcYCR7cG9zaXRpb259XFxgIGlzIG91dCBvZiBib3VuZHMgKFxcYDAgPCBwb3NpdGlvbiA8ICR7bGVuZ3RofVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY291bnQsIGxpbWl0IH0pIHtcbiAgICAgICAgc3VwZXIoYFJlY3Vyc2l2ZSByZWFkIGxpbWl0IG9mIFxcYCR7bGltaXR9XFxgIGV4Y2VlZGVkIChyZWN1cnNpdmUgcmVhZCBjb3VudDogXFxgJHtjb3VudH1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLlJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnNvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/entropy.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/entropy.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extraEntropy: () => (/* binding */ extraEntropy),\n/* harmony export */   setExtraEntropy: () => (/* binding */ setExtraEntropy)\n/* harmony export */ });\nlet extraEntropy = false;\n/** @internal */\nfunction setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n}\n//# sourceMappingURL=entropy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2VudHJvcHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnRyb3B5LmpzPzk0MjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCBleHRyYUVudHJvcHkgPSBmYWxzZTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYUVudHJvcHkoZW50cm9weSkge1xuICAgIGV4dHJhRW50cm9weSA9IGVudHJvcHk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRyb3B5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsZ0RBQU87QUFDbEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUcsSUFBSSwyQkFBMkIsRUFBRSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcz82OTJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB2ZXJzaW9uO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXR0eVByaW50KGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gZW50cmllcy5yZWR1Y2UoKGFjYywgW2tleV0pID0+IE1hdGgubWF4KGFjYywga2V5Lmxlbmd0aCksIDApO1xuICAgIHJldHVybiBlbnRyaWVzXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAgJHtgJHtrZXl9OmAucGFkRW5kKG1heExlbmd0aCArIDEpfSAgJHt2YWx1ZX1gKVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUM7QUFDakM7QUFDTztBQUNQLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLHNEQUFxQjtBQUN2Qyx1QkFBdUIseUNBQVE7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsMERBQTBELHlDQUFRO0FBQ2xFLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQix5Q0FBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFRO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTywrQkFBK0I7QUFDdEMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9oZXguanM/Zjg3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTaXplKGhleCwgc2l6ZV8pIHtcbiAgICBpZiAoSGV4LnNpemUoaGV4KSA+IHNpemVfKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNpemVPdmVyZmxvd0Vycm9yKHtcbiAgICAgICAgICAgIGdpdmVuU2l6ZTogSGV4LnNpemUoaGV4KSxcbiAgICAgICAgICAgIG1heFNpemU6IHNpemVfLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBIZXguc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmXG4gICAgICAgIEhleC5zaXplKHZhbHVlKSAhPT0gZW5kIC0gc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWQoaGV4Xywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGhleF87XG4gICAgY29uc3QgaGV4ID0gaGV4Xy5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCA+IHNpemUgKiAyKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcih7XG4gICAgICAgICAgICBzaXplOiBNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpLFxuICAgICAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6ICdIZXgnLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gYDB4JHtoZXhbZGlyID09PSAncmlnaHQnID8gJ3BhZEVuZCcgOiAncGFkU3RhcnQnXShzaXplICogMiwgJzAnKX1gO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWUucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICBpZiAoZGF0YSA9PT0gJzAnKVxuICAgICAgICByZXR1cm4gJzB4JztcbiAgICBpZiAoZGlyID09PSAncmlnaHQnICYmIGRhdGEubGVuZ3RoICUgMiA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGAweCR7ZGF0YX0wYDtcbiAgICByZXR1cm4gYDB4JHtkYXRhfWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2xydS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9scnUuanM/MzFkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIE1hcCB3aXRoIGEgTFJVIChMZWFzdCByZWNlbnRseSB1c2VkKSBwb2xpY3kuXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX3JlcGxhY2VtZW50X3BvbGljaWVzI0xSVVxuICovXG5leHBvcnQgY2xhc3MgTHJ1TWFwIGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLmdldChrZXkpO1xuICAgICAgICBpZiAoc3VwZXIuaGFzKGtleSkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMubWF4U2l6ZSAmJiB0aGlzLnNpemUgPiB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGZpcnN0S2V5KVxuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1scnUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanM/ZmY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcwLjEuMSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc6492/SignatureErc6492.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   universalSignatureValidatorAbi: () => (/* binding */ universalSignatureValidatorAbi),\n/* harmony export */   universalSignatureValidatorBytecode: () => (/* binding */ universalSignatureValidatorBytecode),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nconst magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nconst universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nconst universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nfunction assert(wrapped) {\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nfunction from(wrapped) {\n    if (typeof wrapped === 'string')\n        return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from('address, bytes, bytes'), wrapped);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nfunction wrap(value) {\n    const { data, signature, to } = value;\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from('address, bytes, bytes'), [\n        to,\n        data,\n        signature,\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nfunction validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nclass InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc6492.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc6492.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ2Q7QUFDTjtBQUN0QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsK0NBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QixLQUFLLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDRCQUE0QixLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQ0FBa0MsMERBQW9CLENBQUMsd0RBQWtCO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxzQkFBc0I7QUFDbEMsV0FBVyxnREFBVSxDQUFDLDBEQUFvQixDQUFDLHdEQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQyxzREFBZ0I7QUFDbEU7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanM/YmRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL2NvcmUvQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbi8qKlxuICogTWFnaWMgYnl0ZXMgdXNlZCB0byBpZGVudGlmeSBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYWdpY0J5dGVzID0gJzB4NjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5Mic7XG4vKipcbiAqIERlcGxveWxlc3MgRVJDLTY0OTIgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBieXRlY29kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlID0gJzB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjEwNjk0MzgwMzgwNjEwNjk0ODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTA1MWU1NjViNjAwMDYxMDAzYzg0ODQ4NDYxMDA0ODU2NWI5MDUwODA2MDAwNTI2MDAxNjAxZmYzNWI2MDAwN2Y2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjEwMDc0ODM2MTA0MGM1NjViMDM2MTAxZTc1NzYwMDA2MDYwODA4NDgwNjAyMDAxOTA1MTgxMDE5MDYxMDA5MjkxOTA2MTA1Nzc1NjViNjA0MDUxOTI5NTUwOTA5MzUwOTE1MDYwMDA5MDYwMDE2MDAxNjBhMDFiMDM4NTE2OTA2MTAwYjY5MDg1OTA2MTA1ZGQ1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg2NWFmMTkxNTA1MDNkODA2MDAwODExNDYxMDBmMzU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDBmODU2NWI2MDYwOTE1MDViNTA1MDkwNTA4NzYwMDE2MDAxNjBhMDFiMDMxNjNiNjAwMDAzNjEwMTYwNTc4MDYxMDE2MDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDFlNjAyNDgyMDE1MjdmNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyM2EyMDY0NjU3MDZjNmY3OTZkNjU2ZTc0MDAwMDYwNDQ4MjAxNTI2MDY0MDE1YjYwNDA1MTgwOTEwMzkwZmQ1YjYwNDA1MTYzMGIxMzVkM2Y2MGUxMWI4MDgyNTI5MDYwMDE2MDAxNjBhMDFiMDM4YTE2OTA2MzE2MjZiYTdlOTA2MTAxOTA5MDhiOTA4NzkwNjAwNDAxNjEwNWY5NTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTE1ODAxNTYxMDFhZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMWQxOTE5MDYxMDYzMzU2NWI2MDAxNjAwMTYwZTAxYjAzMTkxNjE0OTQ1MDUwNTA1MDUwNjEwNDA1NTY1YjYwMDE2MDAxNjBhMDFiMDM4NDE2M2IxNTYxMDI3YTU3NjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzg2MTY5MDYzMTYyNmJhN2U5MDYxMDIyNzkwODc5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMjQ0NTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAyNjg5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5MDUwNjEwNDA1NTY1YjgxNTE2MDQxMTQ2MTAyZGY1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYTYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNmM2NTZlNjc3NDY4MDAwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MTAyZTc2MTA0MjU1NjViNTA2MDIwODIwMTUxNjA0MDgwODQwMTUxODQ1MTg1OTM5MjYwMDA5MTg1OTE5MDgxMTA2MTAzMGM1NzYxMDMwYzYxMDY1ZDU2NWIwMTYwMjAwMTUxNjBmODFjOTA1MDYwMWI4MTE0ODAxNTkwNjEwMzJiNTc1MDgwNjBmZjE2NjAxYzE0MTU1YjE1NjEwMzhjNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwM2I2MDI0ODIwMTUyNjAwMDgwNTE2MDIwNjEwNjc0ODMzOTgxNTE5MTUyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDc2MjA3NjYxNmM3NTY1MDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTAxNTc1NjViNjA0MDgwNTE2MDAwODE1MjYwMjA4MTAxODA4MzUyODk5MDUyNjBmZjgzMTY5MTgxMDE5MTkwOTE1MjYwNjA4MTAxODQ5MDUyNjA4MDgxMDE4MzkwNTI2MDAxNjAwMTYwYTAxYjAzODkxNjkwNjAwMTkwNjBhMDAxNjAyMDYwNDA1MTYwMjA4MTAzOTA4MDg0MDM5MDg1NWFmYTE1ODAxNTYxMDNlYTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA2MDIwNjA0MDUxMDM1MTYwMDE2MDAxNjBhMDFiMDMxNjE0OTQ1MDUwNTA1MDUwNWI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI1MTEwMTU2MTA0MWQ1NzYwMDA4MGZkNWI1MDgwNTEwMTUxOTA1NjViNjA0MDUxODA2MDYwMDE2MDQwNTI4MDYwMDM5MDYwMjA4MjAyODAzNjgzMzc1MDkxOTI5MTUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzgxMTY4MTE0NjEwNDU4NTc2MDAwODBmZDViNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwNWI4MzgxMTAxNTYxMDQ4YzU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMDQ3NDU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI2MDFmODMwMTEyNjEwNGE2NTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA0YmY1NzYxMDRiZjYxMDQ1YjU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDRlZDU3NjEwNGVkNjEwNDViNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDUwNTU3NjAwMDgwZmQ1YjYxMDUxNjgyNjAyMDgzMDE2MDIwODcwMTYxMDQ3MTU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNTMzNTc2MDAwODBmZDViODM1MTYxMDUzZTgxNjEwNDQzNTY1YjYwMjA4NTAxNTE2MDQwODYwMTUxOTE5NDUwOTI1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1NjE1NzYwMDA4MGZkNWI2MTA1NmQ4NjgyODcwMTYxMDQ5NTU2NWI5MTUwNTA5MjUwOTI1MDkyNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDU4YzU3NjAwMDgwZmQ1YjgzNTE2MTA1OTc4MTYxMDQ0MzU2NWI2MDIwODUwMTUxOTA5MzUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDViMzU3NjAwMDgwZmQ1YjYxMDViZjg2ODI4NzAxNjEwNDk1NTY1YjYwNDA4NjAxNTE5MDkzNTA5MDUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYwMDA4MjUxNjEwNWVmODE4NDYwMjA4NzAxNjEwNDcxNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViODI4MTUyNjA0MDYwMjA4MjAxNTI2MDAwODI1MTgwNjA0MDg0MDE1MjYxMDYxZTgxNjA2MDg1MDE2MDIwODcwMTYxMDQ3MTU2NWI2MDFmMDE2MDFmMTkxNjkxOTA5MTAxNjA2MDAxOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTA2NDU1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MGUwMWIwMzE5ODExNjgxMTQ2MTA0MDU1NzYwMDA4MGZkNWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAzMjYwMDQ1MjYwMjQ2MDAwZmRmZTUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjIzNzI2NTYzNmY3NjY1NzI1MzY5Njc2ZTY1NzInO1xuLyoqXG4gKiBBQkkgZm9yIHRoZSBFUkMtNjQ5MiB1bml2ZXJzYWwgZGVwbG95bGVzcyBzaWduYXR1cmUgdmFsaWRhdG9yIGNvbnRyYWN0LlxuICpcbiAqIENvbnN0cnVjdG9yIHJldHVybiB2YWx1ZSBpcyBgMHgxYCAodmFsaWQpIG9yIGAweDBgIChpbnZhbGlkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfaGFzaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnY29uc3RydWN0b3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2hhc2gnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG5hbWU6ICdpc1ZhbGlkU2lnJyxcbiAgICB9LFxuXTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJ1xuICpcbiAqIFNpZ25hdHVyZUVyYzY0OTIuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcjogVmFsdWUgYDB4ZGVhZGJlZWZgIGlzIGFuIGludmFsaWQgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQod3JhcHBlZCkge1xuICAgIGlmIChIZXguc2xpY2Uod3JhcHBlZCwgLTMyKSAhPT0gbWFnaWNCeXRlcylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3Iod3JhcHBlZCk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MiNzcGVjaWZpY2F0aW9uKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MicgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBzZXJpYWxpemVkIGZvcm1hdC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzY0OTIuZnJvbSgnMHguLi4nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7IGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSwgdG86ICcweC4uLicsIH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweC4uLicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHguLi4nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogeyBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0sIHRvOiAnMHguLi4nLCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHdyYXBwZWQpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdW53cmFwKHdyYXBwZWQpO1xuICAgIHJldHVybiB3cmFwcGVkO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MidcbiAqXG4gKiBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IFNpZ25hdHVyZUVyYzY0OTIudW53cmFwKCcweC4uLicpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAod3JhcHBlZCkge1xuICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICBjb25zdCBbdG8sIGRhdGEsIHNpZ25hdHVyZV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3MsIGJ5dGVzLCBieXRlcycpLCB3cmFwcGVkKTtcbiAgICByZXR1cm4geyBkYXRhLCBzaWduYXR1cmUsIHRvIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6ICcweC4uLicsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLndyYXAoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmU6IFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgU2VyaWFsaXplZCB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IHZhbHVlO1xuICAgIHJldHVybiBIZXguY29uY2F0KEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcywgYnl0ZXMsIGJ5dGVzJyksIFtcbiAgICAgICAgdG8sXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICBdKSwgbWFnaWNCeXRlcyk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHdyYXBwZWQgc2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmVFcmM2NDkyLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUod3JhcHBlZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUgaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZCkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt3cmFwcGVkfVxcYCBpcyBhbiBpbnZhbGlkIEVSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlRXJjNjQ5Mi5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmVFcmM2NDkyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc8010/SignatureErc8010.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   suffixParameters: () => (/* binding */ suffixParameters),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nconst magicBytes = '0x8010801080108010801080108010801080108010801080108010801080108010';\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nconst suffixParameters = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.from('(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data');\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nfunction assert(value) {\n    if (typeof value === 'string') {\n        if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, -32) !== magicBytes)\n            throw new InvalidWrappedSignatureError(value);\n    }\n    else\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nfunction from(value) {\n    if (typeof value === 'string')\n        return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -64, -32));\n    const suffix = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -suffixLength - 64, -64);\n    const signature = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(suffixParameters, suffix);\n    const authorization = _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s,\n    });\n    return {\n        authorization,\n        signature,\n        ...(data && data !== '0x' ? { data, to } : {}),\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nfunction wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress({\n        payload: _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.getSignPayload(value.authorization),\n        signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.from(value.authorization),\n    });\n    const suffix = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId),\n        },\n        value.to ?? self,\n        data ?? '0x',\n    ]);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(suffix), { size: 32 });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nclass InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc8010.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc8010.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDQTtBQUNkO0FBQ047QUFDWTtBQUNBO0FBQ2xEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTyx5QkFBeUIsd0RBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLCtDQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLEtBQUssOEJBQThCLFFBQVE7QUFDMUU7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsaUJBQWlCLEtBQUssOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx5QkFBeUIsa0RBQVksQ0FBQywrQ0FBUztBQUMvQyxtQkFBbUIsK0NBQVM7QUFDNUIsc0JBQXNCLCtDQUFTO0FBQy9CLDZCQUE2QiwwREFBb0I7QUFDakQsMEJBQTBCLHdEQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVcsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQ0FBMkM7QUFDM0Msc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLGlCQUFpQiw4REFBd0I7QUFDekMsaUJBQWlCLGtFQUE0QjtBQUM3QyxtQkFBbUIsb0RBQWM7QUFDakMsS0FBSztBQUNMLG1CQUFtQiwwREFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFjLENBQUMsOENBQVEsWUFBWSxVQUFVO0FBQ3RFLFdBQVcsZ0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLHNEQUFnQjtBQUNsRTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2VyYzgwMTAvU2lnbmF0dXJlRXJjODAxMC5qcz8xODExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi4vY29yZS9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEF1dGhvcml6YXRpb24gZnJvbSAnLi4vY29yZS9BdXRob3JpemF0aW9uLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9jb3JlL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuaW1wb3J0ICogYXMgU2VjcDI1NmsxIGZyb20gJy4uL2NvcmUvU2VjcDI1NmsxLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuLi9jb3JlL1NpZ25hdHVyZS5qcyc7XG4vKipcbiAqIE1hZ2ljIGJ5dGVzIHVzZWQgdG8gaWRlbnRpZnkgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmVzLlxuICovXG5leHBvcnQgY29uc3QgbWFnaWNCeXRlcyA9ICcweDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTAnO1xuLyoqIFN1ZmZpeCBBQkkgcGFyYW1ldGVycyBmb3IgdGhlIEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IHN1ZmZpeFBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oJyh1aW50MjU2IGNoYWluSWQsIGFkZHJlc3MgZGVsZWdhdGlvbiwgdWludDI1NiBub25jZSwgdWludDggeVBhcml0eSwgdWludDI1NiByLCB1aW50MjU2IHMpLCBhZGRyZXNzIHRvLCBieXRlcyBkYXRhJyk7XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBTaWduYXR1cmVFcmM4MDEwLmFzc2VydCgnMHhkZWFkYmVlZicpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3I6IFZhbHVlIGAweGRlYWRiZWVmYCBpcyBhbiBpbnZhbGlkIEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChIZXguc2xpY2UodmFsdWUsIC0zMikgIT09IG1hZ2ljQnl0ZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgU2lnbmF0dXJlLmFzc2VydCh2YWx1ZS5hdXRob3JpemF0aW9uKTtcbn1cbi8qKlxuICogUGFyc2VzIGFuIFtFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9naXRodWIuY29tL2p4b20vRVJDcy9ibG9iLzE2ZjdlMzg5MWZmZjJlMWU5YzI1ZGVhMDQ4NTQ5NzczOWRiOGE4MTYvRVJDUy9lcmMtODAxMC5tZCkgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6ICcweC4uLicsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gc2VyaWFsaXplZCBmb3JtYXQuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM4MDEwLmZyb20oJzB4Li4uJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogeyBhdXRob3JpemF0aW9uOiB7IC4uLiB9LCBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0gfSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBjb25zdGl0dWVudCBwYXJ0cy4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzgwMTAuZnJvbSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYXV0aG9yaXphdGlvbjogeyAuLi4gfSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBkYXRhOiAnMHguLi4nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSlcbiAqIC8vIEBsb2c6IHsgYXV0aG9yaXphdGlvbjogeyAuLi4gfSwgZGF0YTogJzB4Li4uJywgc2lnbmF0dXJlOiB7IC4uLiB9IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIHBhcnNlLlxuICogQHJldHVybnMgUGFyc2VkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdW53cmFwKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFVud3JhcHMgYW4gW0VSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2dpdGh1Yi5jb20vanhvbS9FUkNzL2Jsb2IvMTZmN2UzODkxZmZmMmUxZTljMjVkZWEwNDg1NDk3NzM5ZGI4YTgxNi9FUkNTL2VyYy04MDEwLm1kKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJ1xuICpcbiAqIGNvbnN0IHsgYXV0aG9yaXphdGlvbiwgZGF0YSwgc2lnbmF0dXJlIH0gPSBTaWduYXR1cmVFcmM4MDEwLnVud3JhcCgnMHguLi4nKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZWQgLSBXcmFwcGVkIHNpZ25hdHVyZSB0byB1bndyYXAuXG4gKiBAcmV0dXJucyBVbndyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwKHdyYXBwZWQpIHtcbiAgICBhc3NlcnQod3JhcHBlZCk7XG4gICAgY29uc3Qgc3VmZml4TGVuZ3RoID0gSGV4LnRvTnVtYmVyKEhleC5zbGljZSh3cmFwcGVkLCAtNjQsIC0zMikpO1xuICAgIGNvbnN0IHN1ZmZpeCA9IEhleC5zbGljZSh3cmFwcGVkLCAtc3VmZml4TGVuZ3RoIC0gNjQsIC02NCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gSGV4LnNsaWNlKHdyYXBwZWQsIDAsIC1zdWZmaXhMZW5ndGggLSA2NCk7XG4gICAgY29uc3QgW2F1dGgsIHRvLCBkYXRhXSA9IEFiaVBhcmFtZXRlcnMuZGVjb2RlKHN1ZmZpeFBhcmFtZXRlcnMsIHN1ZmZpeCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gICAgICAgIGFkZHJlc3M6IGF1dGguZGVsZWdhdGlvbixcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGF1dGguY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBhdXRoLm5vbmNlLFxuICAgICAgICB5UGFyaXR5OiBhdXRoLnlQYXJpdHksXG4gICAgICAgIHI6IGF1dGgucixcbiAgICAgICAgczogYXV0aC5zLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcml6YXRpb24sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGRhdGEgJiYgZGF0YSAhPT0gJzB4JyA/IHsgZGF0YSwgdG8gfSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBXcmFwcyBhIHNpZ25hdHVyZSBpbnRvIFtFUkMtODAxMCBmb3JtYXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9qeG9tL0VSQ3MvYmxvYi8xNmY3ZTM4OTFmZmYyZTFlOWMyNWRlYTA0ODU0OTc3MzlkYjhhODE2L0VSQ1MvZXJjLTgwMTAubWQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6ICcweC4uLicsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM4MDEwLndyYXAoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGF1dGhvcml6YXRpb246IHsgLi4uIH0sIC8vIFshY29kZSBmb2N1c11cbiAqICAgZGF0YTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLnRvSGV4KHNpZ25hdHVyZSksIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlcyB0byB3cmFwLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzaWduYXR1cmUgfSA9IHZhbHVlO1xuICAgIGFzc2VydCh2YWx1ZSk7XG4gICAgY29uc3Qgc2VsZiA9IFNlY3AyNTZrMS5yZWNvdmVyQWRkcmVzcyh7XG4gICAgICAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQodmFsdWUuYXV0aG9yaXphdGlvbiksXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20odmFsdWUuYXV0aG9yaXphdGlvbiksXG4gICAgfSk7XG4gICAgY29uc3Qgc3VmZml4ID0gQWJpUGFyYW1ldGVycy5lbmNvZGUoc3VmZml4UGFyYW1ldGVycywgW1xuICAgICAgICB7XG4gICAgICAgICAgICAuLi52YWx1ZS5hdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgZGVsZWdhdGlvbjogdmFsdWUuYXV0aG9yaXphdGlvbi5hZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZDogQmlnSW50KHZhbHVlLmF1dGhvcml6YXRpb24uY2hhaW5JZCksXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLnRvID8/IHNlbGYsXG4gICAgICAgIGRhdGEgPz8gJzB4JyxcbiAgICBdKTtcbiAgICBjb25zdCBzdWZmaXhMZW5ndGggPSBIZXguZnJvbU51bWJlcihIZXguc2l6ZShzdWZmaXgpLCB7IHNpemU6IDMyIH0pO1xuICAgIHJldHVybiBIZXguY29uY2F0KHNpZ25hdHVyZSwgc3VmZml4LCBzdWZmaXhMZW5ndGgsIG1hZ2ljQnl0ZXMpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB3cmFwcGVkIHNpZ25hdHVyZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJ1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRXJjODAxMC52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlIGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWQpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7d3JhcHBlZH1cXGAgaXMgYW4gaW52YWxpZCBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVyYzgwMTAuSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmF0dXJlRXJjODAxMC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/errors.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/version.js\");\n\nclass BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: abitype@${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`,\n        ].join('\\n');\n        super(message);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiTypeError'\n        });\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBQ2hDO0FBQ1AsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFLHVDQUF1QyxRQUFRO0FBQy9DLGdDQUFnQyxnREFBTyxDQUFDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9lcnJvcnMuanM/NzIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCBjbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBhcmdzID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gYXJncy5jYXVzZS5kZXRhaWxzXG4gICAgICAgICAgICA6IGFyZ3MuY2F1c2U/Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IGFyZ3MuY2F1c2UubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogYXJncy5kZXRhaWxzO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gYXJncy5jYXVzZS5kb2NzUGF0aCB8fCBhcmdzLmRvY3NQYXRoXG4gICAgICAgICAgICA6IGFyZ3MuZG9jc1BhdGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIC4uLihhcmdzLm1ldGFNZXNzYWdlcyA/IFsuLi5hcmdzLm1ldGFNZXNzYWdlcywgJyddIDogW10pLFxuICAgICAgICAgICAgLi4uKGRvY3NQYXRoID8gW2BEb2NzOiBodHRwczovL2FiaXR5cGUuZGV2JHtkb2NzUGF0aH1gXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzID8gW2BEZXRhaWxzOiAke2RldGFpbHN9YF0gOiBbXSksXG4gICAgICAgICAgICBgVmVyc2lvbjogYWJpdHlwZUAke3ZlcnNpb259YCxcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YU1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFyZ3MuY2F1c2UpXG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gYXJncy5jYXVzZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5kb2NzUGF0aCA9IGRvY3NQYXRoO1xuICAgICAgICB0aGlzLm1ldGFNZXNzYWdlcyA9IGFyZ3MubWV0YU1lc3NhZ2VzO1xuICAgICAgICB0aGlzLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAbiItemError: () => (/* binding */ InvalidAbiItemError),\n/* harmony export */   UnknownSolidityTypeError: () => (/* binding */ UnknownSolidityTypeError),\n/* harmony export */   UnknownTypeError: () => (/* binding */ UnknownTypeError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidAbiItemError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature }) {\n        super('Failed to parse ABI item.', {\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n            docsPath: '/api/human#parseabiitem-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiItemError'\n        });\n    }\n}\nclass UnknownTypeError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownTypeError'\n        });\n    }\n}\nclass UnknownSolidityTypeError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSolidityTypeError'\n        });\n    }\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL2FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNyQyxrQ0FBa0MsaURBQVM7QUFDbEQsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLCtCQUErQixpREFBUztBQUMvQyxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sdUNBQXVDLGlEQUFTO0FBQ3ZELGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvYWJpSXRlbS5qcz80YjljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5leHBvcnQgY2xhc3MgSW52YWxpZEFiaUl0ZW1FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHBhcnNlIEFCSSBpdGVtLicsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IGBwYXJzZUFiaUl0ZW0oJHtKU09OLnN0cmluZ2lmeShzaWduYXR1cmUsIG51bGwsIDIpfSlgLFxuICAgICAgICAgICAgZG9jc1BhdGg6ICcvYXBpL2h1bWFuI3BhcnNlYWJpaXRlbS0xJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkQWJpSXRlbUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB0eXBlIH0pIHtcbiAgICAgICAgc3VwZXIoJ1Vua25vd24gdHlwZS4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3QgYSB2YWxpZCBBQkkgdHlwZS4gUGVyaGFwcyB5b3UgZm9yZ290IHRvIGluY2x1ZGUgYSBzdHJ1Y3Qgc2lnbmF0dXJlP2AsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1Vua25vd25UeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbmtub3duU29saWRpdHlUeXBlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdHlwZSB9KSB7XG4gICAgICAgIHN1cGVyKCdVbmtub3duIHR5cGUuJywge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYFR5cGUgXCIke3R5cGV9XCIgaXMgbm90IGEgdmFsaWQgQUJJIHR5cGUuYF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVW5rbm93blNvbGlkaXR5VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAbiParameterError: () => (/* binding */ InvalidAbiParameterError),\n/* harmony export */   InvalidAbiParametersError: () => (/* binding */ InvalidAbiParametersError),\n/* harmony export */   InvalidAbiTypeParameterError: () => (/* binding */ InvalidAbiTypeParameterError),\n/* harmony export */   InvalidFunctionModifierError: () => (/* binding */ InvalidFunctionModifierError),\n/* harmony export */   InvalidModifierError: () => (/* binding */ InvalidModifierError),\n/* harmony export */   InvalidParameterError: () => (/* binding */ InvalidParameterError),\n/* harmony export */   SolidityProtectedKeywordError: () => (/* binding */ SolidityProtectedKeywordError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidAbiParameterError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param }) {\n        super('Failed to parse ABI parameter.', {\n            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n            docsPath: '/api/human#parseabiparameter-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParameterError'\n        });\n    }\n}\nclass InvalidAbiParametersError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ params }) {\n        super('Failed to parse ABI parameters.', {\n            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n            docsPath: '/api/human#parseabiparameters-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParametersError'\n        });\n    }\n}\nclass InvalidParameterError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParameterError'\n        });\n    }\n}\nclass SolidityProtectedKeywordError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param, name }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SolidityProtectedKeywordError'\n        });\n    }\n}\nclass InvalidModifierError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidModifierError'\n        });\n    }\n}\nclass InvalidFunctionModifierError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidFunctionModifierError'\n        });\n    }\n}\nclass InvalidAbiTypeParameterError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ abiParameter, }) {\n        super('Invalid ABI parameter.', {\n            details: JSON.stringify(abiParameter, null, 2),\n            metaMessages: ['ABI parameter type is invalid.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiTypeParameterError'\n        });\n    }\n}\n//# sourceMappingURL=abiParameter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL2FiaVBhcmFtZXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QztBQUNyQyx1Q0FBdUMsaURBQVM7QUFDdkQsa0JBQWtCLE9BQU87QUFDekI7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLHdDQUF3QyxpREFBUztBQUN4RCxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sb0NBQW9DLGlEQUFTO0FBQ3BELGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sNENBQTRDLGlEQUFTO0FBQzVELGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLG1DQUFtQyxpREFBUztBQUNuRCxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTLGVBQWUsZUFBZSxLQUFLLGFBQWE7QUFDdEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sMkNBQTJDLGlEQUFTO0FBQzNELGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsZUFBZSxlQUFlLEtBQUssYUFBYTtBQUN0RixpR0FBaUcsU0FBUztBQUMxRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTywyQ0FBMkMsaURBQVM7QUFDM0Qsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvYWJpUGFyYW1ldGVyLmpzPzU4OWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmV4cG9ydCBjbGFzcyBJbnZhbGlkQWJpUGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcGFyYW0gfSkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHBhcnNlIEFCSSBwYXJhbWV0ZXIuJywge1xuICAgICAgICAgICAgZGV0YWlsczogYHBhcnNlQWJpUGFyYW1ldGVyKCR7SlNPTi5zdHJpbmdpZnkocGFyYW0sIG51bGwsIDIpfSlgLFxuICAgICAgICAgICAgZG9jc1BhdGg6ICcvYXBpL2h1bWFuI3BhcnNlYWJpcGFyYW1ldGVyLTEnLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRBYmlQYXJhbWV0ZXJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRBYmlQYXJhbWV0ZXJzRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcGFyYW1zIH0pIHtcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZCB0byBwYXJzZSBBQkkgcGFyYW1ldGVycy4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBgcGFyc2VBYmlQYXJhbWV0ZXJzKCR7SlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCAyKX0pYCxcbiAgICAgICAgICAgIGRvY3NQYXRoOiAnL2FwaS9odW1hbiNwYXJzZWFiaXBhcmFtZXRlcnMtMScsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZEFiaVBhcmFtZXRlcnNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRQYXJhbWV0ZXJFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYXJhbSB9KSB7XG4gICAgICAgIHN1cGVyKCdJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuJywge1xuICAgICAgICAgICAgZGV0YWlsczogcGFyYW0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZFBhcmFtZXRlckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU29saWRpdHlQcm90ZWN0ZWRLZXl3b3JkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcGFyYW0sIG5hbWUgfSkge1xuICAgICAgICBzdXBlcignSW52YWxpZCBBQkkgcGFyYW1ldGVyLicsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IHBhcmFtLFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFwiJHtuYW1lfVwiIGlzIGEgcHJvdGVjdGVkIFNvbGlkaXR5IGtleXdvcmQuIE1vcmUgaW5mbzogaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2NoZWF0c2hlZXQuaHRtbGAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NvbGlkaXR5UHJvdGVjdGVkS2V5d29yZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZE1vZGlmaWVyRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcGFyYW0sIHR5cGUsIG1vZGlmaWVyLCB9KSB7XG4gICAgICAgIHN1cGVyKCdJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuJywge1xuICAgICAgICAgICAgZGV0YWlsczogcGFyYW0sXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgTW9kaWZpZXIgXCIke21vZGlmaWVyfVwiIG5vdCBhbGxvd2VkJHt0eXBlID8gYCBpbiBcIiR7dHlwZX1cIiB0eXBlYCA6ICcnfS5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkTW9kaWZpZXJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRGdW5jdGlvbk1vZGlmaWVyRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcGFyYW0sIHR5cGUsIG1vZGlmaWVyLCB9KSB7XG4gICAgICAgIHN1cGVyKCdJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuJywge1xuICAgICAgICAgICAgZGV0YWlsczogcGFyYW0sXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgTW9kaWZpZXIgXCIke21vZGlmaWVyfVwiIG5vdCBhbGxvd2VkJHt0eXBlID8gYCBpbiBcIiR7dHlwZX1cIiB0eXBlYCA6ICcnfS5gLFxuICAgICAgICAgICAgICAgIGBEYXRhIGxvY2F0aW9uIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBmb3IgYXJyYXksIHN0cnVjdCwgb3IgbWFwcGluZyB0eXBlcywgYnV0IFwiJHttb2RpZmllcn1cIiB3YXMgZ2l2ZW4uYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZEZ1bmN0aW9uTW9kaWZpZXJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRBYmlUeXBlUGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWJpUGFyYW1ldGVyLCB9KSB7XG4gICAgICAgIHN1cGVyKCdJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuJywge1xuICAgICAgICAgICAgZGV0YWlsczogSlNPTi5zdHJpbmdpZnkoYWJpUGFyYW1ldGVyLCBudWxsLCAyKSxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydBQkkgcGFyYW1ldGVyIHR5cGUgaXMgaW52YWxpZC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkQWJpVHlwZVBhcmFtZXRlckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlQYXJhbWV0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidSignatureError: () => (/* binding */ InvalidSignatureError),\n/* harmony export */   InvalidStructSignatureError: () => (/* binding */ InvalidStructSignatureError),\n/* harmony export */   UnknownSignatureError: () => (/* binding */ UnknownSignatureError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidSignatureError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature, type, }) {\n        super(`Invalid ${type} signature.`, {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidSignatureError'\n        });\n    }\n}\nclass UnknownSignatureError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature }) {\n        super('Unknown signature.', {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSignatureError'\n        });\n    }\n}\nclass InvalidStructSignatureError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature }) {\n        super('Invalid struct signature.', {\n            details: signature,\n            metaMessages: ['No properties exist.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidStructSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ3JDLG9DQUFvQyxpREFBUztBQUNwRCxrQkFBa0Isa0JBQWtCO0FBQ3BDLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLG9DQUFvQyxpREFBUztBQUNwRCxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLDBDQUEwQyxpREFBUztBQUMxRCxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zaWduYXR1cmUuanM/ZDJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMuanMnO1xuZXhwb3J0IGNsYXNzIEludmFsaWRTaWduYXR1cmVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgJHt0eXBlfSBzaWduYXR1cmUuYCwge1xuICAgICAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRTaWduYXR1cmVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVua25vd25TaWduYXR1cmVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcignVW5rbm93biBzaWduYXR1cmUuJywge1xuICAgICAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1Vua25vd25TaWduYXR1cmVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRTdHJ1Y3RTaWduYXR1cmVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcignSW52YWxpZCBzdHJ1Y3Qgc2lnbmF0dXJlLicsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydObyBwcm9wZXJ0aWVzIGV4aXN0LiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRTdHJ1Y3RTaWduYXR1cmVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidParenthesisError: () => (/* binding */ InvalidParenthesisError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidParenthesisError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ current, depth }) {\n        super('Unbalanced parentheses.', {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,\n            ],\n            details: `Depth \"${depth}\"`,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParenthesisError'\n        });\n    }\n}\n//# sourceMappingURL=splitParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL3NwbGl0UGFyYW1ldGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUNyQyxzQ0FBc0MsaURBQVM7QUFDdEQsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLGVBQWUsaUJBQWlCLG1DQUFtQztBQUN2RjtBQUNBLCtCQUErQixNQUFNO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL3NwbGl0UGFyYW1ldGVycy5qcz8zMjhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5leHBvcnQgY2xhc3MgSW52YWxpZFBhcmVudGhlc2lzRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY3VycmVudCwgZGVwdGggfSkge1xuICAgICAgICBzdXBlcignVW5iYWxhbmNlZCBwYXJlbnRoZXNlcy4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgXCIke2N1cnJlbnQudHJpbSgpfVwiIGhhcyB0b28gbWFueSAke2RlcHRoID4gMCA/ICdvcGVuaW5nJyA6ICdjbG9zaW5nJ30gcGFyZW50aGVzZXMuYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZXRhaWxzOiBgRGVwdGggXCIke2RlcHRofVwiYCxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkUGFyZW50aGVzaXNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaXRQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircularReferenceError: () => (/* binding */ CircularReferenceError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass CircularReferenceError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ type }) {\n        super('Circular reference detected.', {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'CircularReferenceError'\n        });\n    }\n}\n//# sourceMappingURL=struct.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL3N0cnVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUNyQyxxQ0FBcUMsaURBQVM7QUFDckQsa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zdHJ1Y3QuanM/MmVhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMuanMnO1xuZXhwb3J0IGNsYXNzIENpcmN1bGFyUmVmZXJlbmNlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdHlwZSB9KSB7XG4gICAgICAgIHN1cGVyKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQuJywge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYFN0cnVjdCBcIiR7dHlwZX1cIiBpcyBhIGNpcmN1bGFyIHJlZmVyZW5jZS5gXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDaXJjdWxhclJlZmVyZW5jZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJ1Y3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiItem: () => (/* binding */ formatAbiItem)\n/* harmony export */ });\n/* harmony import */ var _formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatAbiParameters.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nfunction formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs?.length\n            ? ` returns (${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZm9ybWF0QWJpSXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCLGFBQWEsR0FBRyw0RUFBbUIsaUJBQWlCLEdBQUc7QUFDbEYsa0JBQWtCLHdCQUF3QjtBQUMxQyxpQkFBaUIsRUFBRTtBQUNuQiwyQkFBMkIsNEVBQW1CLGtCQUFrQjtBQUNoRSxpQkFBaUI7QUFDakI7QUFDQSx3QkFBd0IsYUFBYSxHQUFHLDRFQUFtQixpQkFBaUI7QUFDNUU7QUFDQSx3QkFBd0IsYUFBYSxHQUFHLDRFQUFtQixpQkFBaUI7QUFDNUU7QUFDQSw4QkFBOEIsNEVBQW1CLGlCQUFpQixHQUFHLHdEQUF3RDtBQUM3SDtBQUNBLHFDQUFxQyx3REFBd0Q7QUFDN0Y7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlJdGVtLmpzP2E5NjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0QWJpUGFyYW1ldGVycywgfSBmcm9tICcuL2Zvcm1hdEFiaVBhcmFtZXRlcnMuanMnO1xuLyoqXG4gKiBGb3JtYXRzIEFCSSBpdGVtIChlLmcuIGVycm9yLCBldmVudCwgZnVuY3Rpb24pIGludG8gaHVtYW4tcmVhZGFibGUgQUJJIGl0ZW1cbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIEFCSSBpdGVtXG4gKiBAcmV0dXJucyBIdW1hbi1yZWFkYWJsZSBBQkkgaXRlbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QWJpSXRlbShhYmlJdGVtKSB7XG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIGBmdW5jdGlvbiAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSAmJiBhYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSAhPT0gJ25vbnBheWFibGUnXG4gICAgICAgICAgICA/IGAgJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eX1gXG4gICAgICAgICAgICA6ICcnfSR7YWJpSXRlbS5vdXRwdXRzPy5sZW5ndGhcbiAgICAgICAgICAgID8gYCByZXR1cm5zICgke2Zvcm1hdEFiaVBhcmFtZXRlcnMoYWJpSXRlbS5vdXRwdXRzKX0pYFxuICAgICAgICAgICAgOiAnJ31gO1xuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgIHJldHVybiBgZXZlbnQgJHthYmlJdGVtLm5hbWV9KCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KWA7XG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgcmV0dXJuIGBlcnJvciAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pYDtcbiAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnY29uc3RydWN0b3InKVxuICAgICAgICByZXR1cm4gYGNvbnN0cnVjdG9yKCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KSR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgPT09ICdwYXlhYmxlJyA/ICcgcGF5YWJsZScgOiAnJ31gO1xuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdmYWxsYmFjaycpXG4gICAgICAgIHJldHVybiBgZmFsbGJhY2soKSBleHRlcm5hbCR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgPT09ICdwYXlhYmxlJyA/ICcgcGF5YWJsZScgOiAnJ31gO1xuICAgIHJldHVybiAncmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0QWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiParameter: () => (/* binding */ formatAbiParameter)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../regex.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nfunction formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(tupleRegex, abiParameter.type);\n        type += `)${result?.array || ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZm9ybWF0QWJpUGFyYW1ldGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0JBQStCO0FBQ3RFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvREFBUztBQUNoQyxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sRUFBRSxrQkFBa0I7QUFDNUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlQYXJhbWV0ZXIuanM/M2ZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjVHlwZWQgfSBmcm9tICcuLi9yZWdleC5qcyc7XG4vLyBodHRwczovL3JlZ2V4ci5jb20vN2Y3cnZcbmNvbnN0IHR1cGxlUmVnZXggPSAvXnR1cGxlKD88YXJyYXk+KFxcWyhcXGQqKVxcXSkqKSQvO1xuLyoqXG4gKiBGb3JtYXRzIHtAbGluayBBYmlQYXJhbWV0ZXJ9IHRvIGh1bWFuLXJlYWRhYmxlIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIGFiaVBhcmFtZXRlciAtIEFCSSBwYXJhbWV0ZXJcbiAqIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIEFCSSBwYXJhbWV0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0QWJpUGFyYW1ldGVyKHsgdHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAnZnJvbScgfSlcbiAqIC8vICAgIF4/IGNvbnN0IHJlc3VsdDogJ2FkZHJlc3MgZnJvbSdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEFiaVBhcmFtZXRlcihhYmlQYXJhbWV0ZXIpIHtcbiAgICBsZXQgdHlwZSA9IGFiaVBhcmFtZXRlci50eXBlO1xuICAgIGlmICh0dXBsZVJlZ2V4LnRlc3QoYWJpUGFyYW1ldGVyLnR5cGUpICYmICdjb21wb25lbnRzJyBpbiBhYmlQYXJhbWV0ZXIpIHtcbiAgICAgICAgdHlwZSA9ICcoJztcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYWJpUGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBhYmlQYXJhbWV0ZXIuY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIHR5cGUgKz0gZm9ybWF0QWJpUGFyYW1ldGVyKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgdHlwZSArPSAnLCAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNUeXBlZCh0dXBsZVJlZ2V4LCBhYmlQYXJhbWV0ZXIudHlwZSk7XG4gICAgICAgIHR5cGUgKz0gYCkke3Jlc3VsdD8uYXJyYXkgfHwgJyd9YDtcbiAgICAgICAgcmV0dXJuIGZvcm1hdEFiaVBhcmFtZXRlcih7XG4gICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWRkIGBpbmRleGVkYCB0byB0eXBlIGlmIGluIGBhYmlQYXJhbWV0ZXJgXG4gICAgaWYgKCdpbmRleGVkJyBpbiBhYmlQYXJhbWV0ZXIgJiYgYWJpUGFyYW1ldGVyLmluZGV4ZWQpXG4gICAgICAgIHR5cGUgPSBgJHt0eXBlfSBpbmRleGVkYDtcbiAgICAvLyBSZXR1cm4gaHVtYW4tcmVhZGFibGUgQUJJIHBhcmFtZXRlclxuICAgIGlmIChhYmlQYXJhbWV0ZXIubmFtZSlcbiAgICAgICAgcmV0dXJuIGAke3R5cGV9ICR7YWJpUGFyYW1ldGVyLm5hbWV9YDtcbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdEFiaVBhcmFtZXRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiParameters: () => (/* binding */ formatAbiParameters)\n/* harmony export */ });\n/* harmony import */ var _formatAbiParameter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatAbiParameter.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\");\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nfunction formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += (0,_formatAbiParameter_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameter)(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZm9ybWF0QWJpUGFyYW1ldGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUM5RDtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQkFBK0I7QUFDdEMsT0FBTyxrQ0FBa0M7QUFDekM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0Esa0JBQWtCLDBFQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaVBhcmFtZXRlcnMuanM/NmYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRBYmlQYXJhbWV0ZXIsIH0gZnJvbSAnLi9mb3JtYXRBYmlQYXJhbWV0ZXIuanMnO1xuLyoqXG4gKiBGb3JtYXRzIHtAbGluayBBYmlQYXJhbWV0ZXJ9cyB0byBodW1hbi1yZWFkYWJsZSBBQkkgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0gYWJpUGFyYW1ldGVycyAtIEFCSSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyBIdW1hbi1yZWFkYWJsZSBBQkkgcGFyYW1ldGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRBYmlQYXJhbWV0ZXJzKFtcbiAqICAgLy8gIF4/IGNvbnN0IHJlc3VsdDogJ2FkZHJlc3MgZnJvbSwgdWludDI1NiB0b2tlbklkJ1xuICogICB7IHR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ2Zyb20nIH0sXG4gKiAgIHsgdHlwZTogJ3VpbnQyNTYnLCBuYW1lOiAndG9rZW5JZCcgfSxcbiAqIF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaVBhcmFtZXRlcnMpIHtcbiAgICBsZXQgcGFyYW1zID0gJyc7XG4gICAgY29uc3QgbGVuZ3RoID0gYWJpUGFyYW1ldGVycy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSBhYmlQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBwYXJhbXMgKz0gZm9ybWF0QWJpUGFyYW1ldGVyKGFiaVBhcmFtZXRlcik7XG4gICAgICAgIGlmIChpICE9PSBsZW5ndGggLSAxKVxuICAgICAgICAgICAgcGFyYW1zICs9ICcsICc7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRBYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAbiItem: () => (/* binding */ parseAbiItem)\n/* harmony export */ });\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors/abiItem.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/signatures.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _runtime_structs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/structs.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\");\n/* harmony import */ var _runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/utils.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nfunction parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === 'string')\n        abiItem = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseSignature)(signature);\n    else {\n        const structs = (0,_runtime_structs_js__WEBPACK_IMPORTED_MODULE_1__.parseStructs)(signature);\n        const length = signature.length;\n        for (let i = 0; i < length; i++) {\n            const signature_ = signature[i];\n            if ((0,_runtime_signatures_js__WEBPACK_IMPORTED_MODULE_2__.isStructSignature)(signature_))\n                continue;\n            abiItem = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseSignature)(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem)\n        throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAbiItemError({ signature });\n    return abiItem;\n}\n//# sourceMappingURL=parseAbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBEO0FBQ0U7QUFDUjtBQUNBO0FBQ3BEO0FBQ0Esc0VBQXNFLFdBQVc7QUFDakY7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsa0JBQWtCLHdCQUF3QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxrQkFBa0IseUJBQXlCO0FBQ3JGO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixpRUFBYztBQUNoQztBQUNBLHdCQUF3QixpRUFBWTtBQUNwQztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0EsZ0JBQWdCLHlFQUFpQjtBQUNqQztBQUNBLHNCQUFzQixpRUFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBbUIsR0FBRyxXQUFXO0FBQ25EO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlJdGVtLmpzPzFhMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW52YWxpZEFiaUl0ZW1FcnJvciB9IGZyb20gJy4vZXJyb3JzL2FiaUl0ZW0uanMnO1xuaW1wb3J0IHsgaXNTdHJ1Y3RTaWduYXR1cmUgfSBmcm9tICcuL3J1bnRpbWUvc2lnbmF0dXJlcy5qcyc7XG5pbXBvcnQgeyBwYXJzZVN0cnVjdHMgfSBmcm9tICcuL3J1bnRpbWUvc3RydWN0cy5qcyc7XG5pbXBvcnQgeyBwYXJzZVNpZ25hdHVyZSB9IGZyb20gJy4vcnVudGltZS91dGlscy5qcyc7XG4vKipcbiAqIFBhcnNlcyBodW1hbi1yZWFkYWJsZSBBQkkgaXRlbSAoZS5nLiBlcnJvciwgZXZlbnQsIGZ1bmN0aW9uKSBpbnRvIHtAbGluayBBYml9IGl0ZW1cbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gSHVtYW4tcmVhZGFibGUgQUJJIGl0ZW1cbiAqIEByZXR1cm5zIFBhcnNlZCB7QGxpbmsgQWJpfSBpdGVtXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFiaUl0ZW0gPSBwYXJzZUFiaUl0ZW0oJ2Z1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzIG93bmVyKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJylcbiAqIC8vICAgIF4/IGNvbnN0IGFiaUl0ZW06IHsgbmFtZTogXCJiYWxhbmNlT2ZcIjsgdHlwZTogXCJmdW5jdGlvblwiOyBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiOy4uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBhYmlJdGVtID0gcGFyc2VBYmlJdGVtKFtcbiAqICAgLy8gIF4/IGNvbnN0IGFiaUl0ZW06IHsgbmFtZTogXCJmb29cIjsgdHlwZTogXCJmdW5jdGlvblwiOyBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiOyBpbnB1dHM6Li4uXG4gKiAgICdmdW5jdGlvbiBmb28oQmF6IGJhcikgdmlldyByZXR1cm5zIChzdHJpbmcpJyxcbiAqICAgJ3N0cnVjdCBCYXogeyBzdHJpbmcgbmFtZTsgfScsXG4gKiBdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBYmlJdGVtKHNpZ25hdHVyZSkge1xuICAgIGxldCBhYmlJdGVtO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlXyA9IHNpZ25hdHVyZVtpXTtcbiAgICAgICAgICAgIGlmIChpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmVfKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGFiaUl0ZW0gPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmVfLCBzdHJ1Y3RzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghYWJpSXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBYmlJdGVtRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgcmV0dXJuIGFiaUl0ZW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAbiParameters: () => (/* binding */ parseAbiParameters)\n/* harmony export */ });\n/* harmony import */ var _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors/abiParameter.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\");\n/* harmony import */ var _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/signatures.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _runtime_structs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/structs.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\");\n/* harmony import */ var _runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/utils.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nfunction parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === 'string') {\n        const parameters = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.splitParameters)(params);\n        const length = parameters.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push((0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseAbiParameter)(parameters[i], { modifiers: _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.modifiers }));\n        }\n    }\n    else {\n        const structs = (0,_runtime_structs_js__WEBPACK_IMPORTED_MODULE_2__.parseStructs)(params);\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            const signature = params[i];\n            if ((0,_runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.isStructSignature)(signature))\n                continue;\n            const parameters = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.splitParameters)(signature);\n            const length = parameters.length;\n            for (let k = 0; k < length; k++) {\n                abiParameters.push((0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseAbiParameter)(parameters[k], { modifiers: _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.modifiers, structs }));\n            }\n        }\n    }\n    if (abiParameters.length === 0)\n        throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAbiParametersError({ params });\n    return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFFO0FBQ0U7QUFDbkI7QUFDQztBQUN3QjtBQUM3RTtBQUNBLDhDQUE4QyxtQkFBbUI7QUFDakU7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQixlQUFlLElBQUksZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlLGVBQWUsZ0JBQWdCO0FBQ2xGO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixrRUFBZTtBQUMxQztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLCtCQUErQixvRUFBa0Isa0JBQWtCLFNBQVMsaUVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFZO0FBQ3BDO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSxnQkFBZ0IseUVBQWlCO0FBQ2pDO0FBQ0EsK0JBQStCLGtFQUFlO0FBQzlDO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMsbUNBQW1DLG9FQUFrQixrQkFBa0IsU0FBUywwRUFBVztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4RUFBeUIsR0FBRyxRQUFRO0FBQ3REO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlQYXJhbWV0ZXJzLmpzPzk4NDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW52YWxpZEFiaVBhcmFtZXRlcnNFcnJvciB9IGZyb20gJy4vZXJyb3JzL2FiaVBhcmFtZXRlci5qcyc7XG5pbXBvcnQgeyBpc1N0cnVjdFNpZ25hdHVyZSwgbW9kaWZpZXJzIH0gZnJvbSAnLi9ydW50aW1lL3NpZ25hdHVyZXMuanMnO1xuaW1wb3J0IHsgcGFyc2VTdHJ1Y3RzIH0gZnJvbSAnLi9ydW50aW1lL3N0cnVjdHMuanMnO1xuaW1wb3J0IHsgc3BsaXRQYXJhbWV0ZXJzIH0gZnJvbSAnLi9ydW50aW1lL3V0aWxzLmpzJztcbmltcG9ydCB7IHBhcnNlQWJpUGFyYW1ldGVyIGFzIHBhcnNlQWJpUGFyYW1ldGVyXyB9IGZyb20gJy4vcnVudGltZS91dGlscy5qcyc7XG4vKipcbiAqIFBhcnNlcyBodW1hbi1yZWFkYWJsZSBBQkkgcGFyYW1ldGVycyBpbnRvIHtAbGluayBBYmlQYXJhbWV0ZXJ9c1xuICpcbiAqIEBwYXJhbSBwYXJhbXMgLSBIdW1hbi1yZWFkYWJsZSBBQkkgcGFyYW1ldGVyc1xuICogQHJldHVybnMgUGFyc2VkIHtAbGluayBBYmlQYXJhbWV0ZXJ9c1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBhYmlQYXJhbWV0ZXJzID0gcGFyc2VBYmlQYXJhbWV0ZXJzKCdhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQyNTYgYW1vdW50JylcbiAqIC8vICAgIF4/IGNvbnN0IGFiaVBhcmFtZXRlcnM6IFt7IHR5cGU6IFwiYWRkcmVzc1wiOyBuYW1lOiBcImZyb21cIjsgfSwgeyB0eXBlOiBcImFkZHJlc3NcIjsuLi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYWJpUGFyYW1ldGVycyA9IHBhcnNlQWJpUGFyYW1ldGVycyhbXG4gKiAgIC8vICBePyBjb25zdCBhYmlQYXJhbWV0ZXJzOiBbeyB0eXBlOiBcInR1cGxlXCI7IGNvbXBvbmVudHM6IFt7IHR5cGU6IFwic3RyaW5nXCI7IG5hbWU6Li4uXG4gKiAgICdCYXogYmFyJyxcbiAqICAgJ3N0cnVjdCBCYXogeyBzdHJpbmcgbmFtZTsgfScsXG4gKiBdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHNwbGl0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJhbWV0ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyXyhwYXJhbWV0ZXJzW2ldLCB7IG1vZGlmaWVycyB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMocGFyYW1zKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgaWYgKGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc3BsaXRQYXJhbWV0ZXJzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJhbWV0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBhYmlQYXJhbWV0ZXJzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXJfKHBhcmFtZXRlcnNba10sIHsgbW9kaWZpZXJzLCBzdHJ1Y3RzIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJpUGFyYW1ldGVycy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWJpUGFyYW1ldGVyc0Vycm9yKHsgcGFyYW1zIH0pO1xuICAgIHJldHVybiBhYmlQYXJhbWV0ZXJzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VBYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getParameterCacheKey: () => (/* binding */ getParameterCacheKey),\n/* harmony export */   parameterCache: () => (/* binding */ parameterCache)\n/* harmony export */ });\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type} and {@link structs}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`) and ensures different struct definitions with the same name are cached separately.\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @param structs Struct definitions to include in cache key\n * @returns Cache key for {@link parameterCache}\n */\nfunction getParameterCacheKey(param, type, structs) {\n    let structKey = '';\n    if (structs)\n        for (const struct of Object.entries(structs)) {\n            if (!struct)\n                continue;\n            let propertyKey = '';\n            for (const property of struct[1]) {\n                propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;\n            }\n            structKey += `(${struct[0]}{${propertyKey}})`;\n        }\n    if (type)\n        return `${type}:${param}${structKey}`;\n    return `${param}${structKey}`;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nconst parameterCache = new Map([\n    // Unnamed\n    ['address', { type: 'address' }],\n    ['bool', { type: 'bool' }],\n    ['bytes', { type: 'bytes' }],\n    ['bytes32', { type: 'bytes32' }],\n    ['int', { type: 'int256' }],\n    ['int256', { type: 'int256' }],\n    ['string', { type: 'string' }],\n    ['uint', { type: 'uint256' }],\n    ['uint8', { type: 'uint8' }],\n    ['uint16', { type: 'uint16' }],\n    ['uint24', { type: 'uint24' }],\n    ['uint32', { type: 'uint32' }],\n    ['uint64', { type: 'uint64' }],\n    ['uint96', { type: 'uint96' }],\n    ['uint112', { type: 'uint112' }],\n    ['uint160', { type: 'uint160' }],\n    ['uint192', { type: 'uint192' }],\n    ['uint256', { type: 'uint256' }],\n    // Named\n    ['address owner', { type: 'address', name: 'owner' }],\n    ['address to', { type: 'address', name: 'to' }],\n    ['bool approved', { type: 'bool', name: 'approved' }],\n    ['bytes _data', { type: 'bytes', name: '_data' }],\n    ['bytes data', { type: 'bytes', name: 'data' }],\n    ['bytes signature', { type: 'bytes', name: 'signature' }],\n    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n    ['bytes32 r', { type: 'bytes32', name: 'r' }],\n    ['bytes32 root', { type: 'bytes32', name: 'root' }],\n    ['bytes32 s', { type: 'bytes32', name: 's' }],\n    ['string name', { type: 'string', name: 'name' }],\n    ['string symbol', { type: 'string', name: 'symbol' }],\n    ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint8 v', { type: 'uint8', name: 'v' }],\n    ['uint256 balance', { type: 'uint256', name: 'balance' }],\n    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint256 value', { type: 'uint256', name: 'value' }],\n    // Indexed\n    [\n        'event:address indexed from',\n        { type: 'address', name: 'from', indexed: true },\n    ],\n    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n    [\n        'event:uint indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n    [\n        'event:uint256 indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n]);\n//# sourceMappingURL=cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsU0FBUyxzQkFBc0IseUJBQXlCLFlBQVksS0FBSyxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyxFQUFFLG9CQUFvQixjQUFjLE9BQU87QUFDNUY7QUFDQSw2QkFBNkIsV0FBVyxFQUFFLGFBQWE7QUFDdkQ7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEdBQUcsTUFBTSxFQUFFLFVBQVU7QUFDNUMsY0FBYyxNQUFNLEVBQUUsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQyxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGVBQWU7QUFDL0Isa0JBQWtCLGlCQUFpQjtBQUNuQyxjQUFjLGdCQUFnQjtBQUM5QixpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixnQkFBZ0I7QUFDakMsZUFBZSxpQkFBaUI7QUFDaEMsZ0JBQWdCLGVBQWU7QUFDL0IsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixnQkFBZ0I7QUFDakMsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCLGlCQUFpQjtBQUNuQyxrQkFBa0IsaUJBQWlCO0FBQ25DLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hELHFCQUFxQiw2QkFBNkI7QUFDbEQsd0JBQXdCLGdDQUFnQztBQUN4RCxzQkFBc0IsOEJBQThCO0FBQ3BELHFCQUFxQiw2QkFBNkI7QUFDbEQsMEJBQTBCLGtDQUFrQztBQUM1RCx1QkFBdUIsK0JBQStCO0FBQ3RELG9CQUFvQiw0QkFBNEI7QUFDaEQsdUJBQXVCLCtCQUErQjtBQUN0RCxvQkFBb0IsNEJBQTRCO0FBQ2hELHNCQUFzQiw4QkFBOEI7QUFDcEQsd0JBQXdCLGdDQUFnQztBQUN4RCwwQkFBMEIsa0NBQWtDO0FBQzVELHVCQUF1QixrQ0FBa0M7QUFDekQsa0JBQWtCLDBCQUEwQjtBQUM1QywwQkFBMEIsa0NBQWtDO0FBQzVELDBCQUEwQixrQ0FBa0M7QUFDNUQsd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUE4QztBQUN4RDtBQUNBLG1DQUFtQyw0Q0FBNEM7QUFDL0U7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9jYWNoZS5qcz8xNTBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0cyB7QGxpbmsgcGFyYW1ldGVyQ2FjaGV9IGNhY2hlIGtleSBuYW1lc3BhY2VkIGJ5IHtAbGluayB0eXBlfSBhbmQge0BsaW5rIHN0cnVjdHN9LiBUaGlzIHByZXZlbnRzIHBhcmFtZXRlcnMgZnJvbSBiZWluZyBhY2Nlc3NpYmxlIHRvIHR5cGVzIHRoYXQgZG9uJ3QgYWxsb3cgdGhlbSAoZS5nLiBgc3RyaW5nIGluZGV4ZWQgZm9vYCBub3QgYWxsb3dlZCBvdXRzaWRlIG9mIGB0eXBlOiAnZXZlbnQnYCkgYW5kIGVuc3VyZXMgZGlmZmVyZW50IHN0cnVjdCBkZWZpbml0aW9ucyB3aXRoIHRoZSBzYW1lIG5hbWUgYXJlIGNhY2hlZCBzZXBhcmF0ZWx5LlxuICogQHBhcmFtIHBhcmFtIEFCSSBwYXJhbWV0ZXIgc3RyaW5nXG4gKiBAcGFyYW0gdHlwZSBBQkkgcGFyYW1ldGVyIHR5cGVcbiAqIEBwYXJhbSBzdHJ1Y3RzIFN0cnVjdCBkZWZpbml0aW9ucyB0byBpbmNsdWRlIGluIGNhY2hlIGtleVxuICogQHJldHVybnMgQ2FjaGUga2V5IGZvciB7QGxpbmsgcGFyYW1ldGVyQ2FjaGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJDYWNoZUtleShwYXJhbSwgdHlwZSwgc3RydWN0cykge1xuICAgIGxldCBzdHJ1Y3RLZXkgPSAnJztcbiAgICBpZiAoc3RydWN0cylcbiAgICAgICAgZm9yIChjb25zdCBzdHJ1Y3Qgb2YgT2JqZWN0LmVudHJpZXMoc3RydWN0cykpIHtcbiAgICAgICAgICAgIGlmICghc3RydWN0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5S2V5ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHN0cnVjdFsxXSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ICs9IGBbJHtwcm9wZXJ0eS50eXBlfSR7cHJvcGVydHkubmFtZSA/IGA6JHtwcm9wZXJ0eS5uYW1lfWAgOiAnJ31dYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cnVjdEtleSArPSBgKCR7c3RydWN0WzBdfXske3Byb3BlcnR5S2V5fX0pYDtcbiAgICAgICAgfVxuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gYCR7dHlwZX06JHtwYXJhbX0ke3N0cnVjdEtleX1gO1xuICAgIHJldHVybiBgJHtwYXJhbX0ke3N0cnVjdEtleX1gO1xufVxuLyoqXG4gKiBCYXNpYyBjYWNoZSBzZWVkZWQgd2l0aCBjb21tb24gQUJJIHBhcmFtZXRlciBzdHJpbmdzLlxuICpcbiAqICoqTm90ZTogV2hlbiBzZWVkaW5nIG1vcmUgcGFyYW1ldGVycywgbWFrZSBzdXJlIHlvdSBiZW5jaG1hcmsgcGVyZm9ybWFuY2UuIFRoZSBjdXJyZW50IG51bWJlciBpcyB0aGUgaWRlYWwgYmFsYW5jZSBiZXR3ZWVuIHBlcmZvcm1hbmNlIGFuZCBoYXZpbmcgYW4gYWxyZWFkeSBleGlzdGluZyBjYWNoZS4qKlxuICovXG5leHBvcnQgY29uc3QgcGFyYW1ldGVyQ2FjaGUgPSBuZXcgTWFwKFtcbiAgICAvLyBVbm5hbWVkXG4gICAgWydhZGRyZXNzJywgeyB0eXBlOiAnYWRkcmVzcycgfV0sXG4gICAgWydib29sJywgeyB0eXBlOiAnYm9vbCcgfV0sXG4gICAgWydieXRlcycsIHsgdHlwZTogJ2J5dGVzJyB9XSxcbiAgICBbJ2J5dGVzMzInLCB7IHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBbJ2ludCcsIHsgdHlwZTogJ2ludDI1NicgfV0sXG4gICAgWydpbnQyNTYnLCB7IHR5cGU6ICdpbnQyNTYnIH1dLFxuICAgIFsnc3RyaW5nJywgeyB0eXBlOiAnc3RyaW5nJyB9XSxcbiAgICBbJ3VpbnQnLCB7IHR5cGU6ICd1aW50MjU2JyB9XSxcbiAgICBbJ3VpbnQ4JywgeyB0eXBlOiAndWludDgnIH1dLFxuICAgIFsndWludDE2JywgeyB0eXBlOiAndWludDE2JyB9XSxcbiAgICBbJ3VpbnQyNCcsIHsgdHlwZTogJ3VpbnQyNCcgfV0sXG4gICAgWyd1aW50MzInLCB7IHR5cGU6ICd1aW50MzInIH1dLFxuICAgIFsndWludDY0JywgeyB0eXBlOiAndWludDY0JyB9XSxcbiAgICBbJ3VpbnQ5NicsIHsgdHlwZTogJ3VpbnQ5NicgfV0sXG4gICAgWyd1aW50MTEyJywgeyB0eXBlOiAndWludDExMicgfV0sXG4gICAgWyd1aW50MTYwJywgeyB0eXBlOiAndWludDE2MCcgfV0sXG4gICAgWyd1aW50MTkyJywgeyB0eXBlOiAndWludDE5MicgfV0sXG4gICAgWyd1aW50MjU2JywgeyB0eXBlOiAndWludDI1NicgfV0sXG4gICAgLy8gTmFtZWRcbiAgICBbJ2FkZHJlc3Mgb3duZXInLCB7IHR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ293bmVyJyB9XSxcbiAgICBbJ2FkZHJlc3MgdG8nLCB7IHR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ3RvJyB9XSxcbiAgICBbJ2Jvb2wgYXBwcm92ZWQnLCB7IHR5cGU6ICdib29sJywgbmFtZTogJ2FwcHJvdmVkJyB9XSxcbiAgICBbJ2J5dGVzIF9kYXRhJywgeyB0eXBlOiAnYnl0ZXMnLCBuYW1lOiAnX2RhdGEnIH1dLFxuICAgIFsnYnl0ZXMgZGF0YScsIHsgdHlwZTogJ2J5dGVzJywgbmFtZTogJ2RhdGEnIH1dLFxuICAgIFsnYnl0ZXMgc2lnbmF0dXJlJywgeyB0eXBlOiAnYnl0ZXMnLCBuYW1lOiAnc2lnbmF0dXJlJyB9XSxcbiAgICBbJ2J5dGVzMzIgaGFzaCcsIHsgdHlwZTogJ2J5dGVzMzInLCBuYW1lOiAnaGFzaCcgfV0sXG4gICAgWydieXRlczMyIHInLCB7IHR5cGU6ICdieXRlczMyJywgbmFtZTogJ3InIH1dLFxuICAgIFsnYnl0ZXMzMiByb290JywgeyB0eXBlOiAnYnl0ZXMzMicsIG5hbWU6ICdyb290JyB9XSxcbiAgICBbJ2J5dGVzMzIgcycsIHsgdHlwZTogJ2J5dGVzMzInLCBuYW1lOiAncycgfV0sXG4gICAgWydzdHJpbmcgbmFtZScsIHsgdHlwZTogJ3N0cmluZycsIG5hbWU6ICduYW1lJyB9XSxcbiAgICBbJ3N0cmluZyBzeW1ib2wnLCB7IHR5cGU6ICdzdHJpbmcnLCBuYW1lOiAnc3ltYm9sJyB9XSxcbiAgICBbJ3N0cmluZyB0b2tlblVSSScsIHsgdHlwZTogJ3N0cmluZycsIG5hbWU6ICd0b2tlblVSSScgfV0sXG4gICAgWyd1aW50IHRva2VuSWQnLCB7IHR5cGU6ICd1aW50MjU2JywgbmFtZTogJ3Rva2VuSWQnIH1dLFxuICAgIFsndWludDggdicsIHsgdHlwZTogJ3VpbnQ4JywgbmFtZTogJ3YnIH1dLFxuICAgIFsndWludDI1NiBiYWxhbmNlJywgeyB0eXBlOiAndWludDI1NicsIG5hbWU6ICdiYWxhbmNlJyB9XSxcbiAgICBbJ3VpbnQyNTYgdG9rZW5JZCcsIHsgdHlwZTogJ3VpbnQyNTYnLCBuYW1lOiAndG9rZW5JZCcgfV0sXG4gICAgWyd1aW50MjU2IHZhbHVlJywgeyB0eXBlOiAndWludDI1NicsIG5hbWU6ICd2YWx1ZScgfV0sXG4gICAgLy8gSW5kZXhlZFxuICAgIFtcbiAgICAgICAgJ2V2ZW50OmFkZHJlc3MgaW5kZXhlZCBmcm9tJyxcbiAgICAgICAgeyB0eXBlOiAnYWRkcmVzcycsIG5hbWU6ICdmcm9tJywgaW5kZXhlZDogdHJ1ZSB9LFxuICAgIF0sXG4gICAgWydldmVudDphZGRyZXNzIGluZGV4ZWQgdG8nLCB7IHR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ3RvJywgaW5kZXhlZDogdHJ1ZSB9XSxcbiAgICBbXG4gICAgICAgICdldmVudDp1aW50IGluZGV4ZWQgdG9rZW5JZCcsXG4gICAgICAgIHsgdHlwZTogJ3VpbnQyNTYnLCBuYW1lOiAndG9rZW5JZCcsIGluZGV4ZWQ6IHRydWUgfSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgJ2V2ZW50OnVpbnQyNTYgaW5kZXhlZCB0b2tlbklkJyxcbiAgICAgICAgeyB0eXBlOiAndWludDI1NicsIG5hbWU6ICd0b2tlbklkJywgaW5kZXhlZDogdHJ1ZSB9LFxuICAgIF0sXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventModifiers: () => (/* binding */ eventModifiers),\n/* harmony export */   execConstructorSignature: () => (/* binding */ execConstructorSignature),\n/* harmony export */   execErrorSignature: () => (/* binding */ execErrorSignature),\n/* harmony export */   execEventSignature: () => (/* binding */ execEventSignature),\n/* harmony export */   execFallbackSignature: () => (/* binding */ execFallbackSignature),\n/* harmony export */   execFunctionSignature: () => (/* binding */ execFunctionSignature),\n/* harmony export */   execStructSignature: () => (/* binding */ execStructSignature),\n/* harmony export */   functionModifiers: () => (/* binding */ functionModifiers),\n/* harmony export */   isConstructorSignature: () => (/* binding */ isConstructorSignature),\n/* harmony export */   isErrorSignature: () => (/* binding */ isErrorSignature),\n/* harmony export */   isEventSignature: () => (/* binding */ isEventSignature),\n/* harmony export */   isFallbackSignature: () => (/* binding */ isFallbackSignature),\n/* harmony export */   isFunctionSignature: () => (/* binding */ isFunctionSignature),\n/* harmony export */   isReceiveSignature: () => (/* binding */ isReceiveSignature),\n/* harmony export */   isStructSignature: () => (/* binding */ isStructSignature),\n/* harmony export */   modifiers: () => (/* binding */ modifiers)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../regex.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(errorSignatureRegex, signature);\n}\n// https://regexr.com/7gmoq\nconst eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(eventSignatureRegex, signature);\n}\n// https://regexr.com/7gmot\nconst functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(functionSignatureRegex, signature);\n}\n// https://regexr.com/7gmp3\nconst structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(structSignatureRegex, signature);\n}\n// https://regexr.com/78u01\nconst constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(constructorSignatureRegex, signature);\n}\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex = /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\nfunction execFallbackSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(fallbackSignatureRegex, signature);\n}\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nconst modifiers = new Set([\n    'memory',\n    'indexed',\n    'storage',\n    'calldata',\n]);\nconst eventModifiers = new Set(['indexed']);\nconst functionModifiers = new Set([\n    'calldata',\n    'memory',\n    'storage',\n]);\n//# sourceMappingURL=signatures.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9zaWduYXR1cmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQzNDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsb0RBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCxXQUFXLG9EQUFTO0FBQ3BCO0FBQ0E7QUFDQSw4SEFBOEgsRUFBRSx1REFBdUQsRUFBRTtBQUNsTDtBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsb0RBQVM7QUFDcEI7QUFDQTtBQUNBLDBFQUEwRSxvQkFBb0I7QUFDdkY7QUFDUDtBQUNBO0FBQ087QUFDUCxXQUFXLG9EQUFTO0FBQ3BCO0FBQ0E7QUFDQSxxR0FBcUcsRUFBRTtBQUNoRztBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsb0RBQVM7QUFDcEI7QUFDQTtBQUNBLHNGQUFzRixFQUFFO0FBQ2pGO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyxvREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9zaWduYXR1cmVzLmpzP2Q3ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlY1R5cGVkIH0gZnJvbSAnLi4vLi4vcmVnZXguanMnO1xuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzdnbW9rXG5jb25zdCBlcnJvclNpZ25hdHVyZVJlZ2V4ID0gL15lcnJvciAoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKilcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkkLztcbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBlcnJvclNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGVjRXJyb3JTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGV4ZWNUeXBlZChlcnJvclNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzdnbW9xXG5jb25zdCBldmVudFNpZ25hdHVyZVJlZ2V4ID0gL15ldmVudCAoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKilcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkkLztcbmV4cG9ydCBmdW5jdGlvbiBpc0V2ZW50U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBldmVudFNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGVjRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGV4ZWNUeXBlZChldmVudFNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzdnbW90XG5jb25zdCBmdW5jdGlvblNpZ25hdHVyZVJlZ2V4ID0gL15mdW5jdGlvbiAoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKilcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkoPzogKD88c2NvcGU+ZXh0ZXJuYWx8cHVibGljezF9KSk/KD86ICg/PHN0YXRlTXV0YWJpbGl0eT5wdXJlfHZpZXd8bm9ucGF5YWJsZXxwYXlhYmxlezF9KSk/KD86IHJldHVybnNcXHM/XFwoKD88cmV0dXJucz4uKj8pXFwpKT8kLztcbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmdW5jdGlvblNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGVjRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGV4ZWNUeXBlZChmdW5jdGlvblNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzdnbXAzXG5jb25zdCBzdHJ1Y3RTaWduYXR1cmVSZWdleCA9IC9ec3RydWN0ICg/PG5hbWU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKSBcXHsoPzxwcm9wZXJ0aWVzPi4qPylcXH0kLztcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gc3RydWN0U2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGV4ZWNUeXBlZChzdHJ1Y3RTaWduYXR1cmVSZWdleCwgc2lnbmF0dXJlKTtcbn1cbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS83OHUwMVxuY29uc3QgY29uc3RydWN0b3JTaWduYXR1cmVSZWdleCA9IC9eY29uc3RydWN0b3JcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkoPzpcXHMoPzxzdGF0ZU11dGFiaWxpdHk+cGF5YWJsZXsxfSkpPyQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZXhlY1R5cGVkKGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XG59XG4vLyBodHRwczovL3JlZ2V4ci5jb20vN3NydG5cbmNvbnN0IGZhbGxiYWNrU2lnbmF0dXJlUmVnZXggPSAvXmZhbGxiYWNrXFwoXFwpIGV4dGVybmFsKD86XFxzKD88c3RhdGVNdXRhYmlsaXR5PnBheWFibGV7MX0pKT8kLztcbmV4cG9ydCBmdW5jdGlvbiBpc0ZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmYWxsYmFja1NpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGVjRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGV4ZWNUeXBlZChmYWxsYmFja1NpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzc4dTFrXG5jb25zdCByZWNlaXZlU2lnbmF0dXJlUmVnZXggPSAvXnJlY2VpdmVcXChcXCkgZXh0ZXJuYWwgcGF5YWJsZSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVjZWl2ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjZWl2ZVNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmV4cG9ydCBjb25zdCBtb2RpZmllcnMgPSBuZXcgU2V0KFtcbiAgICAnbWVtb3J5JyxcbiAgICAnaW5kZXhlZCcsXG4gICAgJ3N0b3JhZ2UnLFxuICAgICdjYWxsZGF0YScsXG5dKTtcbmV4cG9ydCBjb25zdCBldmVudE1vZGlmaWVycyA9IG5ldyBTZXQoWydpbmRleGVkJ10pO1xuZXhwb3J0IGNvbnN0IGZ1bmN0aW9uTW9kaWZpZXJzID0gbmV3IFNldChbXG4gICAgJ2NhbGxkYXRhJyxcbiAgICAnbWVtb3J5JyxcbiAgICAnc3RvcmFnZScsXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseStructs: () => (/* binding */ parseStructs)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../regex.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/abiItem.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors/abiParameter.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\");\n/* harmony import */ var _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/signature.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js\");\n/* harmony import */ var _errors_struct_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/struct.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js\");\n/* harmony import */ var _signatures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signatures.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n\n\n\nfunction parseStructs(signatures) {\n    // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for (let i = 0; i < signaturesLength; i++) {\n        const signature = signatures[i];\n        if (!(0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isStructSignature)(signature))\n            continue;\n        const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execStructSignature)(signature);\n        if (!match)\n            throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'struct' });\n        const properties = match.properties.split(';');\n        const components = [];\n        const propertiesLength = properties.length;\n        for (let k = 0; k < propertiesLength; k++) {\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed)\n                continue;\n            const abiParameter = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseAbiParameter)(trimmed, {\n                type: 'struct',\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length)\n            throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidStructSignatureError({ signature });\n        shallowStructs[match.name] = components;\n    }\n    // Resolve nested structs inside each parameter\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for (let i = 0; i < entriesLength; i++) {\n        const [name, parameters] = entries[i];\n        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters = [], structs = {}, ancestors = new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        const isTuple = _regex_js__WEBPACK_IMPORTED_MODULE_3__.isTupleRegex.test(abiParameter.type);\n        if (isTuple)\n            components.push(abiParameter);\n        else {\n            const match = (0,_regex_js__WEBPACK_IMPORTED_MODULE_3__.execTyped)(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type)\n                throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidAbiTypeParameterError({ abiParameter });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type))\n                    throw new _errors_struct_js__WEBPACK_IMPORTED_MODULE_5__.CircularReferenceError({ type });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? ''}`,\n                    components: resolveStructs(structs[type], structs, new Set([...ancestors, type])),\n                });\n            }\n            else {\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isSolidityType)(type))\n                    components.push(abiParameter);\n                else\n                    throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_6__.UnknownTypeError({ type });\n            }\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=structs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9zdHJ1Y3RzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0Q7QUFDaUI7QUFDb0I7QUFDaEM7QUFDWTtBQUNWO0FBQ3hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLGFBQWEsaUVBQWlCO0FBQzlCO0FBQ0Esc0JBQXNCLG1FQUFtQjtBQUN6QztBQUNBLHNCQUFzQix1RUFBcUIsR0FBRywyQkFBMkI7QUFDekUsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDREQUFpQjtBQUNsRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkVBQTJCLEdBQUcsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSx3QkFBd0IsbURBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFTO0FBQ25DO0FBQ0EsMEJBQTBCLGlGQUE0QixHQUFHLGNBQWM7QUFDdkUsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLDhCQUE4QixxRUFBc0IsR0FBRyxNQUFNO0FBQzdEO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFjO0FBQ2xDO0FBQ0E7QUFDQSw4QkFBOEIsZ0VBQWdCLEdBQUcsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvc3RydWN0cy5qcz8xNDc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWNUeXBlZCwgaXNUdXBsZVJlZ2V4IH0gZnJvbSAnLi4vLi4vcmVnZXguanMnO1xuaW1wb3J0IHsgVW5rbm93blR5cGVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9hYmlJdGVtLmpzJztcbmltcG9ydCB7IEludmFsaWRBYmlUeXBlUGFyYW1ldGVyRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvYWJpUGFyYW1ldGVyLmpzJztcbmltcG9ydCB7IEludmFsaWRTaWduYXR1cmVFcnJvciwgSW52YWxpZFN0cnVjdFNpZ25hdHVyZUVycm9yLCB9IGZyb20gJy4uL2Vycm9ycy9zaWduYXR1cmUuanMnO1xuaW1wb3J0IHsgQ2lyY3VsYXJSZWZlcmVuY2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9zdHJ1Y3QuanMnO1xuaW1wb3J0IHsgZXhlY1N0cnVjdFNpZ25hdHVyZSwgaXNTdHJ1Y3RTaWduYXR1cmUgfSBmcm9tICcuL3NpZ25hdHVyZXMuanMnO1xuaW1wb3J0IHsgaXNTb2xpZGl0eVR5cGUsIHBhcnNlQWJpUGFyYW1ldGVyIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdHJ1Y3RzKHNpZ25hdHVyZXMpIHtcbiAgICAvLyBDcmVhdGUgXCJzaGFsbG93XCIgdmVyc2lvbiBvZiBlYWNoIHN0cnVjdCAoYW5kIGZpbHRlciBvdXQgbm9uLXN0cnVjdHMgb3IgaW52YWxpZCBzdHJ1Y3RzKVxuICAgIGNvbnN0IHNoYWxsb3dTdHJ1Y3RzID0ge307XG4gICAgY29uc3Qgc2lnbmF0dXJlc0xlbmd0aCA9IHNpZ25hdHVyZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25hdHVyZXNbaV07XG4gICAgICAgIGlmICghaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGV4ZWNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUsIHR5cGU6ICdzdHJ1Y3QnIH0pO1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWF0Y2gucHJvcGVydGllcy5zcGxpdCgnOycpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXNMZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBwcm9wZXJ0aWVzTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydGllc1trXTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBwcm9wZXJ0eS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRyaW1tZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSBwYXJzZUFiaVBhcmFtZXRlcih0cmltbWVkLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cnVjdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChhYmlQYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0cnVjdFNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgICAgICBzaGFsbG93U3RydWN0c1ttYXRjaC5uYW1lXSA9IGNvbXBvbmVudHM7XG4gICAgfVxuICAgIC8vIFJlc29sdmUgbmVzdGVkIHN0cnVjdHMgaW5zaWRlIGVhY2ggcGFyYW1ldGVyXG4gICAgY29uc3QgcmVzb2x2ZWRTdHJ1Y3RzID0ge307XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNoYWxsb3dTdHJ1Y3RzKTtcbiAgICBjb25zdCBlbnRyaWVzTGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgW25hbWUsIHBhcmFtZXRlcnNdID0gZW50cmllc1tpXTtcbiAgICAgICAgcmVzb2x2ZWRTdHJ1Y3RzW25hbWVdID0gcmVzb2x2ZVN0cnVjdHMocGFyYW1ldGVycywgc2hhbGxvd1N0cnVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRTdHJ1Y3RzO1xufVxuY29uc3QgdHlwZVdpdGhvdXRUdXBsZVJlZ2V4ID0gL14oPzx0eXBlPlthLXpBLVokX11bYS16QS1aMC05JF9dKikoPzxhcnJheT4oPzpcXFtcXGQqP1xcXSkrPyk/JC87XG5mdW5jdGlvbiByZXNvbHZlU3RydWN0cyhhYmlQYXJhbWV0ZXJzID0gW10sIHN0cnVjdHMgPSB7fSwgYW5jZXN0b3JzID0gbmV3IFNldCgpKSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFiaVBhcmFtZXRlcnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gYWJpUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgY29uc3QgaXNUdXBsZSA9IGlzVHVwbGVSZWdleC50ZXN0KGFiaVBhcmFtZXRlci50eXBlKTtcbiAgICAgICAgaWYgKGlzVHVwbGUpXG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2goYWJpUGFyYW1ldGVyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGV4ZWNUeXBlZCh0eXBlV2l0aG91dFR1cGxlUmVnZXgsIGFiaVBhcmFtZXRlci50eXBlKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2g/LnR5cGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBYmlUeXBlUGFyYW1ldGVyRXJyb3IoeyBhYmlQYXJhbWV0ZXIgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGFycmF5LCB0eXBlIH0gPSBtYXRjaDtcbiAgICAgICAgICAgIGlmICh0eXBlIGluIHN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyh0eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENpcmN1bGFyUmVmZXJlbmNlRXJyb3IoeyB0eXBlIH0pO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYHR1cGxlJHthcnJheSA/PyAnJ31gLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiByZXNvbHZlU3RydWN0cyhzdHJ1Y3RzW3R5cGVdLCBzdHJ1Y3RzLCBuZXcgU2V0KFsuLi5hbmNlc3RvcnMsIHR5cGVdKSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTb2xpZGl0eVR5cGUodHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChhYmlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVua25vd25UeXBlRXJyb3IoeyB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RydWN0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSolidityKeyword: () => (/* binding */ isSolidityKeyword),\n/* harmony export */   isSolidityType: () => (/* binding */ isSolidityType),\n/* harmony export */   isValidDataLocation: () => (/* binding */ isValidDataLocation),\n/* harmony export */   parseAbiParameter: () => (/* binding */ parseAbiParameter),\n/* harmony export */   parseConstructorSignature: () => (/* binding */ parseConstructorSignature),\n/* harmony export */   parseErrorSignature: () => (/* binding */ parseErrorSignature),\n/* harmony export */   parseEventSignature: () => (/* binding */ parseEventSignature),\n/* harmony export */   parseFallbackSignature: () => (/* binding */ parseFallbackSignature),\n/* harmony export */   parseFunctionSignature: () => (/* binding */ parseFunctionSignature),\n/* harmony export */   parseSignature: () => (/* binding */ parseSignature),\n/* harmony export */   splitParameters: () => (/* binding */ splitParameters)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../regex.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/abiItem.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors/abiParameter.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\");\n/* harmony import */ var _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/signature.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js\");\n/* harmony import */ var _errors_splitParameters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/splitParameters.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js\");\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js\");\n/* harmony import */ var _signatures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signatures.js */ \"(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n\n\n\n\n\n\n\nfunction parseSignature(signature, structs = {}) {\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isFunctionSignature)(signature))\n        return parseFunctionSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isEventSignature)(signature))\n        return parseEventSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isErrorSignature)(signature))\n        return parseErrorSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isConstructorSignature)(signature))\n        return parseConstructorSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isFallbackSignature)(signature))\n        return parseFallbackSignature(signature);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isReceiveSignature)(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.UnknownSignatureError({ signature });\n}\nfunction parseFunctionSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execFunctionSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'function' });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n        inputs.push(parseAbiParameter(inputParams[i], {\n            modifiers: _signatures_js__WEBPACK_IMPORTED_MODULE_0__.functionModifiers,\n            structs,\n            type: 'function',\n        }));\n    }\n    const outputs = [];\n    if (match.returns) {\n        const outputParams = splitParameters(match.returns);\n        const outputLength = outputParams.length;\n        for (let i = 0; i < outputLength; i++) {\n            outputs.push(parseAbiParameter(outputParams[i], {\n                modifiers: _signatures_js__WEBPACK_IMPORTED_MODULE_0__.functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n    }\n    return {\n        name: match.name,\n        type: 'function',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs,\n        outputs,\n    };\n}\nfunction parseEventSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execEventSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'event' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], {\n            modifiers: _signatures_js__WEBPACK_IMPORTED_MODULE_0__.eventModifiers,\n            structs,\n            type: 'event',\n        }));\n    return { name: match.name, type: 'event', inputs: abiParameters };\n}\nfunction parseErrorSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execErrorSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'error' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n    return { name: match.name, type: 'error', inputs: abiParameters };\n}\nfunction parseConstructorSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execConstructorSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'constructor' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n    return {\n        type: 'constructor',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs: abiParameters,\n    };\n}\nfunction parseFallbackSignature(signature) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execFallbackSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'fallback' });\n    return {\n        type: 'fallback',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n    };\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\\spayable)?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n    // optional namespace cache by `type`\n    const parameterCacheKey = (0,_cache_js__WEBPACK_IMPORTED_MODULE_2__.getParameterCacheKey)(param, options?.type, options?.structs);\n    if (_cache_js__WEBPACK_IMPORTED_MODULE_2__.parameterCache.has(parameterCacheKey))\n        return _cache_js__WEBPACK_IMPORTED_MODULE_2__.parameterCache.get(parameterCacheKey);\n    const isTuple = _regex_js__WEBPACK_IMPORTED_MODULE_3__.isTupleRegex.test(param);\n    const match = (0,_regex_js__WEBPACK_IMPORTED_MODULE_3__.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            // remove `modifiers` from `options` to prevent from being added to tuple components\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else if (match.type === 'address payable') {\n        type = 'address';\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_5__.UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        // Check if resolved `type` is valid if there is a function modifier\n        if (_signatures_js__WEBPACK_IMPORTED_MODULE_0__.functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    _cache_js__WEBPACK_IMPORTED_MODULE_2__.parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\n// s/o latika for this\nfunction splitParameters(params, result = [], current = '', depth = 0) {\n    const length = params.trim().length;\n    // biome-ignore lint/correctness/noUnreachable: recursive\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    if (current === '')\n        return result;\n    if (depth !== 0)\n        throw new _errors_splitParameters_js__WEBPACK_IMPORTED_MODULE_6__.InvalidParenthesisError({ current, depth });\n    result.push(current.trim());\n    return result;\n}\nfunction isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.bytesRegex.test(type) ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.integerRegex.test(type));\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nfunction isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.bytesRegex.test(name) ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\n/** @internal */\nfunction isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Y7QUFDcEI7QUFDc0Y7QUFDL0Q7QUFDaEI7QUFDTDtBQUM2TztBQUN4UywrQ0FBK0M7QUFDdEQsUUFBUSxtRUFBbUI7QUFDM0I7QUFDQSxRQUFRLGdFQUFnQjtBQUN4QjtBQUNBLFFBQVEsZ0VBQWdCO0FBQ3hCO0FBQ0EsUUFBUSxzRUFBc0I7QUFDOUI7QUFDQSxRQUFRLG1FQUFtQjtBQUMzQjtBQUNBLFFBQVEsa0VBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1RUFBcUIsR0FBRyxXQUFXO0FBQ2pEO0FBQ08sdURBQXVEO0FBQzlELGtCQUFrQixxRUFBcUI7QUFDdkM7QUFDQSxrQkFBa0IsdUVBQXFCLEdBQUcsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSx1QkFBdUIsNkRBQWlCO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQSwyQkFBMkIsNkRBQWlCO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvREFBb0Q7QUFDM0Qsa0JBQWtCLGtFQUFrQjtBQUNwQztBQUNBLGtCQUFrQix1RUFBcUIsR0FBRywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSx1QkFBdUIsMERBQWM7QUFDckM7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhO0FBQ2I7QUFDTyxvREFBb0Q7QUFDM0Qsa0JBQWtCLGtFQUFrQjtBQUNwQztBQUNBLGtCQUFrQix1RUFBcUIsR0FBRywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsMERBQTBELHdCQUF3QjtBQUNsRixhQUFhO0FBQ2I7QUFDTywwREFBMEQ7QUFDakUsa0JBQWtCLHdFQUF3QjtBQUMxQztBQUNBLGtCQUFrQix1RUFBcUIsR0FBRyxnQ0FBZ0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsMERBQTBELDhCQUE4QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQixxRUFBcUI7QUFDdkM7QUFDQSxrQkFBa0IsdUVBQXFCLEdBQUcsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUssRUFBRTtBQUNuSywrSEFBK0gsRUFBRTtBQUNqSTtBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsK0RBQW9CO0FBQ2xELFFBQVEscURBQWM7QUFDdEIsZUFBZSxxREFBYztBQUM3QixvQkFBb0IsbURBQVk7QUFDaEMsa0JBQWtCLG9EQUFTO0FBQzNCO0FBQ0Esa0JBQWtCLDBFQUFxQixHQUFHLE9BQU87QUFDakQ7QUFDQSxrQkFBa0Isa0ZBQTZCLEdBQUcseUJBQXlCO0FBQzNFLGdDQUFnQyxtQkFBbUI7QUFDbkQscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdFQUF3QixHQUFHLE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUVBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVksNkRBQWlCO0FBQzdCO0FBQ0Esc0JBQXNCLGlGQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQixLQUFLLEVBQUUsa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUSxFQUFFLEtBQUs7QUFDdEU7QUFDQSx3REFBd0QsUUFBUSxFQUFFLEtBQUs7QUFDdkU7QUFDQSx3REFBd0QsUUFBUSxFQUFFLEtBQUs7QUFDdkU7QUFDQSx3REFBd0QsUUFBUSxFQUFFLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrRUFBdUIsR0FBRyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQVU7QUFDbEIsUUFBUSxtREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFVO0FBQ2xCLFFBQVEsbURBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvdXRpbHMuanM/ZDgwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBieXRlc1JlZ2V4LCBleGVjVHlwZWQsIGludGVnZXJSZWdleCwgaXNUdXBsZVJlZ2V4LCB9IGZyb20gJy4uLy4uL3JlZ2V4LmpzJztcbmltcG9ydCB7IFVua25vd25Tb2xpZGl0eVR5cGVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9hYmlJdGVtLmpzJztcbmltcG9ydCB7IEludmFsaWRGdW5jdGlvbk1vZGlmaWVyRXJyb3IsIEludmFsaWRNb2RpZmllckVycm9yLCBJbnZhbGlkUGFyYW1ldGVyRXJyb3IsIFNvbGlkaXR5UHJvdGVjdGVkS2V5d29yZEVycm9yLCB9IGZyb20gJy4uL2Vycm9ycy9hYmlQYXJhbWV0ZXIuanMnO1xuaW1wb3J0IHsgSW52YWxpZFNpZ25hdHVyZUVycm9yLCBVbmtub3duU2lnbmF0dXJlRXJyb3IsIH0gZnJvbSAnLi4vZXJyb3JzL3NpZ25hdHVyZS5qcyc7XG5pbXBvcnQgeyBJbnZhbGlkUGFyZW50aGVzaXNFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9zcGxpdFBhcmFtZXRlcnMuanMnO1xuaW1wb3J0IHsgZ2V0UGFyYW1ldGVyQ2FjaGVLZXksIHBhcmFtZXRlckNhY2hlIH0gZnJvbSAnLi9jYWNoZS5qcyc7XG5pbXBvcnQgeyBldmVudE1vZGlmaWVycywgZXhlY0NvbnN0cnVjdG9yU2lnbmF0dXJlLCBleGVjRXJyb3JTaWduYXR1cmUsIGV4ZWNFdmVudFNpZ25hdHVyZSwgZXhlY0ZhbGxiYWNrU2lnbmF0dXJlLCBleGVjRnVuY3Rpb25TaWduYXR1cmUsIGZ1bmN0aW9uTW9kaWZpZXJzLCBpc0NvbnN0cnVjdG9yU2lnbmF0dXJlLCBpc0Vycm9yU2lnbmF0dXJlLCBpc0V2ZW50U2lnbmF0dXJlLCBpc0ZhbGxiYWNrU2lnbmF0dXJlLCBpc0Z1bmN0aW9uU2lnbmF0dXJlLCBpc1JlY2VpdmVTaWduYXR1cmUsIH0gZnJvbSAnLi9zaWduYXR1cmVzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xuICAgIGlmIChpc0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyk7XG4gICAgaWYgKGlzRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKTtcbiAgICBpZiAoaXNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgICByZXR1cm4gcGFyc2VFcnJvclNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMpO1xuICAgIGlmIChpc0NvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgIHJldHVybiBwYXJzZUNvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyk7XG4gICAgaWYgKGlzRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoaXNSZWNlaXZlU2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncmVjZWl2ZScsXG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdwYXlhYmxlJyxcbiAgICAgICAgfTtcbiAgICB0aHJvdyBuZXcgVW5rbm93blNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzID0ge30pIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUsIHR5cGU6ICdmdW5jdGlvbicgfSk7XG4gICAgY29uc3QgaW5wdXRQYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgaW5wdXRzID0gW107XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dFBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKGlucHV0UGFyYW1zW2ldLCB7XG4gICAgICAgICAgICBtb2RpZmllcnM6IGZ1bmN0aW9uTW9kaWZpZXJzLFxuICAgICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgIGlmIChtYXRjaC5yZXR1cm5zKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dFBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5yZXR1cm5zKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0TGVuZ3RoID0gb3V0cHV0UGFyYW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKG91dHB1dFBhcmFtc1tpXSwge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogZnVuY3Rpb25Nb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG1hdGNoLm5hbWUsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogbWF0Y2guc3RhdGVNdXRhYmlsaXR5ID8/ICdub25wYXlhYmxlJyxcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICBvdXRwdXRzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdmVudFNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhlY0V2ZW50U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogJ2V2ZW50JyB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtc1tpXSwge1xuICAgICAgICAgICAgbW9kaWZpZXJzOiBldmVudE1vZGlmaWVycyxcbiAgICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICB9KSk7XG4gICAgcmV0dXJuIHsgbmFtZTogbWF0Y2gubmFtZSwgdHlwZTogJ2V2ZW50JywgaW5wdXRzOiBhYmlQYXJhbWV0ZXJzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFcnJvclNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhlY0Vycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogJ2Vycm9yJyB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtc1tpXSwgeyBzdHJ1Y3RzLCB0eXBlOiAnZXJyb3InIH0pKTtcbiAgICByZXR1cm4geyBuYW1lOiBtYXRjaC5uYW1lLCB0eXBlOiAnZXJyb3InLCBpbnB1dHM6IGFiaVBhcmFtZXRlcnMgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyA9IHt9KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlLCB0eXBlOiAnY29uc3RydWN0b3InIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5wYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBhYmlQYXJhbWV0ZXJzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7IHN0cnVjdHMsIHR5cGU6ICdjb25zdHJ1Y3RvcicgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogbWF0Y2guc3RhdGVNdXRhYmlsaXR5ID8/ICdub25wYXlhYmxlJyxcbiAgICAgICAgaW5wdXRzOiBhYmlQYXJhbWV0ZXJzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUsIHR5cGU6ICdmYWxsYmFjaycgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ZhbGxiYWNrJyxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBtYXRjaC5zdGF0ZU11dGFiaWxpdHkgPz8gJ25vbnBheWFibGUnLFxuICAgIH07XG59XG5jb25zdCBhYmlQYXJhbWV0ZXJXaXRob3V0VHVwbGVSZWdleCA9IC9eKD88dHlwZT5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSooPzpcXHNwYXlhYmxlKT8pKD88YXJyYXk+KD86XFxbXFxkKj9cXF0pKz8pPyg/Olxccyg/PG1vZGlmaWVyPmNhbGxkYXRhfGluZGV4ZWR8bWVtb3J5fHN0b3JhZ2V7MX0pKT8oPzpcXHMoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKikpPyQvO1xuY29uc3QgYWJpUGFyYW1ldGVyV2l0aFR1cGxlUmVnZXggPSAvXlxcKCg/PHR5cGU+Lis/KVxcKSg/PGFycmF5Pig/OlxcW1xcZCo/XFxdKSs/KT8oPzpcXHMoPzxtb2RpZmllcj5jYWxsZGF0YXxpbmRleGVkfG1lbW9yeXxzdG9yYWdlezF9KSk/KD86XFxzKD88bmFtZT5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSopKT8kLztcbmNvbnN0IGR5bmFtaWNJbnRlZ2VyUmVnZXggPSAvXnU/aW50JC87XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBYmlQYXJhbWV0ZXIocGFyYW0sIG9wdGlvbnMpIHtcbiAgICAvLyBvcHRpb25hbCBuYW1lc3BhY2UgY2FjaGUgYnkgYHR5cGVgXG4gICAgY29uc3QgcGFyYW1ldGVyQ2FjaGVLZXkgPSBnZXRQYXJhbWV0ZXJDYWNoZUtleShwYXJhbSwgb3B0aW9ucz8udHlwZSwgb3B0aW9ucz8uc3RydWN0cyk7XG4gICAgaWYgKHBhcmFtZXRlckNhY2hlLmhhcyhwYXJhbWV0ZXJDYWNoZUtleSkpXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJDYWNoZS5nZXQocGFyYW1ldGVyQ2FjaGVLZXkpO1xuICAgIGNvbnN0IGlzVHVwbGUgPSBpc1R1cGxlUmVnZXgudGVzdChwYXJhbSk7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjVHlwZWQoaXNUdXBsZSA/IGFiaVBhcmFtZXRlcldpdGhUdXBsZVJlZ2V4IDogYWJpUGFyYW1ldGVyV2l0aG91dFR1cGxlUmVnZXgsIHBhcmFtKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlckVycm9yKHsgcGFyYW0gfSk7XG4gICAgaWYgKG1hdGNoLm5hbWUgJiYgaXNTb2xpZGl0eUtleXdvcmQobWF0Y2gubmFtZSkpXG4gICAgICAgIHRocm93IG5ldyBTb2xpZGl0eVByb3RlY3RlZEtleXdvcmRFcnJvcih7IHBhcmFtLCBuYW1lOiBtYXRjaC5uYW1lIH0pO1xuICAgIGNvbnN0IG5hbWUgPSBtYXRjaC5uYW1lID8geyBuYW1lOiBtYXRjaC5uYW1lIH0gOiB7fTtcbiAgICBjb25zdCBpbmRleGVkID0gbWF0Y2gubW9kaWZpZXIgPT09ICdpbmRleGVkJyA/IHsgaW5kZXhlZDogdHJ1ZSB9IDoge307XG4gICAgY29uc3Qgc3RydWN0cyA9IG9wdGlvbnM/LnN0cnVjdHMgPz8ge307XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGNvbXBvbmVudHMgPSB7fTtcbiAgICBpZiAoaXNUdXBsZSkge1xuICAgICAgICB0eXBlID0gJ3R1cGxlJztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnR5cGUpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRzXyA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYG1vZGlmaWVyc2AgZnJvbSBgb3B0aW9uc2AgdG8gcHJldmVudCBmcm9tIGJlaW5nIGFkZGVkIHRvIHR1cGxlIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGNvbXBvbmVudHNfLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7IHN0cnVjdHMgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudHMgPSB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHNfIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoLnR5cGUgaW4gc3RydWN0cykge1xuICAgICAgICB0eXBlID0gJ3R1cGxlJztcbiAgICAgICAgY29tcG9uZW50cyA9IHsgY29tcG9uZW50czogc3RydWN0c1ttYXRjaC50eXBlXSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkeW5hbWljSW50ZWdlclJlZ2V4LnRlc3QobWF0Y2gudHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IGAke21hdGNoLnR5cGV9MjU2YDtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2gudHlwZSA9PT0gJ2FkZHJlc3MgcGF5YWJsZScpIHtcbiAgICAgICAgdHlwZSA9ICdhZGRyZXNzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSBtYXRjaC50eXBlO1xuICAgICAgICBpZiAoIShvcHRpb25zPy50eXBlID09PSAnc3RydWN0JykgJiYgIWlzU29saWRpdHlUeXBlKHR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFVua25vd25Tb2xpZGl0eVR5cGVFcnJvcih7IHR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChtYXRjaC5tb2RpZmllcikge1xuICAgICAgICAvLyBDaGVjayBpZiBtb2RpZmllciBleGlzdHMsIGJ1dCBpcyBub3QgYWxsb3dlZCAoZS5nLiBgaW5kZXhlZGAgaW4gYGZ1bmN0aW9uTW9kaWZpZXJzYClcbiAgICAgICAgaWYgKCFvcHRpb25zPy5tb2RpZmllcnM/Lmhhcz8uKG1hdGNoLm1vZGlmaWVyKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTW9kaWZpZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgcGFyYW0sXG4gICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucz8udHlwZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogbWF0Y2gubW9kaWZpZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcmVzb2x2ZWQgYHR5cGVgIGlzIHZhbGlkIGlmIHRoZXJlIGlzIGEgZnVuY3Rpb24gbW9kaWZpZXJcbiAgICAgICAgaWYgKGZ1bmN0aW9uTW9kaWZpZXJzLmhhcyhtYXRjaC5tb2RpZmllcikgJiZcbiAgICAgICAgICAgICFpc1ZhbGlkRGF0YUxvY2F0aW9uKHR5cGUsICEhbWF0Y2guYXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRGdW5jdGlvbk1vZGlmaWVyRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnM/LnR5cGUsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IG1hdGNoLm1vZGlmaWVyLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IHtcbiAgICAgICAgdHlwZTogYCR7dHlwZX0ke21hdGNoLmFycmF5ID8/ICcnfWAsXG4gICAgICAgIC4uLm5hbWUsXG4gICAgICAgIC4uLmluZGV4ZWQsXG4gICAgICAgIC4uLmNvbXBvbmVudHMsXG4gICAgfTtcbiAgICBwYXJhbWV0ZXJDYWNoZS5zZXQocGFyYW1ldGVyQ2FjaGVLZXksIGFiaVBhcmFtZXRlcik7XG4gICAgcmV0dXJuIGFiaVBhcmFtZXRlcjtcbn1cbi8vIHMvbyBsYXRpa2EgZm9yIHRoaXNcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFBhcmFtZXRlcnMocGFyYW1zLCByZXN1bHQgPSBbXSwgY3VycmVudCA9ICcnLCBkZXB0aCA9IDApIHtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMudHJpbSgpLmxlbmd0aDtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy9ub1VucmVhY2hhYmxlOiByZWN1cnNpdmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBwYXJhbXNbaV07XG4gICAgICAgIGNvbnN0IHRhaWwgPSBwYXJhbXMuc2xpY2UoaSArIDEpO1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZXB0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IHNwbGl0UGFyYW1ldGVycyh0YWlsLCBbLi4ucmVzdWx0LCBjdXJyZW50LnRyaW0oKV0pXG4gICAgICAgICAgICAgICAgICAgIDogc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGgpO1xuICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0UGFyYW1ldGVycyh0YWlsLCByZXN1bHQsIGAke2N1cnJlbnR9JHtjaGFyfWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGggLSAxKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0UGFyYW1ldGVycyh0YWlsLCByZXN1bHQsIGAke2N1cnJlbnR9JHtjaGFyfWAsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudCA9PT0gJycpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGRlcHRoICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmVudGhlc2lzRXJyb3IoeyBjdXJyZW50LCBkZXB0aCB9KTtcbiAgICByZXN1bHQucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NvbGlkaXR5VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSAnYWRkcmVzcycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2Jvb2wnIHx8XG4gICAgICAgIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgYnl0ZXNSZWdleC50ZXN0KHR5cGUpIHx8XG4gICAgICAgIGludGVnZXJSZWdleC50ZXN0KHR5cGUpKTtcbn1cbmNvbnN0IHByb3RlY3RlZEtleXdvcmRzUmVnZXggPSAvXig/OmFmdGVyfGFsaWFzfGFub255bW91c3xhcHBseXxhdXRvfGJ5dGV8Y2FsbGRhdGF8Y2FzZXxjYXRjaHxjb25zdGFudHxjb3B5b2Z8ZGVmYXVsdHxkZWZpbmVkfGVycm9yfGV2ZW50fGV4dGVybmFsfGZhbHNlfGZpbmFsfGZ1bmN0aW9ufGltbXV0YWJsZXxpbXBsZW1lbnRzfGlufGluZGV4ZWR8aW5saW5lfGludGVybmFsfGxldHxtYXBwaW5nfG1hdGNofG1lbW9yeXxtdXRhYmxlfG51bGx8b2Z8b3ZlcnJpZGV8cGFydGlhbHxwcml2YXRlfHByb21pc2V8cHVibGljfHB1cmV8cmVmZXJlbmNlfHJlbG9jYXRhYmxlfHJldHVybnxyZXR1cm5zfHNpemVvZnxzdGF0aWN8c3RvcmFnZXxzdHJ1Y3R8c3VwZXJ8c3VwcG9ydHN8c3dpdGNofHRoaXN8dHJ1ZXx0cnl8dHlwZWRlZnx0eXBlb2Z8dmFyfHZpZXd8dmlydHVhbCkkLztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NvbGlkaXR5S2V5d29yZChuYW1lKSB7XG4gICAgcmV0dXJuIChuYW1lID09PSAnYWRkcmVzcycgfHxcbiAgICAgICAgbmFtZSA9PT0gJ2Jvb2wnIHx8XG4gICAgICAgIG5hbWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgbmFtZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgbmFtZSA9PT0gJ3R1cGxlJyB8fFxuICAgICAgICBieXRlc1JlZ2V4LnRlc3QobmFtZSkgfHxcbiAgICAgICAgaW50ZWdlclJlZ2V4LnRlc3QobmFtZSkgfHxcbiAgICAgICAgcHJvdGVjdGVkS2V5d29yZHNSZWdleC50ZXN0KG5hbWUpKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRGF0YUxvY2F0aW9uKHR5cGUsIGlzQXJyYXkpIHtcbiAgICByZXR1cm4gaXNBcnJheSB8fCB0eXBlID09PSAnYnl0ZXMnIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICd0dXBsZSc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/regex.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   execTyped: () => (/* binding */ execTyped),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   isTupleRegex: () => (/* binding */ isTupleRegex)\n/* harmony export */ });\n// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nfunction execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL3JlZ2V4LmpzPzI4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogVGhpcyBsb29rcyBjb29sLiBOZWVkIHRvIGNoZWNrIHRoZSBwZXJmb3JtYW5jZSBvZiBgbmV3IFJlZ0V4cGAgdmVyc3VzIGRlZmluZWQgaW5saW5lIHRob3VnaC5cbi8vIGh0dHBzOi8vdHdpdHRlci5jb20vR2FicmllbFZlcmduYXVkL3N0YXR1cy8xNjIyOTA2ODM0MzQzMzY2NjU3XG5leHBvcnQgZnVuY3Rpb24gZXhlY1R5cGVkKHJlZ2V4LCBzdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICByZXR1cm4gbWF0Y2g/Lmdyb3Vwcztcbn1cbi8vIGBieXRlczxNPmA6IGJpbmFyeSB0eXBlIG9mIGBNYCBieXRlcywgYDAgPCBNIDw9IDMyYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTU1XG5leHBvcnQgY29uc3QgYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xuLy8gYCh1KWludDxNPmA6ICh1bilzaWduZWQgaW50ZWdlciB0eXBlIG9mIGBNYCBiaXRzLCBgMCA8IE0gPD0gMjU2YCwgYE0gJSA4ID09IDBgXG4vLyBodHRwczovL3JlZ2V4ci5jb20vNnY4aHBcbmV4cG9ydCBjb25zdCBpbnRlZ2VyUmVnZXggPSAvXnU/aW50KDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC87XG5leHBvcnQgY29uc3QgaXNUdXBsZVJlZ2V4ID0gL15cXCguKz9cXCkuKj8kLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2V4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/version.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '1.2.3';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vdmVyc2lvbi5qcz9lODA1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMi4zJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/abitype/dist/esm/version.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbiParameters.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs?.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nfunction format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_2__.formatAbiItem(abiConstructor);\n}\n/** @internal */\nfunction from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */\nfunction fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpQ29uc3RydWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDWTtBQUNwQjtBQUNoQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFvQjtBQUMvQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxpQkFBaUI7QUFDN0IsV0FBVywyQ0FBVTtBQUNyQixVQUFVLHFEQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0E7QUFDTztBQUNQLFdBQVcsNkNBQVk7QUFDdkI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixzREFBcUIsR0FBRyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpQ29uc3RydWN0b3IuanM/OGVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWJpSXRlbSBmcm9tICcuL0FiaUl0ZW0uanMnO1xuaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpQ29uc3RydWN0b3IsIG9wdGlvbnNdID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG9wdGlvbnNdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmkpLCBvcHRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgYnl0ZWNvZGUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGFiaUNvbnN0cnVjdG9yLmlucHV0cz8ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGEucmVwbGFjZShieXRlY29kZSwgJzB4Jyk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZGVjb2RlKGFiaUNvbnN0cnVjdG9yLmlucHV0cywgZGF0YSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUNvbnN0cnVjdG9yLCBvcHRpb25zXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpKSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGJ5dGVjb2RlLCBhcmdzIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIZXguY29uY2F0KGJ5dGVjb2RlLCBhYmlDb25zdHJ1Y3Rvci5pbnB1dHM/Lmxlbmd0aCAmJiBhcmdzPy5sZW5ndGhcbiAgICAgICAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlDb25zdHJ1Y3Rvci5pbnB1dHMsIGFyZ3MpXG4gICAgICAgIDogJzB4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlDb25zdHJ1Y3Rvcik7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBBYmlJdGVtLmZyb20oYWJpQ29uc3RydWN0b3IpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpKSB7XG4gICAgY29uc3QgaXRlbSA9IGFiaS5maW5kKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicpO1xuICAgIGlmICghaXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uTm90Rm91bmRFcnJvcih7IG5hbWU6ICdjb25zdHJ1Y3RvcicgfSk7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlDb25zdHJ1Y3Rvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/AbiConstructor.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiFunction.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: () => (/* binding */ decodeData),\n/* harmony export */   decodeResult: () => (/* binding */ decodeResult),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeResult: () => (/* binding */ encodeResult),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! abitype */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiItem.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiParameters.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeData(...parameters) {\n    const [abiFunction, data] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [fromAbi(abi, name), data];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) < 4)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs?.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) <= 4)\n        return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(data, 4));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [fromAbi(abi, name), data, options];\n        }\n        return parameters;\n    })();\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeData(...parameters) {\n    const [abiFunction, args = []] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [fromAbi(abi, name, { args }), args];\n        }\n        const [abiFunction, args] = parameters;\n        return [abiFunction, args];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args,\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(item.inputs, args) : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(selector, data) : selector;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [fromAbi(abi, name), output, options];\n        }\n        return parameters;\n    })();\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nfunction format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_3__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nfunction from(abiFunction, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nfunction getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpRnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDWTtBQUNwQjtBQUNoQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksWUFBWTtBQUN4QixRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixpRUFBZ0MsR0FBRyxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFRO0FBQ2hCO0FBQ0EsV0FBVyxxREFBb0IsY0FBYywwQ0FBUztBQUN0RDtBQUNBO0FBQ087QUFDUCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIscURBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFvQjtBQUN2RCxrQkFBa0IsMkNBQVU7QUFDNUI7QUFDQTtBQUNPO0FBQ1AsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyxxREFBb0I7QUFDL0I7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ0EsOEZBQThGLGlDQUFpQztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUMsV0FBVyw2Q0FBWTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQyxTQUFTLGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLGdEQUFlO0FBQ2hDO0FBQ0Esa0JBQWtCLHNEQUFxQixHQUFHLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsaUNBQWlDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ087QUFDUCxXQUFXLG9EQUFtQjtBQUM5QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpRnVuY3Rpb24uanM/YTVkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWJpSXRlbSBmcm9tICcuL0FiaUl0ZW0uanMnO1xuaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGF0YSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUZ1bmN0aW9uLCBkYXRhXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBkYXRhXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lKSwgZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IG92ZXJsb2FkcyB9ID0gYWJpRnVuY3Rpb247XG4gICAgaWYgKEhleC5zaXplKGRhdGEpIDwgNClcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yKHsgZGF0YSB9KTtcbiAgICBpZiAoYWJpRnVuY3Rpb24uaW5wdXRzPy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXRlbSA9IG92ZXJsb2Fkc1xuICAgICAgICA/IGZyb21BYmkoW2FiaUZ1bmN0aW9uLCAuLi5vdmVybG9hZHNdLCBkYXRhKVxuICAgICAgICA6IGFiaUZ1bmN0aW9uO1xuICAgIGlmIChIZXguc2l6ZShkYXRhKSA8PSA0KVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmRlY29kZShpdGVtLmlucHV0cywgSGV4LnNsaWNlKGRhdGEsIDQpKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmVzdWx0KC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGRhdGEsIG9wdGlvbnMgPSB7fV0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZSwgZGF0YSwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSksIGRhdGEsIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgdmFsdWVzID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoYWJpRnVuY3Rpb24ub3V0cHV0cywgZGF0YSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlcyAmJiBPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh2YWx1ZXMpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXRhKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGFyZ3MgPSBbXV0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZSwgYXJnc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSwgeyBhcmdzIH0pLCBhcmdzXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGFyZ3NdID0gcGFyYW1ldGVycztcbiAgICAgICAgcmV0dXJuIFthYmlGdW5jdGlvbiwgYXJnc107XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IG92ZXJsb2FkcyB9ID0gYWJpRnVuY3Rpb247XG4gICAgY29uc3QgaXRlbSA9IG92ZXJsb2Fkc1xuICAgICAgICA/IGZyb21BYmkoW2FiaUZ1bmN0aW9uLCAuLi5vdmVybG9hZHNdLCBhYmlGdW5jdGlvbi5uYW1lLCB7XG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICB9KVxuICAgICAgICA6IGFiaUZ1bmN0aW9uO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoaXRlbSk7XG4gICAgY29uc3QgZGF0YSA9IGFyZ3MubGVuZ3RoID4gMCA/IEFiaVBhcmFtZXRlcnMuZW5jb2RlKGl0ZW0uaW5wdXRzLCBhcmdzKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZGF0YSA/IEhleC5jb25jYXQoc2VsZWN0b3IsIGRhdGEpIDogc2VsZWN0b3I7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJlc3VsdCguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUZ1bmN0aW9uLCBvdXRwdXQsIG9wdGlvbnMgPSB7fV0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZSwgb3V0cHV0LCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lKSwgb3V0cHV0LCBvcHRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgYXMgPSAnQXJyYXknIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChhYmlGdW5jdGlvbi5vdXRwdXRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0KSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIGlmIChhcyA9PT0gJ09iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvdXRwdXQpO1xuICAgICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfSkoKTtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5lbmNvZGUoYWJpRnVuY3Rpb24ub3V0cHV0cywgdmFsdWVzKTtcbn1cbi8qKlxuICogRm9ybWF0cyBhbiB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uQWJpRnVuY3Rpb259IGludG8gYSAqKkh1bWFuIFJlYWRhYmxlIEFCSSBGdW5jdGlvbioqLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlGdW5jdGlvbi5mb3JtYXQoe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9KVxuICpcbiAqIGZvcm1hdHRlZFxuICogLy8gICAgXj9cbiAqXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUZ1bmN0aW9uIC0gVGhlIEFCSSBGdW5jdGlvbiB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBGdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChhYmlGdW5jdGlvbikge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpRnVuY3Rpb24pO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gYXJiaXRyYXJ5ICoqSlNPTiBBQkkgRnVuY3Rpb24qKiBvciAqKkh1bWFuIFJlYWRhYmxlIEFCSSBGdW5jdGlvbioqIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uQWJpRnVuY3Rpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSlNPTiBBQklzXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9KVxuICpcbiAqIGFwcHJvdmVcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgQUJJc1xuICpcbiAqIEEgSHVtYW4gUmVhZGFibGUgQUJJIGNhbiBiZSBwYXJzZWQgaW50byBhIHR5cGVkIEFCSSBvYmplY3Q6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHJldHVybnMgKGJvb2wpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oW1xuICogICAnc3RydWN0IEZvbyB7IGFkZHJlc3Mgc3BlbmRlcjsgdWludDI1NiBhbW91bnQ7IH0nLCAvLyBbIWNvZGUgaGxdXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKEZvbyBmb28pIHJldHVybnMgKGJvb2wpJyxcbiAqIF0pXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBUaGUgQUJJIEZ1bmN0aW9uIHRvIHBhcnNlLlxuICogQHJldHVybnMgVHlwZWQgQUJJIEZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlGdW5jdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZnJvbShhYmlGdW5jdGlvbiwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4dHJhY3RzIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IE5hbWVcbiAqXG4gKiBBQkkgRnVuY3Rpb25zIGNhbiBiZSBleHRyYWN0ZWQgYnkgdGhlaXIgbmFtZSB1c2luZyB0aGUgYG5hbWVgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnZm9vJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRXh0cmFjdGluZyBieSBTZWxlY3RvclxuICpcbiAqIEFCSSBGdW5jdGlvbnMgY2FuIGJlIGV4dHJhY3QgYnkgdGhlaXIgc2VsZWN0b3Igd2hlbiB7QGxpbmsgb3gjSGV4LkhleH0gaXMgcHJvdmlkZWQgdG8gYG5hbWVgLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqIGNvbnN0IGl0ZW0gPSBBYmlGdW5jdGlvbi5mcm9tQWJpKGFiaSwgJzB4MDk1ZWE3YjMnKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEV4dHJhY3RpbmcgdmlhIGEgaGV4IHNlbGVjdG9yIGlzIHVzZWZ1bCB3aGVuIGV4dHJhY3RpbmcgYW4gQUJJIEZ1bmN0aW9uIGZyb20gYW4gYGV0aF9jYWxsYCBSUEMgcmVzcG9uc2Ugb3JcbiAqIGZyb20gYSBUcmFuc2FjdGlvbiBgaW5wdXRgLlxuICpcbiAqIDo6OlxuICpcbiAqIEBwYXJhbSBhYmkgLSBUaGUgQUJJIHRvIGV4dHJhY3QgZnJvbS5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgKG9yIHNlbGVjdG9yKSBvZiB0aGUgQUJJIGl0ZW0gdG8gZXh0cmFjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRXh0cmFjdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEFCSSBpdGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpdGVtID0gQWJpSXRlbS5mcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKGl0ZW0udHlwZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uTm90Rm91bmRFcnJvcih7IG5hbWUsIHR5cGU6ICdmdW5jdGlvbicgfSk7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBbNC1ieXRlIHNlbGVjdG9yXShodHRwczovL3NvbGlkaXR5LWJ5LWV4YW1wbGUub3JnL2Z1bmN0aW9uLXNlbGVjdG9yLykgZm9yIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0uXG4gKlxuICogVXNlZnVsIGZvciBjb21wdXRpbmcgZnVuY3Rpb24gc2VsZWN0b3JzIGZvciBjYWxsZGF0YS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlGdW5jdGlvbi5nZXRTZWxlY3RvcignZnVuY3Rpb24gb3duZXJPZih1aW50MjU2IHRva2VuSWQpJylcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNlbGVjdG9yID0gQWJpRnVuY3Rpb24uZ2V0U2VsZWN0b3Ioe1xuICogICBpbnB1dHM6IFt7IHR5cGU6ICd1aW50MjU2JyB9XSxcbiAqICAgbmFtZTogJ293bmVyT2YnLFxuICogICBvdXRwdXRzOiBbXSxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gKiAgIHR5cGU6ICdmdW5jdGlvbidcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHg2MzUyMjExZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBpdGVtIHRvIGNvbXB1dGUgdGhlIHNlbGVjdG9yIGZvci5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSB7QGxpbmsgb3gjSGFzaC4oa2VjY2FrMjU2OmZ1bmN0aW9uKX0gaGFzaCBvZiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoYWJpSXRlbSkge1xuICAgIHJldHVybiBBYmlJdGVtLmdldFNlbGVjdG9yKGFiaUl0ZW0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpRnVuY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/AbiFunction.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiItem.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: () => (/* binding */ AmbiguityError),\n/* harmony export */   InvalidSelectorSizeError: () => (/* binding */ InvalidSelectorSizeError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   getSignatureHash: () => (/* binding */ getSignatureHash)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abitype */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiItem.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/abiItem.js\");\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nfunction format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nfunction from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSelector(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignature(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignatureHash(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_4__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nclass AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nclass NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nclass InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDRztBQUNKO0FBQ0Y7QUFDa0I7QUFDbEQ7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNBLHNGQUFzRix5QkFBeUI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQixpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxtQkFBbUIsaURBQW9CO0FBQ3ZDO0FBQ0EsbUJBQW1CLGlEQUFvQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQixJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEIsU0FBUyxrQkFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksNEJBQTRCO0FBQ3hDLFVBQVU7QUFDVix1QkFBdUIsNkNBQVksU0FBUyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwQ0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQyxJQUFJO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQ0FBa0MsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBb0I7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUVBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQyxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsMENBQVM7QUFDcEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQXFCO0FBQ3BDLEtBQUs7QUFDTCxXQUFXLG9FQUEyQjtBQUN0QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsK0NBQWMsQ0FBQywrQ0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixpREFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxVQUFVLG9FQUEyQixDQUFDLGtEQUFxQixhQUFhO0FBQ3BHLHFCQUFxQixPQUFPLFVBQVUsb0VBQTJCLENBQUMsa0RBQXFCLGFBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFnQjtBQUNuRCxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0EsU0FBUztBQUNULHFCQUFxQixLQUFLLEVBQUUsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxpREFBZ0I7QUFDOUQsa0JBQWtCLE1BQU07QUFDeEIsc0VBQXNFLHlDQUFRLFFBQVEsVUFBVSxLQUFLO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qcz83OWIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpSXRlbS5qcyc7XG4vKipcbiAqIEZvcm1hdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEl0ZW0qKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlJdGVtLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBJdGVtICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpSXRlbSkge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBJdGVtKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgSXRlbSoqIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gQUJJc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHJldHVybnMgKGJvb2wpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnZnVuY3Rpb24gYXBwcm92ZShGb28gZm9vKSByZXR1cm5zIChib29sKScsXG4gKiBdKVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQUJJIEl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFiaUl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFCSSBJdGVtcyBjYW4gYmUgZXh0cmFjdGVkIGJ5IHRoZWlyIG5hbWUgdXNpbmcgdGhlIGBuYW1lYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICdUcmFuc2ZlcicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgU2VsZWN0b3JcbiAqXG4gKiBBQkkgSXRlbXMgY2FuIGJlIGV4dHJhY3QgYnkgdGhlaXIgc2VsZWN0b3Igd2hlbiB7QGxpbmsgb3gjSGV4LkhleH0gaXMgcHJvdmlkZWQgdG8gYG5hbWVgLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICcweDA5NWVhN2IzJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgSXRlbSBmcm9tIGFuIGBldGhfY2FsbGAgUlBDIHJlc3BvbnNlLFxuICogYSBUcmFuc2FjdGlvbiBgaW5wdXRgLCBvciBmcm9tIEV2ZW50IExvZyBgdG9waWNzYC5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIChvciBzZWxlY3Rvcikgb2YgdGhlIEFCSSBpdGVtIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhY3Rpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBBQkkgaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzID0gW10sIHByZXBhcmUgPSB0cnVlIH0gPSAob3B0aW9ucyA/P1xuICAgICAgICB7fSk7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IEhleC52YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgYWJpSXRlbXMgPSBhYmkuZmlsdGVyKChhYmlJdGVtKSA9PiB7XG4gICAgICAgIGlmIChpc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZnVuY3Rpb24nIHx8IGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpSXRlbSkgPT09IEhleC5zbGljZShuYW1lLCAwLCA0KTtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICduYW1lJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFiaUl0ZW1zWzBdLFxuICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbXNbMF0pIH0gOiB7fSksXG4gICAgICAgIH07XG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtO1xuICAgIGZvciAoY29uc3QgYWJpSXRlbSBvZiBhYmlJdGVtcykge1xuICAgICAgICBpZiAoISgnaW5wdXRzJyBpbiBhYmlJdGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMgfHwgYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gJ2lucHV0cycgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwuaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbWJpZ3VpdHkgYWdhaW5zdCBhbHJlYWR5IG1hdGNoZWQgcGFyYW1ldGVycyAoZS5nLiBgYWRkcmVzc2AgdnMgYGJ5dGVzMjBgKS5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgICdpbnB1dHMnIGluIG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1iaWd1b3VzVHlwZXMgPSBpbnRlcm5hbC5nZXRBbWJpZ3VvdXNUeXBlcyhhYmlJdGVtLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzVHlwZXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW06IG1hdGNoZWRBYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0pXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZEFiaUl0ZW07XG4gICAgICAgIGNvbnN0IFthYmlJdGVtLCAuLi5vdmVybG9hZHNdID0gYWJpSXRlbXM7XG4gICAgICAgIHJldHVybiB7IC4uLmFiaUl0ZW0sIG92ZXJsb2FkcyB9O1xuICAgIH0pKCk7XG4gICAgaWYgKCFhYmlJdGVtKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvciguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEhleC5zbGljZShnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pLCAwLCA0KTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWVdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBmcm9tQWJpKGFiaSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgfSkoKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaUl0ZW07XG4gICAgICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gaW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZUhhc2goLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZV0gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIGZyb21BYmkoYWJpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgYWJpSXRlbSAhPT0gJ3N0cmluZycgJiYgJ2hhc2gnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5oYXNoKVxuICAgICAgICByZXR1cm4gYWJpSXRlbS5oYXNoO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhnZXRTaWduYXR1cmUoYWJpSXRlbSkpKTtcbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW1iaWd1b3VzIHR5cGVzIGFyZSBmb3VuZCBvbiBvdmVybG9hZGVkIEFCSSBpdGVtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsICdmdW5jdGlvbiBmb28oYnl0ZXMyMCknXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnZm9vJywge1xuICogICBhcmdzOiBbJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSddLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcjogRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLlxuICogLy8gQGVycm9yOiBgYnl0ZXMyMGAgaW4gYGZvbyhieXRlczIwKWAsIGFuZFxuICogLy8gQGVycm9yOiBgYWRkcmVzc2AgaW4gYGZvbyhhZGRyZXNzKWBcbiAqIC8vIEBlcnJvcjogVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlxuICogLy8gQGVycm9yOiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyB0eXBlcyBmcm9tIHRoZSBBQkkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gZm9vKGJ5dGVzMjApJyAvLyBbIWNvZGUgLS1dXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdmb28nLCB7XG4gKiAgIGFyZ3M6IFsnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ10sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkFtYmlndWl0eUVycm9yOiBGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuXG4gKiAvLyBAZXJyb3I6IGBieXRlczIwYCBpbiBgZm9vKGJ5dGVzMjApYCwgYW5kXG4gKiAvLyBAZXJyb3I6IGBhZGRyZXNzYCBpbiBgZm9vKGFkZHJlc3MpYFxuICogLy8gQGVycm9yOiBUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuXG4gKiAvLyBAZXJyb3I6IFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBbWJpZ3VpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgc3VwZXIoJ0ZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhYml0eXBlIHRvIGFkZCBzdXBwb3J0IGZvciBzaWduYXR1cmUtZm9ybWF0dGVkIEFCSSBpdGVtcy5cbiAgICAgICAgICAgICAgICBgXFxgJHt4LnR5cGV9XFxgIGluIFxcYCR7aW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKGFiaXR5cGUuZm9ybWF0QWJpSXRlbSh4LmFiaUl0ZW0pKX1cXGAsIGFuZGAsXG4gICAgICAgICAgICAgICAgYFxcYCR7eS50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeS5hYmlJdGVtKSl9XFxgYCxcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAnVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLicsXG4gICAgICAgICAgICAgICAgJ1JlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uQW1iaWd1aXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW4gQUJJIGl0ZW0gaXMgbm90IGZvdW5kIGluIHRoZSBBQkkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnYmF6JylcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5Ob3RGb3VuZEVycm9yOiBBQkkgZnVuY3Rpb24gd2l0aCBuYW1lIFwiYmF6XCIgbm90IGZvdW5kLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBBQkkgaXRlbSBleGlzdHMgb24gdGhlIEFCSS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KScsXG4gKiAgICdmdW5jdGlvbiBiYXooYm9vbCknIC8vIFshY29kZSArK11cbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2JheicpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGRhdGEsIHR5cGUgPSAnaXRlbScsIH0pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgd2l0aCBuYW1lIFwiJHtuYW1lfVwiYDtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggZGF0YSBcIiR7ZGF0YX1cImA7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHN1cGVyKGBBQkkgJHt0eXBlfSR7c2VsZWN0b3J9IG5vdCBmb3VuZC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uTm90Rm91bmRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgc2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICcweGFhYScpXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yOiBTZWxlY3RvciBzaXplIGlzIGludmFsaWQuIEV4cGVjdGVkIDQgYnl0ZXMuIFJlY2VpdmVkIDIgYnl0ZXMgKFwiMHhhYWFcIikuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBFbnN1cmUgdGhlIHNlbGVjdG9yIHNpemUgaXMgNCBieXRlcy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJzB4N2FmODJiMWEnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgfSkge1xuICAgICAgICBzdXBlcihgU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAke0hleC5zaXplKGRhdGEpfSBieXRlcyAoXCIke2RhdGF9XCIpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/AbiItem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! abitype */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! abitype */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Address.js */ \"(action-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/cursor.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/cursor.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Solidity.js */ \"(action-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n            parameters: parameters,\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_4__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size, 10),\n                    value: value,\n                });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nfunction format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nclass DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nclass ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nclass ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nclass BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nclass LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nclass InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nclass InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpUGFyYW1ldGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNKO0FBQ0U7QUFDTjtBQUN3QjtBQUNUO0FBQ0w7QUFDMUM7QUFDTyw4Q0FBOEM7QUFDckQsWUFBWSx3Q0FBd0M7QUFDcEQsNkNBQTZDLDhDQUFhO0FBQzFELG1CQUFtQix1REFBYTtBQUNoQyxRQUFRLDJDQUFVO0FBQ2xCO0FBQ0EsUUFBUSwyQ0FBVSxXQUFXLDJDQUFVO0FBQ3ZDO0FBQ0Esb0RBQW9ELDhDQUFhO0FBQ2pFO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0Esa0NBQWtDLHVFQUF3QjtBQUMxRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QyxTQUFTLDJCQUEyQjtBQUNwQyxTQUFTLCtCQUErQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHlFQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDhEQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFjO0FBQzFCLG1CQUFtQiw0Q0FBVztBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBVyxDQUFDLGdEQUFlO0FBQzlDLG9DQUFvQyxzREFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFjO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0Msb0RBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUIsNkNBQVk7QUFDL0I7QUFDQSxzQ0FBc0Msb0RBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsd0RBQTJCO0FBQ3RDO0FBQ0E7QUFDQSw2RkFBNkYscUNBQXFDO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxxQ0FBcUM7QUFDbEc7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSx1REFBMEI7QUFDekM7QUFDQSxlQUFlLHVEQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyxpREFBZ0I7QUFDM0Qsa0JBQWtCLHlCQUF5QjtBQUMzQyw4QkFBOEIsTUFBTTtBQUNwQztBQUNBLDRCQUE0Qix3REFBMkIsYUFBYTtBQUNwRSwyQkFBMkIsTUFBTSxHQUFHLE1BQU07QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxpREFBZ0I7QUFDOUQsa0JBQWtCLG9DQUFvQztBQUN0RCxrREFBa0QsS0FBSyxrQkFBa0IsZUFBZSxlQUFlLFlBQVk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUNBQXFDLGlEQUFnQjtBQUM1RCxrQkFBa0Isc0JBQXNCO0FBQ3hDLGdDQUFnQyxNQUFNLFVBQVUseUNBQVEsUUFBUSx1Q0FBdUMsYUFBYTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsaURBQWdCO0FBQ3ZEO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsaURBQWdCO0FBQ3REO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlQYXJhbWV0ZXJzLmpzP2Y1NTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgQ3Vyc29yIGZyb20gJy4vaW50ZXJuYWwvY3Vyc29yLmpzJztcbmltcG9ydCAqIGFzIFNvbGlkaXR5IGZyb20gJy4vU29saWRpdHkuanMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUocGFyYW1ldGVycywgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScsIGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChkYXRhKSA6IGRhdGE7XG4gICAgY29uc3QgY3Vyc29yID0gQ3Vyc29yLmNyZWF0ZShieXRlcyk7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID09PSAwICYmIHBhcmFtZXRlcnMubGVuZ3RoID4gMClcbiAgICAgICAgdGhyb3cgbmV3IFplcm9EYXRhRXJyb3IoKTtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgJiYgQnl0ZXMuc2l6ZShieXRlcykgPCAzMilcbiAgICAgICAgdGhyb3cgbmV3IERhdGFTaXplVG9vU21hbGxFcnJvcih7XG4gICAgICAgICAgICBkYXRhOiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSGV4LmZyb21CeXRlcyhkYXRhKSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKGJ5dGVzKSxcbiAgICAgICAgfSk7XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICBjb25zdCB2YWx1ZXMgPSBhcyA9PT0gJ0FycmF5JyA/IFtdIDoge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gcGFyYW1ldGVyc1tpXTtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKGNvbnN1bWVkKTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBpbnRlcm5hbC5kZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgIGlmIChhcyA9PT0gJ0FycmF5JylcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGRhdGEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0ubmFtZSA/PyBpXSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgcHJpbWl0aXZlIHZhbHVlcyBpbnRvIEFCSSBlbmNvZGVkIGRhdGEgYXMgcGVyIHRoZSBbQXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAoQUJJKSBTcGVjaWZpY2F0aW9uXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvYWJpLXNwZWMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShcbiAqICAgQWJpUGFyYW1ldGVycy5mcm9tKFsnc3RyaW5nJywgJ3VpbnQnLCAnYm9vbCddKSxcbiAqICAgWyd3YWdtaScsIDQyMG4sIHRydWVdLFxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIFBhcmFtZXRlcnNcbiAqXG4gKiBTcGVjaWZ5ICoqSlNPTiBBQkkqKiBQYXJhbWV0ZXJzIGFzIHNjaGVtYTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShcbiAqICAgW1xuICogICAgIHsgdHlwZTogJ3N0cmluZycsIG5hbWU6ICduYW1lJyB9LFxuICogICAgIHsgdHlwZTogJ3VpbnQnLCBuYW1lOiAnYWdlJyB9LFxuICogICAgIHsgdHlwZTogJ2Jvb2wnLCBuYW1lOiAnaXNPd25lcicgfSxcbiAqICAgXSxcbiAqICAgWyd3YWdtaScsIDQyMG4sIHRydWVdLFxuICogKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIEFCSSBwYXJhbWV0ZXJzIHRvIGVuY29kZSwgaW4gdGhlIHNoYXBlIG9mIHRoZSBgaW5wdXRzYCBvciBgb3V0cHV0c2AgYXR0cmlidXRlIG9mIGFuIEFCSSBJdGVtLiBUaGVzZSBwYXJhbWV0ZXJzIG11c3QgaW5jbHVkZSB2YWxpZCBbQUJJIHR5cGVzXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvdHlwZXMuaHRtbCkuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHNldCBvZiBwcmltaXRpdmUgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgQUJJIHR5cGVzIGRlZmluZWQgaW4gYHBhcmFtZXRlcnNgLlxuICogQHJldHVybnMgQUJJIGVuY29kZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShwYXJhbWV0ZXJzLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHBhcmFtZXRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIC8vIFByZXBhcmUgdGhlIHBhcmFtZXRlcnMgdG8gZGV0ZXJtaW5lIGR5bmFtaWMgdHlwZXMgdG8gZW5jb2RlLlxuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IGludGVybmFsLnByZXBhcmVQYXJhbWV0ZXJzKHtcbiAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gaW50ZXJuYWwuZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJzB4JztcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogRW5jb2RlcyBhbiBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzIHRvIGEgW3BhY2tlZCBBQkkgZW5jb2RpbmddKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYy5odG1sI25vbi1zdGFuZGFyZC1wYWNrZWQtbW9kZSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW5jb2RlZCA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlUGFja2VkKFxuICogICBbJ2FkZHJlc3MnLCAnc3RyaW5nJ10sXG4gKiAgIFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgJ2hlbGxvIHdvcmxkJ10sXG4gKiApXG4gKiAvLyBAbG9nOiAnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0eXBlcyAtIFNldCBvZiBBQkkgdHlwZXMgdG8gcGFjayBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHNldCBvZiBwcmltaXRpdmUgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgQUJJIHR5cGVzIGRlZmluZWQgaW4gYHR5cGVzYC5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHBhY2tlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUGFja2VkKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogdHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGRhdGEucHVzaChlbmNvZGVQYWNrZWQuZW5jb2RlKHR5cGUsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBIZXguY29uY2F0KC4uLmRhdGEpO1xufVxuKGZ1bmN0aW9uIChlbmNvZGVQYWNrZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgIGZ1bmN0aW9uIGVuY29kZSh0eXBlLCB2YWx1ZSwgaXNBcnJheSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRMZWZ0KGFkZHJlc3MudG9Mb3dlckNhc2UoKSwgaXNBcnJheSA/IDMyIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdieXRlcycpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlID09PSAnYm9vbCcpXG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZExlZnQoSGV4LmZyb21Cb29sZWFuKHZhbHVlKSwgaXNBcnJheSA/IDMyIDogMSk7XG4gICAgICAgIGNvbnN0IGludE1hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5pbnRlZ2VyUmVnZXgpO1xuICAgICAgICBpZiAoaW50TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgYmFzZVR5cGUsIGJpdHMgPSAnMjU2J10gPSBpbnRNYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBOdW1iZXIucGFyc2VJbnQoYml0cywgMTApIC8gODtcbiAgICAgICAgICAgIHJldHVybiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNpemU6IGlzQXJyYXkgPyAzMiA6IHNpemUsXG4gICAgICAgICAgICAgICAgc2lnbmVkOiBiYXNlVHlwZSA9PT0gJ2ludCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlc01hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5ieXRlc1JlZ2V4KTtcbiAgICAgICAgaWYgKGJ5dGVzTWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgc2l6ZV0gPSBieXRlc01hdGNoO1xuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChzaXplLCAxMCkgIT09ICh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZFNpemU6IE51bWJlci5wYXJzZUludChzaXplLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkUmlnaHQodmFsdWUsIGlzQXJyYXkgPyAzMiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmFycmF5UmVnZXgpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBjaGlsZFR5cGVdID0gYXJyYXlNYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goZW5jb2RlKGNoaWxkVHlwZSwgdmFsdWVbaV0sIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJzB4JztcbiAgICAgICAgICAgIHJldHVybiBIZXguY29uY2F0KC4uLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHlwZUVycm9yKHR5cGUpO1xuICAgIH1cbiAgICBlbmNvZGVQYWNrZWQuZW5jb2RlID0gZW5jb2RlO1xufSkoZW5jb2RlUGFja2VkIHx8IChlbmNvZGVQYWNrZWQgPSB7fSkpO1xuLyoqXG4gKiBGb3JtYXRzIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9IGludG8gKipIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyoqLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaVBhcmFtZXRlcnMuZm9ybWF0KFtcbiAqICAge1xuICogICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgIH0sXG4gKiBdKVxuICpcbiAqIGZvcm1hdHRlZFxuICogLy8gICAgXj9cbiAqXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBUaGUgQUJJIFBhcmFtZXRlcnMgdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBBQkkgUGFyYW1ldGVycyAgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xufVxuLyoqXG4gKiBQYXJzZXMgYXJiaXRyYXJ5ICoqSlNPTiBBQkkgUGFyYW1ldGVycyoqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnMqKiBpbnRvIHR5cGVkIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSlNPTiBQYXJhbWV0ZXJzXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKFtcbiAqICAge1xuICogICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgIH0sXG4gKiBdKVxuICpcbiAqIHBhcmFtZXRlcnNcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEh1bWFuIFJlYWRhYmxlIFBhcmFtZXRlcnNcbiAqXG4gKiBIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy5BYmlQYXJhbWV0ZXJzfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQnKVxuICpcbiAqIHBhcmFtZXRlcnNcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBgc3RydWN0YHMgYWxvbmcgd2l0aCB5b3VyIGRlZmluaXRpb25zOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ0ZvbyBmb28sIGFkZHJlc3MgYmFyJyxcbiAqIF0pXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBBQkkgUGFyYW1ldGVycyB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBBQkkgUGFyYW1ldGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20ocGFyYW1ldGVycykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpICYmIHR5cGVvZiBwYXJhbWV0ZXJzWzBdID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycyA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4gcGFyYW1ldGVycztcbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gdGhlIGRhdGEgc2l6ZSBpcyB0b28gc21hbGwgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgMiBieXRlc1xuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcjogRGF0YSBzaXplIG9mIDIgYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLlxuICogLy8gQGVycm9yOiBQYXJhbXM6ICh1aW50MjU2KVxuICogLy8gQGVycm9yOiBEYXRhOiAgIDB4MDEwZiAoMiBieXRlcylcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSB2YWxpZCBkYXRhIHNpemUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgMzIgYnl0ZXNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRGF0YVNpemVUb29TbWFsbEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhLCBwYXJhbWV0ZXJzLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBEYXRhIHNpemUgb2YgJHtzaXplfSBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFBhcmFtczogKCR7YWJpdHlwZS5mb3JtYXRBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpfSlgLFxuICAgICAgICAgICAgICAgIGBEYXRhOiAgICR7ZGF0YX0gKCR7c2l6ZX0gYnl0ZXMpYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gemVybyBkYXRhIGlzIHByb3ZpZGVkLCBidXQgZGF0YSBpcyBleHBlY3RlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweCcpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4p2MIHplcm8gZGF0YVxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcjogRGF0YSBzaXplIG9mIDIgYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLlxuICogLy8gQGVycm9yOiBQYXJhbXM6ICh1aW50MjU2KVxuICogLy8gQGVycm9yOiBEYXRhOiAgIDB4MDEwZiAoMiBieXRlcylcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgdmFsaWQgZGF0YS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSAzMiBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBaZXJvRGF0YUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdDYW5ub3QgZGVjb2RlIHplcm8gZGF0YSAoXCIweFwiKSB3aXRoIEFCSSBwYXJhbWV0ZXJzLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5aZXJvRGF0YUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgndWludDI1NlszXScpLCBbWzY5biwgNDIwbl1dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSBleHBlY3RlZDogMyAg4oaRIOKdjCBsZW5ndGg6IDJcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3I6IEFCSSBlbmNvZGluZyBhcnJheSBsZW5ndGggbWlzbWF0Y2hcbiAqIC8vIEBlcnJvcjogZm9yIHR5cGUgYHVpbnQyNTZbM11gLiBFeHBlY3RlZDogYDNgLiBHaXZlbjogYDJgLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhbiBhcnJheSBvZiB0aGUgY29ycmVjdCBsZW5ndGguXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsndWludDI1NlszXSddKSwgW1s2OW4sIDQyMG4sIDY5bl1dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIGxlbmd0aDogM1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgQXJyYXkgbGVuZ3RoIG1pc21hdGNoIGZvciB0eXBlIFxcYCR7dHlwZX1cXGAuIEV4cGVjdGVkOiBcXGAke2V4cGVjdGVkTGVuZ3RofVxcYC4gR2l2ZW46IFxcYCR7Z2l2ZW5MZW5ndGh9XFxgLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHNpemUgb2YgdGhlIGJ5dGVzIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2J5dGVzOCcpLCBbWycweGRlYWRiZWVmZGVhZGJlZWZkZWFkYmVlZiddXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgZXhwZWN0ZWQ6IDggYnl0ZXMgIOKGkSDinYwgc2l6ZTogMTIgYnl0ZXNcbiAqIC8vIEBlcnJvcjogQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcjogU2l6ZSBvZiBieXRlcyBcIjB4ZGVhZGJlZWZkZWFkYmVlZmRlYWRiZWVmXCJcbiAqIC8vIEBlcnJvcjogKGJ5dGVzMTIpIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHNpemUgKGJ5dGVzOCkuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGEgYnl0ZXMgdmFsdWUgb2YgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWydieXRlczgnXSksIFsnMHhkZWFkYmVlZmRlYWRiZWVmJ10pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIHNpemU6IDggYnl0ZXNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRTaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBvZiBieXRlcyBcIiR7dmFsdWV9XCIgKGJ5dGVzJHtIZXguc2l6ZSh2YWx1ZSl9KSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBzaXplIChieXRlcyR7ZXhwZWN0ZWRTaXplfSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGxlbmd0aCBvZiB0aGUgdmFsdWVzIHRvIGVuY29kZSBkb2VzIG5vdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBBQkkgcGFyYW1ldGVycy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsnc3RyaW5nJywgJ3VpbnQyNTYnXSksIFsnaGVsbG8nXSlcbiAqIC8vIEBlcnJvcjogTGVuZ3RoTWlzbWF0Y2hFcnJvcjogQUJJIGVuY29kaW5nIHBhcmFtcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoLlxuICogLy8gQGVycm9yOiBFeHBlY3RlZCBsZW5ndGggKHBhcmFtcyk6IDJcbiAqIC8vIEBlcnJvcjogR2l2ZW4gbGVuZ3RoICh2YWx1ZXMpOiAxXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIHRoZSBjb3JyZWN0IG51bWJlciBvZiB2YWx1ZXMgdG8gZW5jb2RlLlxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSBbdmFsaWQgQUJJIHR5cGVdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2RldmVsb3AvYWJpLXNwZWMuaHRtbCN0eXBlcykuXG4gKi9cbmV4cG9ydCBjbGFzcyBMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIH0pIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgJ0FCSSBlbmNvZGluZyBwYXJhbWV0ZXJzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guJyxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBsZW5ndGggKHBhcmFtZXRlcnMpOiAke2V4cGVjdGVkTGVuZ3RofWAsXG4gICAgICAgICAgICBgR2l2ZW4gbGVuZ3RoICh2YWx1ZXMpOiAke2dpdmVuTGVuZ3RofWAsXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5MZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYSB2YWxpZCBhcnJheSBhcyBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsndWludDI1NlszXSddKSwgWzY5XSlcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYW4gYXJyYXkgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJyYXlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBub3QgYSB2YWxpZCBhcnJheS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gdGhlIEFCSSBwYXJhbWV0ZXIgdHlwZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICdsb2wnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgaW52YWxpZCB0eXBlXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcjogVHlwZSBgbG9sYCBpcyBub3QgYSB2YWxpZCBBQkkgVHlwZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFR5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgc3VwZXIoYFR5cGUgXFxgJHt0eXBlfVxcYCBpcyBub3QgYSB2YWxpZCBBQkkgVHlwZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"(action-browser)/./node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"(action-browser)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nfunction checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address))\n        return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (optionally checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: true\n * })\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nfunction isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nclass InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nclass InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nclass InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNFO0FBQ0E7QUFDSjtBQUNVO0FBQzVDLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSxnREFBZTtBQUN2QixlQUFlLGdEQUFlO0FBQzlCLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsaUJBQWlCLCtDQUFjLENBQUMsaURBQWdCLGdCQUFnQixhQUFhO0FBQzdFO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDLElBQUksZ0RBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHlCQUF5QjtBQUNoRztBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ08sOENBQThDO0FBQ3JELG9CQUFvQiwrQ0FBYyxNQUFNLGdEQUFlLHFCQUFxQjtBQUM1RSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIsZUFBZTtBQUN0Qyx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUMsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQixnQkFBZ0I7QUFDbEMsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsaURBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyxpREFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWRkcmVzcy5qcz9lMjYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgQ2FjaGVzIGZyb20gJy4vQ2FjaGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBQdWJsaWNLZXkgZnJvbSAnLi9QdWJsaWNLZXkuanMnO1xuY29uc3QgYWRkcmVzc1JlZ2V4ID0gL14weFthLWZBLUYwLTldezQwfSQvO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5hc3NlcnQoJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmFzc2VydCgnMHhkZWFkYmVlZicpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRBZGRyZXNzRXJyb3I6IEFkZHJlc3MgXCIweGRlYWRiZWVmXCIgaXMgaW52YWxpZC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGFzc2VydCBpZiBpdCBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFzc2VydGlvbiBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhZGRyZXNzUmVnZXgudGVzdCh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkSW5wdXRFcnJvcigpLFxuICAgICAgICB9KTtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGNoZWNrc3VtKHZhbHVlKSAhPT0gdmFsdWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdmFsdWUsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkQ2hlY2tzdW1FcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY2hlY2tzdW0gYWRkcmVzcyBmb3IgdGhlIGdpdmVuIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuY2hlY2tzdW0oJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScpXG4gKiAvLyBAbG9nOiAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBjb21wdXRlIHRoZSBjaGVja3N1bSBmb3IuXG4gKiBAcmV0dXJucyBUaGUgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBpZiAoQ2FjaGVzLmNoZWNrc3VtLmhhcyhhZGRyZXNzKSlcbiAgICAgICAgcmV0dXJuIENhY2hlcy5jaGVja3N1bS5nZXQoYWRkcmVzcyk7XG4gICAgYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBjb25zdCBoZXhBZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNoID0gSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhoZXhBZGRyZXNzKSwgeyBhczogJ0J5dGVzJyB9KTtcbiAgICBjb25zdCBjaGFyYWN0ZXJzID0gaGV4QWRkcmVzcy5zcGxpdCgnJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChoYXNoW2kgPj4gMV0gPj4gNCA+PSA4ICYmIGNoYXJhY3RlcnNbaV0pIHtcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbaV0gPSBjaGFyYWN0ZXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoW2kgPj4gMV0gJiAweDBmKSA+PSA4ICYmIGNoYXJhY3RlcnNbaSArIDFdKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2kgKyAxXSA9IGNoYXJhY3RlcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYDB4JHtjaGFyYWN0ZXJzLmpvaW4oJycpfWA7XG4gICAgQ2FjaGVzLmNoZWNrc3VtLnNldChhZGRyZXNzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5naWZpZWQgYWRkcmVzcyB0byBhIHR5cGVkIChvcHRpb25hbGx5IGNoZWNrc3VtbWVkKSB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScpXG4gKiAvLyBAbG9nOiAnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5mcm9tKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnLCB7XG4gKiAgIGNoZWNrc3VtOiB0cnVlXG4gKiB9KVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnaGVsbG8nKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhhXCIgaXMgaW52YWxpZC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQW4gYWRkcmVzcyBzdHJpbmcgdG8gY29udmVydCB0byBhIHR5cGVkIEFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBBZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtOiBjaGVja3N1bVZhbCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGFzc2VydChhZGRyZXNzKTtcbiAgICBpZiAoY2hlY2tzdW1WYWwpXG4gICAgICAgIHJldHVybiBjaGVja3N1bShhZGRyZXNzKTtcbiAgICByZXR1cm4gYWRkcmVzcztcbn1cbi8qKlxuICogQ29udmVydHMgYW4gRUNEU0EgcHVibGljIGtleSB0byBhbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MsIFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKFxuICogICAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JyxcbiAqIClcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVibGljS2V5KVxuICogLy8gQGxvZzogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgRUNEU0EgcHVibGljIGtleSB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb252ZXJzaW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30gY29ycmVzcG9uZGluZyB0byB0aGUgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXkocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gSGFzaC5rZWNjYWsyNTYoYDB4JHtQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSg0KX1gKS5zdWJzdHJpbmcoMjYpO1xuICAgIHJldHVybiBmcm9tKGAweCR7YWRkcmVzc31gLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfSBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5pc0VxdWFsKFxuICogICAnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJyxcbiAqICAgJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIClcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuaXNFcXVhbChcbiAqICAgJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsXG4gKiAgICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWYnXG4gKiApXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3NBIC0gVGhlIGZpcnN0IGFkZHJlc3MgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBhZGRyZXNzQiAtIFRoZSBzZWNvbmQgYWRkcmVzcyB0byBjb21wYXJlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYWRkcmVzc2VzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYWRkcmVzc0EsIGFkZHJlc3NCKSB7XG4gICAgYXNzZXJ0KGFkZHJlc3NBLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgYXNzZXJ0KGFkZHJlc3NCLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3NBLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3NCLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYWRkcmVzcyBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MudmFsaWRhdGUoJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ2hlY2sgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHgxMjMnKVxuICogLy8gQGVycm9yOiBBZGRyZXNzLkludmFsaWRBZGRyZXNzRXJyb3I6IEFkZHJlc3MgYDB4MTIzYCBpcyBpbnZhbGlkLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhZGRyZXNzLCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCwge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnB1dEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGlzIG5vdCBhIDIwIGJ5dGUgKDQwIGhleGFkZWNpbWFsIGNoYXJhY3RlcikgdmFsdWUuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBZGRyZXNzLkludmFsaWRJbnB1dEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBkb2VzIG5vdCBtYXRjaCBpdHMgY2hlY2tzdW0gY291bnRlcnBhcnQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZENoZWNrc3VtRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0FkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQ2hlY2tzdW1FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(action-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(action-browser)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === '0x' ? 0 : Number(chainId),\n        nonce: nonce === '0x' ? 0n : BigInt(nonce),\n    };\n    if (yParity && r && s)\n        args = { ...args, ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([yParity, r, s]) };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization, { presign: true });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nfunction hash(authorization, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat('0x05', _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign\n        ? {\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: authorization.nonce,\n        }\n        : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nfunction toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : '0x',\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : '0x',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nfunction toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDRjtBQUNBO0FBQ1k7QUFDNUM7QUFDQSxzR0FBc0cscUNBQXFDO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhCQUE4QjtBQUNwQywwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3REO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEIsT0FBTyxxQ0FBcUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ087QUFDUCxZQUFZLDBCQUEwQjtBQUN0QyxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDLE9BQU8sNEJBQTRCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QixPQUFPLHFDQUFxQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksb0RBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsT0FBTyw0QkFBNEI7QUFDckY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBLHFFQUFxRSxxQ0FBcUM7QUFDMUcsaURBQWlELG1DQUFtQztBQUNwRjtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBLDZCQUE2QixzQ0FBc0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNPLHlDQUF5QztBQUNoRCxZQUFZLFVBQVU7QUFDdEIsV0FBVywrQ0FBYyxDQUFDLDJDQUFVLFNBQVMsNENBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0MsT0FBTywyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFjO0FBQy9CLGVBQWUsK0NBQWM7QUFDN0IsV0FBVyxnREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCLE9BQU8sK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQyxPQUFPLDZCQUE2QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNPO0FBQ1AsWUFBWSwwQkFBMEI7QUFDdEMsc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBLGtCQUFrQiwrQ0FBYztBQUNoQztBQUNBLGdCQUFnQiwrQ0FBYztBQUM5Qix3QkFBd0Isa0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkIsT0FBTyxpQ0FBaUM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanM/YTA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIEFuIEF1dGhvcml6YXRpb24gY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGNhbiBiZSBhdHRhY2hlZCB3aXRoIHRoZSBgc2lnbmF0dXJlYCBvcHRpb24uIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBzaWduaW5nXG4gKiBhbiBBdXRob3JpemF0aW9uIHdpdGgge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmUgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBdXRob3JpemF0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvbi5jaGFpbklkID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIHsgLi4uYXV0aG9yaXphdGlvbiwgLi4ub3B0aW9ucy5zaWduYXR1cmUgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEJpZ0ludChub25jZSksXG4gICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVJwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIFRoZSBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24gbGlzdC5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKGZyb21ScGMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgJzB4MScsXG4gKiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAnMHgzJ1xuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXBwZW5kIGEgU2lnbmF0dXJlIHR1cGxlIHRvIHRoZSBlbmQgb2YgYW4gQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MycsXG4gKiAgICcweDEnLFxuICogICAnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyxcbiAqICAgJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcsXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbY2hhaW5JZCwgYWRkcmVzcywgbm9uY2UsIHlQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgbGV0IGFyZ3MgPSB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IGNoYWluSWQgPT09ICcweCcgPyAwIDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogbm9uY2UgPT09ICcweCcgPyAwbiA6IEJpZ0ludChub25jZSksXG4gICAgfTtcbiAgICBpZiAoeVBhcml0eSAmJiByICYmIHMpXG4gICAgICAgIGFyZ3MgPSB7IC4uLmFyZ3MsIC4uLlNpZ25hdHVyZS5mcm9tVHVwbGUoW3lQYXJpdHksIHIsIHNdKSB9O1xuICAgIHJldHVybiBmcm9tKGFyZ3MpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZUxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGVMaXN0KFtcbiAqICAgWycweDEnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MyddLFxuICogICBbJzB4MycsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgxNCddLFxuICogXSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDNuLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMyxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogMjBuLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXBwZW5kIGEgU2lnbmF0dXJlIHR1cGxlIHRvIHRoZSBlbmQgb2YgYW4gQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGVMaXN0KFtcbiAqICAgWycweDEnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MycsICcweDEnLCAnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJywgJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCddLFxuICogICBbJzB4MycsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgxNCcsICcweDEnLCAnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJywgJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCddLFxuICogXSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDNuLFxuICogLy8gQGxvZzogICAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgICAgczogQmlnSW50KCcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnKSxcbiAqIC8vIEBsb2c6ICAgICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMyxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogMjBuLFxuICogLy8gQGxvZzogICAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgICAgczogQmlnSW50KCcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnKSxcbiAqIC8vIEBsb2c6ICAgICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlTGlzdCAtIFRoZSBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBsaXN0LlxuICogQHJldHVybnMgQW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGVMaXN0KHR1cGxlTGlzdCkge1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHR1cGxlIG9mIHR1cGxlTGlzdClcbiAgICAgICAgbGlzdC5wdXNoKGZyb21UdXBsZSh0dXBsZSkpO1xuICAgIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2lnbiBwYXlsb2FkIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBjb21wdXRpbmcgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uIFRoaXMgcGF5bG9hZFxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHNpZ25pbmcgZnVuY3Rpb25zIGxpa2Uge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikge1xuICAgIHJldHVybiBoYXNoKGF1dGhvcml6YXRpb24sIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGhhc2ggZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBBdXRob3JpemF0aW9uLmhhc2goYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKiBAcmV0dXJucyBUaGUgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goYXV0aG9yaXphdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVzaWduIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguY29uY2F0KCcweDA1JywgUmxwLmZyb21IZXgodG9UdXBsZShwcmVzaWduXG4gICAgICAgID8ge1xuICAgICAgICAgICAgYWRkcmVzczogYXV0aG9yaXphdGlvbi5hZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZDogYXV0aG9yaXphdGlvbi5jaGFpbklkLFxuICAgICAgICAgICAgbm9uY2U6IGF1dGhvcml6YXRpb24ubm9uY2UsXG4gICAgICAgIH1cbiAgICAgICAgOiBhdXRob3JpemF0aW9uKSkpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMW4sXG4gKiAgIHI6IDQ0OTQ0NjI3ODEzMDA3NzcyODk3MzkxNTMxMjMwMDgxNjk1MTAyNzAzMjg5MTIzMzMyMTg3Njk2MTE1MTgxMTA0NzM5MjM5MTk3NTE3bixcbiAqICAgczogMzY1Mjg1MDM1MDUxOTI0MzgzMDczNTUxNjQ0NDExMDQwMDEzMTA1NjY1MDUzNTE5ODAzNjkwODUyMDgxNzg3MTI2Nzg3OTkxODExMjBuLFxuICogICB5UGFyaXR5OiAwLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gQXV0aG9yaXphdGlvbi5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCAuLi5zaWduYXR1cmUgfSA9IGF1dGhvcml6YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBIZXguZnJvbU51bWJlcihub25jZSksXG4gICAgICAgIC4uLlNpZ25hdHVyZS50b1JwYyhzaWduYXR1cmUpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3RScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLnRvUnBjTGlzdChbe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH1dKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25MaXN0IC0gQW4gQXV0aG9yaXphdGlvbiBMaXN0LlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uIExpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKHRvUnBjKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgdHVwbGUgPSBBdXRob3JpemF0aW9uLnRvVHVwbGUoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDY5bixcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGNoYWluSWQgPyBIZXguZnJvbU51bWJlcihjaGFpbklkKSA6ICcweCcsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIG5vbmNlID8gSGV4LmZyb21OdW1iZXIobm9uY2UpIDogJzB4JyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGVMaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uXzEgPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uXzIgPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMyxcbiAqICAgbm9uY2U6IDIwbixcbiAqIH0pXG4gKlxuICogY29uc3QgdHVwbGUgPSBBdXRob3JpemF0aW9uLnRvVHVwbGVMaXN0KFthdXRob3JpemF0aW9uXzEsIGF1dGhvcml6YXRpb25fMl0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgW1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDY5bixcbiAqIC8vIEBsb2c6ICAgXSxcbiAqIC8vIEBsb2c6ICAgW1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgXSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsaXN0IC0gQW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKiBAcmV0dXJucyBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZUxpc3QobGlzdCkge1xuICAgIGlmICghbGlzdCB8fCBsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlTGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBsaXN0KVxuICAgICAgICB0dXBsZUxpc3QucHVzaCh0b1R1cGxlKGF1dGhvcml6YXRpb24pKTtcbiAgICByZXR1cm4gdHVwbGVMaXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Authorization.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"(action-browser)/./node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmxvY2tPdmVycmlkZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnQztBQUNjO0FBQzlDO0FBQ0EsZ0JBQWdCLDZCQUE2QixPQUFPLHVDQUF1QztBQUMzRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkRBQTJELG1EQUFrQjtBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QyxPQUFPLDRCQUE0QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQiwrQ0FBYztBQUN6QyxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsK0NBQWM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQkFBc0IsK0NBQWM7QUFDcEMsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLCtDQUFjO0FBQ2xDLFNBQVM7QUFDVDtBQUNBLHdCQUF3QiwrQ0FBYztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsK0NBQWM7QUFDaEMsU0FBUztBQUNUO0FBQ0Esd0RBQXdELGlEQUFnQjtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmxvY2tPdmVycmlkZXMuanM/NTQwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgV2l0aGRyYXdhbCBmcm9tICcuL1dpdGhkcmF3YWwuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfSB0byBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuQmxvY2tPdmVycmlkZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvY2tPdmVycmlkZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBibG9ja092ZXJyaWRlcyA9IEJsb2NrT3ZlcnJpZGVzLmZyb21ScGMoe1xuICogICBiYXNlRmVlUGVyR2FzOiAnMHgxJyxcbiAqICAgYmxvYkJhc2VGZWU6ICcweDInLFxuICogICBmZWVSZWNpcGllbnQ6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBnYXNMaW1pdDogJzB4NCcsXG4gKiAgIG51bWJlcjogJzB4NScsXG4gKiAgIHByZXZSYW5kYW86ICcweDYnLFxuICogICB0aW1lOiAnMHgxMjM0NTY3ODkwJyxcbiAqICAgd2l0aGRyYXdhbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGFtb3VudDogJzB4MScsXG4gKiAgICAgICBpbmRleDogJzB4MCcsXG4gKiAgICAgICB2YWxpZGF0b3JJbmRleDogJzB4MScsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcnBjQmxvY2tPdmVycmlkZXMgLSBUaGUgUlBDIGJsb2NrIG92ZXJyaWRlcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHJwY0Jsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgJiYge1xuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0KSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5udW1iZXIgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvICYmIHtcbiAgICAgICAgICAgIHByZXZSYW5kYW86IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy50aW1lICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy50aW1lKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XG4gICAgICAgICAgICB3aXRoZHJhd2FsczogcnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKFdpdGhkcmF3YWwuZnJvbVJwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30gdG8gYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9ja092ZXJyaWRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrT3ZlcnJpZGVzID0gQmxvY2tPdmVycmlkZXMudG9ScGMoe1xuICogICBiYXNlRmVlUGVyR2FzOiAxbixcbiAqICAgYmxvYkJhc2VGZWU6IDJuLFxuICogICBmZWVSZWNpcGllbnQ6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBnYXNMaW1pdDogNG4sXG4gKiAgIG51bWJlcjogNW4sXG4gKiAgIHByZXZSYW5kYW86IDZuLFxuICogICB0aW1lOiA3ODE4NzQ5MzUyMG4sXG4gKiAgIHdpdGhkcmF3YWxzOiBbXG4gKiAgICAge1xuICogICAgICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgICBhbW91bnQ6IDFuLFxuICogICAgICAgaW5kZXg6IDAsXG4gKiAgICAgICB2YWxpZGF0b3JJbmRleDogMSxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBibG9ja092ZXJyaWRlcyAtIFRoZSBibG9jayBvdmVycmlkZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGJsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCA9PT0gJ3N0cmluZycgJiYge1xuICAgICAgICAgICAgZmVlUmVjaXBpZW50OiBibG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0ID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5udW1iZXIgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIG51bWJlcjogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgcHJldlJhbmRhbzogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLnRpbWUgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnRpbWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzICYmIHtcbiAgICAgICAgICAgIHdpdGhkcmF3YWxzOiBibG9ja092ZXJyaWRlcy53aXRoZHJhd2Fscy5tYXAoV2l0aGRyYXdhbC50b1JwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9ja092ZXJyaWRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(action-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(action-browser)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = (nibbleLeft << 4) | nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ3BCO0FBQ047QUFDZ0I7QUFDRTtBQUNoQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ08sd0NBQXdDO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0IsWUFBWSxxQkFBcUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDTyxvQ0FBb0M7QUFDM0MsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxRQUFRLHdEQUF1QjtBQUMvQixjQUFjLDZDQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DLDJCQUEyQixnRUFBeUI7QUFDcEQsNEJBQTRCLGdFQUF5QjtBQUNyRDtBQUNBLHNCQUFzQixpREFBZ0IsNEJBQTRCLGlCQUFpQixFQUFFLGlCQUFpQixRQUFRLFVBQVU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNPO0FBQ1AsZ0JBQWdCLCtDQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDTyx1Q0FBdUM7QUFDOUMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxRQUFRLDBEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ087QUFDUCxXQUFXLHdFQUFVO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsa0NBQWtDLHNCQUFzQjtBQUN4RCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ087QUFDUCxXQUFXLG1EQUFZLFVBQVUsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsa0NBQWtDLHNCQUFzQjtBQUN4RCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ087QUFDUCxXQUFXLG1EQUFZLFVBQVUsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qyx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDTyw4Q0FBOEM7QUFDckQsWUFBWSxTQUFTO0FBQ3JCLElBQUksaUVBQTBCO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLCtEQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ08scUNBQXFDO0FBQzVDLFlBQVksT0FBTztBQUNuQjtBQUNBLFFBQVEsMERBQW1CO0FBQzNCLGdCQUFnQiw4Q0FBYTtBQUM3QixXQUFXLDZDQUFZO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsUUFBUSwwREFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQixjQUFjLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ08sa0NBQWtDO0FBQ3pDLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUNBQXFDO0FBQzVDLFlBQVksT0FBTztBQUNuQjtBQUNBLFFBQVEsMERBQW1CO0FBQzNCLGdCQUFnQiw4Q0FBYTtBQUM3QixXQUFXLDZDQUFZO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ08scUNBQXFDO0FBQzVDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsUUFBUSwwREFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDTztBQUNQLFdBQVcsb0RBQWEsVUFBVSxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QyxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ087QUFDUCxXQUFXLG9EQUFhLFVBQVUsY0FBYztBQUNoRDtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGlEQUFnQjtBQUM5RDtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyxpREFBZ0I7QUFDM0Q7QUFDQSx5QkFBeUIsNEJBQTRCLCtDQUFjLGdCQUFnQixlQUFlLGFBQWE7QUFDL0c7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpREFBZ0I7QUFDdkQsa0JBQWtCLG9CQUFvQjtBQUN0QyxzQ0FBc0MsUUFBUSwwQkFBMEIsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsdUJBQXVCLDhDQUE4QyxjQUFjLE9BQU8sK0JBQStCLEtBQUs7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLGlCQUFpQiw2QkFBNkIsRUFBRTtBQUNoRDtBQUNBLDRCQUE0QixVQUFVLEtBQUssOEJBQThCLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qcz81YTc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9oZXggZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEJ5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYFVpbnQ4QXJyYXlgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoISgnQllURVNfUEVSX0VMRU1FTlQnIGluIHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSAxIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVaW50OEFycmF5JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBmcm9tIGEgYFVpbnQ4QXJyYXlgLCBhIGhleCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEJ5dGVzLmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21TdHJpbmdgXG4gKlxuICogLSBgQnl0ZXMuZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIyMiwgMTczLCAxOTAsIDIzOV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VycyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBCb29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcbiAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGogPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBuaWJibGVMZWZ0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgY29uc3QgbmliYmxlUmlnaHQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpbmRleF0gPSAobmliYmxlTGVmdCA8PCA0KSB8IG5pYmJsZVJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSBudW1iZXIgdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAxNjRdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiA0IH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAxLCAxNjRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZyb21IZXgoaGV4KTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIHdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzMywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlcyBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogQnl0ZXMuaXNFcXVhbChCeXRlcy5mcm9tKFsxXSksIEJ5dGVzLmZyb20oWzJdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXNBIC0gRmlyc3Qge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEBwYXJhbSBieXRlc0IgLSBTZWNvbmQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHZhbHVlcyBhcmUgZXF1YWwsIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChieXRlc0EsIGJ5dGVzQikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKGJ5dGVzQSwgYnl0ZXNCKTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIGxlZnQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRMZWZ0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRMZWZ0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdsZWZ0Jywgc2l6ZSB9KTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkUmlnaHQoQnl0ZXMuZnJvbShbMV0pLCA0KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gU2l6ZSB0byBwYWQgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8uXG4gKiBAcmV0dXJucyBQYWRkZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYnl0ZXMgPSBCeXRlcy5yYW5kb20oMzIpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsuLi4geDMyXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsZW5ndGggLSBMZW5ndGggb2YgdGhlIHJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSk7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNpemUoQnl0ZXMuZnJvbShbMSwgMiwgMywgNF0pKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFNpemUgb2YgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoXG4gKiAgIEJ5dGVzLmZyb20oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldKSxcbiAqICAgMSxcbiAqICAgNCxcbiAqIClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIsIDMsIDRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBvZmZzZXQuXG4gKiBAcGFyYW0gZW5kIC0gRW5kIG9mZnNldC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gU2xpY2Ugb3B0aW9ucy5cbiAqIEByZXR1cm5zIFNsaWNlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJpZ2ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9CaWdJbnQoQnl0ZXMuZnJvbShbMSwgMTY0XSkpXG4gKiAvLyBAbG9nOiA0MjBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJpZ2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b0JpZ0ludChoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzFdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRGVjb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQm9vbGVhbihieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlc18gPSBieXRlcztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXNfLCBzaXplKTtcbiAgICAgICAgYnl0ZXNfID0gdHJpbUxlZnQoYnl0ZXNfKTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzXy5sZW5ndGggPiAxIHx8IGJ5dGVzX1swXSA+IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IoYnl0ZXNfKTtcbiAgICByZXR1cm4gQm9vbGVhbihieXRlc19bMF0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0hleChCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9OdW1iZXIoQnl0ZXMuZnJvbShbMSwgMTY0XSkpXG4gKiAvLyBAbG9nOiA0MjBcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvTnVtYmVyKGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy50b1N0cmluZyhCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1SaWdodChieXRlc18pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnl0ZXNfKTtcbn1cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudHJpbUxlZnQoQnl0ZXMuZnJvbShbMCwgMCwgMCwgMCwgMSwgMiwgM10pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbi8qKlxuICogVHJpbXMgdHJhaWxpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1SaWdodChCeXRlcy5mcm9tKFsxLCAyLCAzLCAwLCAwLCAwLCAwXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBUcmltbWVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoQnl0ZXMuZnJvbShbMSwgMiwgM10pKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgYnl0ZXMgdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzVdKSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yOiBCeXRlcyB2YWx1ZSBgWzVdYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLlxuICogLy8gQGVycm9yOiBUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYEJ5dGVzIHZhbHVlIFxcYCR7Ynl0ZXN9XFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBieXRlcyBhcnJheSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgYnl0ZSBvZiBlaXRoZXIgYSBgMGAgb3IgYDFgIHZhbHVlLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbSgnZm9vJylcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yOiBWYWx1ZSBgZm9vYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc1R5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3R5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKc29uLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiB2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnQnl0ZXMgdmFsdWVzIG11c3QgYmUgb2YgdHlwZSBgQnl0ZXNgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzbGljZSBvZmZzZXQgaXMgb3V0LW9mLWJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoQnl0ZXMuZnJvbShbMSwgMiwgM10pLCA0KVxuICogLy8gQGVycm9yOiBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDNgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdGhlIHBhZGRpbmcgc2l6ZSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKSwgOClcbiAqIC8vIEBlcnJvcjogW0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogQnl0ZXMgc2l6ZSAoYDEyYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKGA4YCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192),\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nfunction clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQ2FjaGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUMzQztBQUNBLGdDQUFnQyxvREFBTTtBQUN0QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQ2FjaGVzLmpzPzU5MjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTHJ1TWFwIH0gZnJvbSAnLi9pbnRlcm5hbC9scnUuanMnO1xuY29uc3QgY2FjaGVzID0ge1xuICAgIGNoZWNrc3VtOiAvKiNfX1BVUkVfXyovIG5ldyBMcnVNYXAoODE5MiksXG59O1xuZXhwb3J0IGNvbnN0IGNoZWNrc3VtID0gY2FjaGVzLmNoZWNrc3VtO1xuLyoqXG4gKiBDbGVhcnMgYWxsIGdsb2JhbCBjYWNoZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDYWNoZXMgfSBmcm9tICdveCdcbiAqIENhY2hlcy5jbGVhcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgT2JqZWN0LnZhbHVlcyhjYWNoZXMpKVxuICAgICAgICBjYWNoZS5jbGVhcigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    static setStaticOptions(options) {\n        BaseError.prototype.docsOrigin = options.docsOrigin;\n        BaseError.prototype.showVersion = options.showVersion;\n        BaseError.prototype.version = options.version;\n    }\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = options.docsOrigin ?? BaseError.prototype.docsOrigin;\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const showVersion = Boolean(options.version ?? BaseError.prototype.showVersion);\n        const version = options.version ?? BaseError.prototype.version;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath || showVersion\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                    showVersion ? `Version: ${version}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsOrigin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"showVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsOrigin = docsBaseUrl;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n        this.showVersion = showVersion;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nObject.defineProperty(BaseError, \"defaultStaticOptions\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        docsOrigin: 'https://oxlib.sh',\n        showVersion: false,\n        version: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`,\n    }\n});\n(() => {\n    BaseError.setStaticOptions(BaseError.defaultStaticOptions);\n})();\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvRXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsWUFBWSxFQUFFLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQVUsR0FBRztBQUNwQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcz8yMmQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFZlcnNpb24gfSBmcm9tICcuL2ludGVybmFsL2Vycm9ycy5qcyc7XG4vKipcbiAqIEJhc2UgZXJyb3IgY2xhc3MgaW5oZXJpdGVkIGJ5IGFsbCBlcnJvcnMgdGhyb3duIGJ5IG94LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSAnb3gnXG4gKiB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdGljIHNldFN0YXRpY09wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLmRvY3NPcmlnaW4gPSBvcHRpb25zLmRvY3NPcmlnaW47XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUuc2hvd1ZlcnNpb24gPSBvcHRpb25zLnNob3dWZXJzaW9uO1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLnZlcnNpb24gPSBvcHRpb25zLnZlcnNpb247XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNob3J0TWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5kZXRhaWxzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgJiZcbiAgICAgICAgICAgICAgICAnZGV0YWlscycgaW4gb3B0aW9ucy5jYXVzZSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmNhdXNlLmRldGFpbHMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZT8ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGV0YWlscztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc1BhdGggPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZG9jc1BhdGggfHwgb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzQmFzZVVybCA9IG9wdGlvbnMuZG9jc09yaWdpbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLmRvY3NPcmlnaW47XG4gICAgICAgIGNvbnN0IGRvY3MgPSBgJHtkb2NzQmFzZVVybH0ke2RvY3NQYXRoID8/ICcnfWA7XG4gICAgICAgIGNvbnN0IHNob3dWZXJzaW9uID0gQm9vbGVhbihvcHRpb25zLnZlcnNpb24gPz8gQmFzZUVycm9yLnByb3RvdHlwZS5zaG93VmVyc2lvbik7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gPz8gQmFzZUVycm9yLnByb3RvdHlwZS52ZXJzaW9uO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgICAgc2hvcnRNZXNzYWdlIHx8ICdBbiBlcnJvciBvY2N1cnJlZC4nLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubWV0YU1lc3NhZ2VzID8gWycnLCAuLi5vcHRpb25zLm1ldGFNZXNzYWdlc10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZGV0YWlscyB8fCBkb2NzUGF0aCB8fCBzaG93VmVyc2lvblxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA/IGBEZXRhaWxzOiAke2RldGFpbHN9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZG9jc1BhdGggPyBgU2VlOiAke2RvY3N9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1ZlcnNpb24gPyBgVmVyc2lvbjogJHt2ZXJzaW9ufWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMuY2F1c2UgPyB7IGNhdXNlOiBvcHRpb25zLmNhdXNlIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc09yaWdpblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzUGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvd1ZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQmFzZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMuZG9jc09yaWdpbiA9IGRvY3NCYXNlVXJsO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgICAgICB0aGlzLnNob3dWZXJzaW9uID0gc2hvd1ZlcnNpb247XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIHdhbGsoZm4pIHtcbiAgICAgICAgcmV0dXJuIHdhbGsodGhpcywgZm4pO1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IsIFwiZGVmYXVsdFN0YXRpY09wdGlvbnNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7XG4gICAgICAgIGRvY3NPcmlnaW46ICdodHRwczovL294bGliLnNoJyxcbiAgICAgICAgc2hvd1ZlcnNpb246IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uOiBgb3hAJHtnZXRWZXJzaW9uKCl9YCxcbiAgICB9XG59KTtcbigoKSA9PiB7XG4gICAgQmFzZUVycm9yLnNldFN0YXRpY09wdGlvbnMoQmFzZUVycm9yLmRlZmF1bHRTdGF0aWNPcHRpb25zKTtcbn0pKCk7XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB3YWxrKGVyciwgZm4pIHtcbiAgICBpZiAoZm4/LihlcnIpKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgJ2NhdXNlJyBpbiBlcnIgJiYgZXJyLmNhdXNlKVxuICAgICAgICByZXR1cm4gd2FsayhlcnIuY2F1c2UsIGZuKTtcbiAgICByZXR1cm4gZm4gPyBudWxsIDogZXJyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(action-browser)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(action-browser)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(action-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBdUU7QUFDSjtBQUNMO0FBQzFCO0FBQ0o7QUFDaEM7QUFDQSw4RUFBOEUsc0JBQXNCLElBQUksa0JBQWtCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0IsSUFBSSxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksbURBQW1EO0FBQy9ELGtCQUFrQiw4REFBZSxDQUFDLDJDQUFVO0FBQzVDO0FBQ0E7QUFDQSxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQSwrRUFBK0Usc0JBQXNCLElBQUksa0JBQWtCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0IsSUFBSSxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksbURBQW1EO0FBQy9ELGtCQUFrQixrRUFBZSxDQUFDLDJDQUFVO0FBQzVDO0FBQ0E7QUFDQSxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQSw2RUFBNkUsc0JBQXNCLElBQUksa0JBQWtCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0IsSUFBSSxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksbURBQW1EO0FBQy9ELGtCQUFrQiw0REFBWSxDQUFDLDJDQUFVO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDZDQUFZLFdBQVcseUNBQVE7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanM/ZmE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByaXBlbWQxNjAgYXMgbm9ibGVfcmlwZW1kMTYwIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAnO1xuaW1wb3J0IHsga2VjY2FrXzI1NiBhcyBub2JsZV9rZWNjYWsyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IHsgc2hhMjU2IGFzIG5vYmxlX3NoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgW0tlY2NhazI1Nl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU0hBLTMpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGBrZWNjYWtfMjU2YCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6ICcweGQ0ZmQ0ZTE4OTEzMjI3MzAzNjQ0OWZjOWUxMTE5OGM3MzkxNjFiNGMwMTE2YTlhMmRjY2RmYTFjNDkyMDA2ZjEnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENhbGN1bGF0ZSBIYXNoIG9mIGEgU3RyaW5nXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2gsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpKVxuICogLy8gQGxvZzogJzB4M2VhMmYxZDBhYmYzZmM2NmNmMjllZWJiNzBjYmQ0ZTdmZTc2MmVmOGEwOWJjYzA2YzhlZGY2NDEyMzBhZmVjMCdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ29uZmlndXJlIFJldHVybiBUeXBlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NignMHhkZWFkYmVlZicsIHsgYXM6ICdCeXRlcycgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWy4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgS2VjY2FrMjU2IGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfa2VjY2FrMjU2KEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtSaXBlbWQxNjBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JJUEVNRCkgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYHJpcGVtZDE2MGAgZnJvbSBbYEBub2JsZS9oYXNoZXNgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcyksIGFuIGF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGhhc2hpbmcgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLnJpcGVtZDE2MCgnMHhkZWFkYmVlZicpXG4gKiAvLyAnMHgyMjY4MjFjMmY1NDIzZTExZmU5YWY2OGJkMjg1YzI0OWRiMmU0YjVhJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBSaXBlbWQxNjAgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJpcGVtZDE2MCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9yaXBlbWQxNjAoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgW1NoYTI1Nl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU0hBLTI1NikgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYHNoYTI1NmAgZnJvbSBbYEBub2JsZS9oYXNoZXNgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcyksIGFuIGF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGhhc2hpbmcgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLnNoYTI1NignMHhkZWFkYmVlZicpXG4gKiAvLyAnMHg1Zjc4YzMzMjc0ZTQzZmE5ZGU1NjU5MjY1YzFkOTE3ZTI1YzAzNzIyZGNiMGI4ZDI3ZGI4ZDVmZWFhODEzOTUzJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBTaGEyNTYgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9zaGEyNTYoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGFzaCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLnZhbGlkYXRlKCcweCcpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICpcbiAqIEhhc2gudmFsaWRhdGUoJzB4M2VhMmYxZDBhYmYzZmM2NmNmMjllZWJiNzBjYmQ0ZTdmZTc2MmVmOGEwOWJjYzA2YzhlZGY2NDEyMzBhZmVjMCcpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgSGV4LnNpemUodmFsdWUpID09PSAzMjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(action-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(action-browser)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ3RCO0FBQ0U7QUFDZ0I7QUFDUjtBQUNaO0FBQ2xDO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNPO0FBQ1AsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQiw0QkFBNEIsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qyx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTyx3Q0FBd0M7QUFDL0MscUJBQXFCLGNBQWM7QUFDbkM7QUFDQSxRQUFRLHdEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0IsY0FBYyxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNPLHNDQUFzQztBQUM3QztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBLFFBQVEsd0RBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLE9BQU87QUFDakQsb0JBQW9CLFNBQVMsRUFBRSxPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLE9BQU87QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsNkJBQTZCLGtCQUFrQjtBQUMvQywrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ087QUFDUCxXQUFXLHdFQUFVLENBQUMsOENBQWEsUUFBUSw4Q0FBYTtBQUN4RDtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNPO0FBQ1AsV0FBVyxpREFBWSxVQUFVLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNPO0FBQ1AsV0FBVyxpREFBWSxVQUFVLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDTztBQUNQLHFCQUFxQiw2Q0FBWTtBQUNqQztBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNPLDhDQUE4QztBQUNyRCxZQUFZLFNBQVM7QUFDckIsSUFBSSwrREFBMEI7QUFDOUIsd0JBQXdCO0FBQ3hCO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsUUFBUSw2REFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekMsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekMseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNPO0FBQ1AsV0FBVyxrREFBYSxVQUFVLGFBQWE7QUFDL0M7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTztBQUNQLFdBQVcsa0RBQWEsVUFBVSxjQUFjO0FBQ2hEO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLFNBQVM7QUFDckI7QUFDQSxRQUFRLHdEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFVBQVU7QUFDbkc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDTyxvQ0FBb0M7QUFDM0M7QUFDQSxRQUFRLHdEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0IsY0FBYyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNPLGtDQUFrQztBQUN6QyxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxPQUFPO0FBQ25CLGdCQUFnQiw4Q0FBYTtBQUM3QjtBQUNBLFFBQVEsMERBQXlCO0FBQ2pDLGdCQUFnQixnREFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNPLHFDQUFxQztBQUM1QyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxpREFBZ0I7QUFDNUQsa0JBQWtCLGdDQUFnQztBQUNsRCwwQkFBMEIsTUFBTSxtQkFBbUIsV0FBVyxTQUFTLFdBQVcsRUFBRSxrQ0FBa0MsZ0JBQWdCLFlBQVksSUFBSSxVQUFVLElBQUksbUJBQW1CLElBQUksS0FBSztBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxpREFBZ0I7QUFDNUQ7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RDtBQUNBLHlCQUF5Qiw0QkFBNEIsK0NBQWMsZ0JBQWdCLGVBQWUsYUFBYTtBQUMvRyxtRUFBbUUsT0FBTztBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsaURBQWdCO0FBQzFEO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxpREFBZ0I7QUFDeEQ7QUFDQSw4QkFBOEIsTUFBTSx3QkFBd0Isa0JBQWtCO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsaURBQWdCO0FBQ3ZELGtCQUFrQixvQkFBb0I7QUFDdEMsc0NBQXNDLFFBQVEsMEJBQTBCLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLHVCQUF1Qiw4Q0FBOEMsY0FBYyxPQUFPLCtCQUErQixLQUFLO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyxpQkFBaUIsNkJBQTZCLEVBQUU7QUFDaEQ7QUFDQSw0QkFBNEIsVUFBVSxLQUFLLDhCQUE4QixXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGV4LmpzPzFjZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXF1YWxCeXRlcyB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWxfYnl0ZXMgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGhleGVzID0gLyojX19QVVJFX18qLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF92LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmFzc2VydCgnYWJjJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZEhleFZhbHVlVHlwZUVycm9yOlxuICogLy8gQGVycm9yOiBWYWx1ZSBgXCJhYmNcImAgb2YgdHlwZSBgc3RyaW5nYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLlxuICogLy8gQGVycm9yOiBIZXggdHlwZXMgbXVzdCBiZSByZXByZXNlbnRlZCBhcyBgXCIweFxcJHtzdHJpbmd9XCJgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2VydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmICghL14weFswLTlhLWZBLUZdKiQvLnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKCcweCcpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZXMgdHdvIG9yIG1vcmUge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmNvbmNhdCgnMHgxMjMnLCAnMHg0NTYnKVxuICogLy8gQGxvZzogJzB4MTIzNDU2J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoLi4udmFsdWVzKSB7XG4gICAgcmV0dXJuIGAweCR7dmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4LnJlcGxhY2UoJzB4JywgJycpLCAnJyl9YDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGZyb20gYSBoZXggc3RyaW5nIG9yIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogOjo6dGlwXG4gKlxuICogVG8gaW5zdGFudGlhdGUgZnJvbSBhICoqQm9vbGVhbioqLCAqKlN0cmluZyoqLCBvciAqKk51bWJlcioqLCB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogLSBgSGV4LmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEhleC5mcm9tU3RyaW5nYFxuICpcbiAqIC0gYEhleC5mcm9tTnVtYmVyYFxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMScpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKlxuICogSGV4LmZyb20oQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgYm9vbGVhbiBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiAnMHgxJ1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbihmYWxzZSlcbiAqIC8vIEBsb2c6ICcweDAnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKHRydWUsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYm9vbGVhbiB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQm9vbGVhbih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaGV4ID0gYDB4JHtOdW1iZXIodmFsdWUpfWA7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgICAgICByZXR1cm4gcGFkTGVmdChoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21CeXRlcyhCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0cmluZyArPSBoZXhlc1t2YWx1ZVtpXV07XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmd9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEVuY29kZXMgYSBudW1iZXIgb3IgYmlnaW50IGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjApXG4gKiAvLyBAbG9nOiAnMHgxYTQnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciBvciBiaWdpbnQgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWVfID0gQmlnSW50KHZhbHVlKTtcbiAgICBsZXQgbWF4VmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaWYgKHNpZ25lZClcbiAgICAgICAgICAgIG1heFZhbHVlID0gKDFuIDw8IChCaWdJbnQoc2l6ZSkgKiA4biAtIDFuKSkgLSAxbjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAybiAqKiAoQmlnSW50KHNpemUpICogOG4pIC0gMW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWF4VmFsdWUgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIH1cbiAgICBjb25zdCBtaW5WYWx1ZSA9IHR5cGVvZiBtYXhWYWx1ZSA9PT0gJ2JpZ2ludCcgJiYgc2lnbmVkID8gLW1heFZhbHVlIC0gMW4gOiAwO1xuICAgIGlmICgobWF4VmFsdWUgJiYgdmFsdWVfID4gbWF4VmFsdWUpIHx8IHZhbHVlXyA8IG1pblZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJztcbiAgICAgICAgdGhyb3cgbmV3IEludGVnZXJPdXRPZlJhbmdlRXJyb3Ioe1xuICAgICAgICAgICAgbWF4OiBtYXhWYWx1ZSA/IGAke21heFZhbHVlfSR7c3VmZml4fWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtaW46IGAke21pblZhbHVlfSR7c3VmZml4fWAsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgdmFsdWU6IGAke3ZhbHVlfSR7c3VmZml4fWAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IChzaWduZWQgJiYgdmFsdWVfIDwgMCA/IEJpZ0ludC5hc1VpbnROKHNpemUgKiA4LCBCaWdJbnQodmFsdWVfKSkgOiB2YWx1ZV8pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XG4gICAgaWYgKHNpemUpXG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJylcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhlbmNvZGVyLmVuY29kZSh2YWx1ZSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGVhZGJlZWYnLCAnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGEnLCAnMHhiYScpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleEEgLSBUaGUgZmlyc3Qge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIGhleEIgLSBUaGUgc2Vjb25kIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoaGV4QSwgaGV4Qikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKEJ5dGVzLmZyb21IZXgoaGV4QSksIEJ5dGVzLmZyb21IZXgoaGV4QikpO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MDAwMDEyMzQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRSaWdodCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDEyMzQwMDAwJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoZXggPSBIZXgucmFuZG9tKDMyKVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICogYGBgXG4gKlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLnJhbmRvbShsZW5ndGgpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgMSwgNClcbiAqIC8vIEBsb2c6ICcweDIzNDU2NydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gc2xpY2UuXG4gKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gZW5kIC0gVGhlIGVuZCBvZmZzZXQgKGluIGJ5dGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzbGljZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gYDB4JHt2YWx1ZVxuICAgICAgICAucmVwbGFjZSgnMHgnLCAnJylcbiAgICAgICAgLnNsaWNlKChzdGFydCA/PyAwKSAqIDIsIChlbmQgPz8gdmFsdWUubGVuZ3RoKSAqIDIpfWA7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2l6ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiA0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgKGluIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xufVxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbUxlZnQoJzB4MDAwMDAwMDBkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdHJpbS5cbiAqIEByZXR1cm5zIFRoZSB0cmltbWVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbVJpZ2h0KCcweGRlYWRiZWVmMDAwMDAwMDAnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIEJpZ0ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0JpZ0ludCgnMHgxYTQnKVxuICogLy8gQGxvZzogNDIwblxuICpcbiAqIEhleC50b0JpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgQmlnSW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heF91bnNpZ25lZCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4pKSAtIDFuO1xuICAgIGNvbnN0IG1heF9zaWduZWQgPSBtYXhfdW5zaWduZWQgPj4gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heF9zaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgLSBtYXhfdW5zaWduZWQgLSAxbjtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDEnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCBoZXhfID0gdHJpbUxlZnQoaGV4KTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChoZXhfID09PSAnMHgxJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEludmFsaWRIZXhCb29sZWFuRXJyb3IoaGV4KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBIZXgudG9CeXRlcygnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDFhNCcpXG4gKiAvLyBAbG9nOiA0MjBcbiAqXG4gKiBIZXgudG9OdW1iZXIoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMFxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXNpZ25lZCAmJiAhc2l6ZSlcbiAgICAgICAgcmV0dXJuIE51bWJlcihoZXgpO1xuICAgIHJldHVybiBOdW1iZXIodG9CaWdJbnQoaGV4LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b1N0cmluZygnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkISdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIHtcbiAqICBzaXplOiAzMixcbiAqIH0pXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5mcm9tSGV4KGhleCk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfYnl0ZXMuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzID0gQnl0ZXMudHJpbVJpZ2h0KGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEge0BsaW5rIG94I0hleC5IZXh9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSwgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBpbnRlZ2VyIGlzIG91dCBvZiByYW5nZSwgYW5kIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGhleCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMDE4MjczODkxMjczMTI4MzcxMjkzNzEyOSlcbiAqIC8vIEBlcnJvcjogSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3I6IE51bWJlciBcXGA0LjIwMTgyNzM4OTEyNzMxMjZlKzI2XFxgIGlzIG5vdCBpbiBzYWZlIHVuc2lnbmVkIGludGVnZXIgcmFuZ2UgKGAwYCB0byBgOTAwNzE5OTI1NDc0MDk5MWApXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heCwgbWluLCBzaWduZWQsIHNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBOdW1iZXIgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGluIHNhZmUke3NpemUgPyBgICR7c2l6ZSAqIDh9LWJpdGAgOiAnJ30ke3NpZ25lZCA/ICcgc2lnbmVkJyA6ICcgdW5zaWduZWQnfSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXGAke21pbn1cXGAgdG8gXFxgJHttYXh9XFxgKWAgOiBgKGFib3ZlIFxcYCR7bWlufVxcYClgfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvQm9vbGVhbignMHhhJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFcImAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhCb29sZWFuRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihoZXgpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7aGV4fVwiXFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoMSlcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhUeXBlRXJyb3I6IFZhbHVlIGAxYCBvZiB0eXBlIGBudW1iZXJgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0hleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4JHtzdHJpbmd9XCJgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJzB4MDEyMzQ1Njc4OWFiY2RlZmcnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleFZhbHVlRXJyb3I6IFZhbHVlIGAweDAxMjM0NTY3ODlhYmNkZWZnYCBpcyBhbiBpbnZhbGlkIGhleCB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogSGV4IHZhbHVlcyBtdXN0IHN0YXJ0IHdpdGggYFwiMHhcImAgYW5kIGNvbnRhaW4gb25seSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTksIGEtZiwgQS1GKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgYW4gb2RkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbUhleCgnMHhhYmNkZScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkTGVuZ3RoRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFiY2RlXCJgIGlzIGFuIG9kZCBsZW5ndGggKDUgbmliYmxlcykuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRMZW5ndGhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke3ZhbHVlfVwiXFxgIGlzIGFuIG9kZCBsZW5ndGggKCR7dmFsdWUubGVuZ3RoIC0gMn0gbmliYmxlcykuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0l0IG11c3QgYmUgYW4gZXZlbiBsZW5ndGguJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRMZW5ndGhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgZXhwZWN0ZWQgbWF4IHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiA4IH0pXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzbGljZSBvZmZzZXQgZXhjZWVkcyB0aGUgYm91bmRzIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgNilcbiAqIC8vIEBlcnJvcjogSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjogU2xpY2Ugc3RhcnRpbmcgYXQgb2Zmc2V0IGA2YCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBgNWApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSBleGNlZWRzIHRoZSBwYWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDFhNGUxMmE0NWEyMTMyMzEyM2FhYTg3YTg5N2E4OTdhODk4YTY1NjdhNTc4YTg2N2E5ODc3OGE2NjdhODVhODc1YTg3YTZhNzg3YTY1YTY3NWE2YTknLCAzMilcbiAqIC8vIEBlcnJvcjogSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogSGV4IHNpemUgKGA0M2ApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgMzJgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSnNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLDZCQUE2QixnRkFBZ0Y7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsZ0ZBQWdGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUtBQXFLO0FBQ3JLO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSnNvbi5qcz9hNjI5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJpZ0ludFN1ZmZpeCA9ICcjX19iaWdpbnQnO1xuLyoqXG4gKiBQYXJzZXMgYSBKU09OIHN0cmluZywgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5wYXJzZSgne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBmb286ICdiYXInLFxuICogLy8gQGxvZzogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEBwYXJhbSByZXZpdmVyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyaW5nLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nLCAoa2V5LCB2YWx1ZV8pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKGJpZ0ludFN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlLnNsaWNlKDAsIC1iaWdJbnRTdWZmaXgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IHJldml2ZXIoa2V5LCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogU3RyaW5naWZpZXMgYSB2YWx1ZSB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiwgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5zdHJpbmdpZnkoe1xuICogICBmb286ICdiYXInLFxuICogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiAne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RyaW5naWZ5LlxuICogQHBhcmFtIHJlcGxhY2VyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuIEl0IGlzIHBhc3NlZCB0aGUga2V5IGFuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGFuZCBtdXN0IHJldHVybiB0aGUgdmFsdWUgdG8gYmUgdXNlZCBpbiB0aGUgSlNPTiBzdHJpbmcuIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlIHByb3BlcnR5IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIEpTT04gc3RyaW5nLlxuICogQHBhcmFtIHNwYWNlIC0gQSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIEpTT04gc3RyaW5nLiBJZiBpdCBpcyBhIG51bWJlciwgaXQgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIHVzZSBhcyBpbmRlbnRhdGlvbjsgaWYgaXQgaXMgYSBzdHJpbmcgKGUuZy4gYCdcXHQnYCksIGl0IHVzZXMgdGhlIHN0cmluZyBhcyB0aGUgaW5kZW50YXRpb24gY2hhcmFjdGVyLlxuICogQHJldHVybnMgVGhlIEpTT04gc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyBiaWdJbnRTdWZmaXg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBzcGFjZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"(action-browser)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nfunction from(value) {\n    const publicKey = (() => {\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value))\n            return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, { size: 1 }) : '0x', _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (_error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nclass InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nclass InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nclass InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nclass InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUHVibGljS2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDTjtBQUNFO0FBQ2xDO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUMsWUFBWSxhQUFhO0FBQ3pCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEIsZUFBZSw2QkFBNkIsR0FBRyxxQkFBcUIsTUFBTSxpQkFBaUI7QUFDbEo7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDTztBQUNQO0FBQ0EsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBLFlBQVksK0NBQWM7QUFDMUI7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QixRQUFRLHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1CQUFtQiw4Q0FBYTtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QixRQUFRLGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQSx5QkFBeUIsMENBQVM7QUFDbEMseUJBQXlCLDBDQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUFTO0FBQ3ZDLHlCQUF5QiwwQ0FBUztBQUNsQyx5QkFBeUIsMENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUFTO0FBQ25DLHFCQUFxQiwwQ0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCLElBQUkscUJBQXFCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3Q0FBd0M7QUFDL0MsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QixJQUFJLGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksdUJBQXVCO0FBQ25DLHVCQUF1QiwyQ0FBVSxpQkFBaUIsK0NBQWMsV0FBVyxTQUFTLFVBQVUsK0NBQWMsTUFBTSxVQUFVO0FBQzVIO0FBQ0EsNEJBQTRCLCtDQUFjLE1BQU0sVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0IsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixpREFBZ0I7QUFDbEQsa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLCtDQUFjLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxpREFBZ0I7QUFDeEQsa0JBQWtCLGVBQWU7QUFDakMseUJBQXlCLE9BQU87QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTywyQ0FBMkMsaURBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDZDQUE2QyxpREFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08seUNBQXlDLGlEQUFnQjtBQUNoRSxrQkFBa0IsV0FBVztBQUM3Qix5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLHlDQUFRLENBQUMseUNBQVEsY0FBYztBQUMzRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1B1YmxpY0tleS5qcz81NjcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIFB1YmxpY0tleS5hc3NlcnQoe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHk6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFB1YmxpY0tleS5JbnZhbGlkRXJyb3I6IFZhbHVlIFxcYHtcInlcIjpcIjFcIn1cXGAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5cbiAqIC8vIEBlcnJvcjogUHVibGljIGtleSBtdXN0IGNvbnRhaW46XG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZClcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAsIGB5YCwgYW5kIGBwcmVmaXhgIHZhbHVlICh1bmNvbXByZXNzZWQpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY29tcHJlc3NlZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHByZWZpeCwgeCwgeSB9ID0gcHVibGljS2V5O1xuICAgIC8vIFVuY29tcHJlc3NlZFxuICAgIGlmIChjb21wcmVzc2VkID09PSBmYWxzZSB8fFxuICAgICAgICAodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHR5cGVvZiB5ID09PSAnYmlnaW50JykpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gNClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJlZml4RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICBjYXVzZTogbmV3IEludmFsaWRVbmNvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ29tcHJlc3NlZFxuICAgIGlmIChjb21wcmVzc2VkID09PSB0cnVlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSAzICYmIHByZWZpeCAhPT0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJlZml4RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICBjYXVzZTogbmV3IEludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFVua25vd24vaW52YWxpZFxuICAgIHRocm93IG5ldyBJbnZhbGlkRXJyb3IoeyBwdWJsaWNLZXkgfSk7XG59XG4vKipcbiAqIENvbXByZXNzZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGNvbXByZXNzZWQgPSBQdWJsaWNLZXkuY29tcHJlc3MocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogMyxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIGNvbXByZXNzLlxuICogQHJldHVybnMgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcHVibGljS2V5O1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogeSAlIDJuID09PSAwbiA/IDIgOiAzLFxuICAgICAgICB4LFxuICAgIH07XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHR5cGVkIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSBvYmplY3QgZnJvbSBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSwge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSwgb3Ige0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKCcweDA0ODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NTM1NDdmMTFjYTg2OTY2NDZmMmYzYWNiMDhlMzEwMTZhZmFjMjNlNjMwYzVkMTFmNTlmNjFmZWY1N2IwZDJhYTUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHB1YmxpYyBrZXkgdmFsdWUgdG8gaW5zdGFudGlhdGUuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFudGlhdGVkIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgaWYgKEJ5dGVzLnZhbGlkYXRlKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgeCwgeSB9ID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXggPz8gMHgwNCwgeCwgeSB9O1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHggfTtcbiAgICB9KSgpO1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIHJldHVybiBwdWJsaWNLZXk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSBmcm9tIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb21CeXRlcyhuZXcgVWludDhBcnJheShbMTI4LCAzLCAxMzEsIC4uLl0pKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIGZyb21IZXgoSGV4LmZyb21CeXRlcyhwdWJsaWNLZXkpKTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUhleCgnMHg4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIERlc2VyaWFsaXppbmcgYSBDb21wcmVzc2VkIFB1YmxpYyBLZXlcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb21IZXgoJzB4MDM4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiAzLFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgocHVibGljS2V5KSB7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDEzMiAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzAgJiZcbiAgICAgICAgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjgpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHB1YmxpY0tleSB9KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gMTMwKSB7XG4gICAgICAgIGNvbnN0IHggPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMCwgMzIpKTtcbiAgICAgICAgY29uc3QgeSA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeDogNCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gMTMyKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgICAgIGNvbnN0IHggPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMSwgMzMpKTtcbiAgICAgICAgY29uc3QgeSA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAzMywgNjUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSBOdW1iZXIoSGV4LnNsaWNlKHB1YmxpY0tleSwgMCwgMSkpO1xuICAgIGNvbnN0IHggPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMSwgMzMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fSB0byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBieXRlcyA9IFB1YmxpY0tleS50b0J5dGVzKHB1YmxpY0tleSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTI4LCAzLCAxMzEsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHRvSGV4KHB1YmxpY0tleSwgb3B0aW9ucykpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IHRvIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgaGV4ID0gUHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBhc3NlcnQocHVibGljS2V5KTtcbiAgICBjb25zdCB7IHByZWZpeCwgeCwgeSB9ID0gcHVibGljS2V5O1xuICAgIGNvbnN0IHsgaW5jbHVkZVByZWZpeCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcHVibGljS2V5XyA9IEhleC5jb25jYXQoaW5jbHVkZVByZWZpeCA/IEhleC5mcm9tTnVtYmVyKHByZWZpeCwgeyBzaXplOiAxIH0pIDogJzB4JywgSGV4LmZyb21OdW1iZXIoeCwgeyBzaXplOiAzMiB9KSwgXG4gICAgLy8gSWYgdGhlIHB1YmxpYyBrZXkgaXMgbm90IGNvbXByZXNzZWQsIGFkZCB0aGUgeSBjb29yZGluYXRlLlxuICAgIHR5cGVvZiB5ID09PSAnYmlnaW50JyA/IEhleC5mcm9tTnVtYmVyKHksIHsgc2l6ZTogMzIgfSkgOiAnMHgnKTtcbiAgICByZXR1cm4gcHVibGljS2V5Xztcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LiBSZXR1cm5zIGB0cnVlYCBpZiB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFB1YmxpY0tleS52YWxpZGF0ZSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeTogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgcHVibGljIGtleSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogUHVibGljS2V5LmFzc2VydCh7IHk6IDFuIH0pXG4gKiAvLyBAZXJyb3I6IFB1YmxpY0tleS5JbnZhbGlkRXJyb3I6IFZhbHVlIGB7XCJ5XCI6MW59YCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LlxuICogLy8gQGVycm9yOiBQdWJsaWMga2V5IG11c3QgY29udGFpbjpcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKVxuICogLy8gQGVycm9yOiAtIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwdWJsaWNLZXkgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtKc29uLnN0cmluZ2lmeShwdWJsaWNLZXkpfVxcYCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdQdWJsaWMga2V5IG11c3QgY29udGFpbjonLFxuICAgICAgICAgICAgICAgICctIGFuIGB4YCBhbmQgYHByZWZpeGAgdmFsdWUgKGNvbXByZXNzZWQpJyxcbiAgICAgICAgICAgICAgICAnLSBhbiBgeGAsIGB5YCwgYW5kIGBwcmVmaXhgIHZhbHVlICh1bmNvbXByZXNzZWQpJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGEgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBwcmVmaXguICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXgsIGNhdXNlIH0pIHtcbiAgICAgICAgc3VwZXIoYFByZWZpeCBcIiR7cHJlZml4fVwiIGlzIGludmFsaWQuYCwge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRQcmVmaXhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeCBmb3IgYSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUHJlZml4IG11c3QgYmUgMiBvciAzIGZvciBjb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBwcmVmaXggZm9yIGFuIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbmNvbXByZXNzZWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUHJlZml4IG11c3QgYmUgNCBmb3IgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRVbmNvbXByZXNzZWRQcmVmaXhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHNlcmlhbGl6ZWQgc2l6ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHVibGljS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7cHVibGljS2V5fVxcYCBpcyBhbiBpbnZhbGlkIHB1YmxpYyBrZXkgc2l6ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQ6IDMzIGJ5dGVzIChjb21wcmVzc2VkICsgcHJlZml4KSwgNjQgYnl0ZXMgKHVuY29tcHJlc3NlZCkgb3IgNjUgYnl0ZXMgKHVuY29tcHJlc3NlZCArIHByZWZpeCkuJyxcbiAgICAgICAgICAgICAgICBgUmVjZWl2ZWQgJHtIZXguc2l6ZShIZXguZnJvbShwdWJsaWNLZXkpKX0gYnl0ZXMuYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QdWJsaWNLZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nfunction toBytes(value) {\n    return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value) {\n    return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nfunction to(value, to) {\n    const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */\n/** @internal */\nfunction decodeRlpCursor(cursor, to = 'Hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromBytes(bytes, options = {}) {\n    const { as = 'Bytes' } = options;\n    return from(bytes, { as });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromHex(hex, options = {}) {\n    const { as = 'Hex' } = options;\n    return from(hex, { as });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length <= 0xff)\n        return 1;\n    if (length <= 0xff_ff)\n        return 2;\n    if (length <= 0xff_ff_ff)\n        return 3;\n    if (length <= 0xff_ff_ff_ff)\n        return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ2U7QUFDL0M7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQXNCO0FBQ2hELG1CQUFtQiw4Q0FBYTtBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQix1REFBYTtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQiw4Q0FBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQWdCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0IsSUFBSSxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLEtBQUs7QUFDakI7QUFDQSxtQkFBbUIsdURBQWE7QUFDaEM7QUFDQTtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLGVBQWU7QUFDM0IseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDTyxrQ0FBa0M7QUFDekMsWUFBWSxhQUFhO0FBQ3pCLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4Q0FBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpREFBZ0I7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JscC5qcz81NDJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBDdXJzb3IgZnJvbSAnLi9pbnRlcm5hbC9jdXJzb3IuanMnO1xuLyoqXG4gKiBEZWNvZGVzIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUgaW50byBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0J5dGVzKCcweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcpXG4gKiAvLyBVaW50OEFycmF5KFsxMzksIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB0byh2YWx1ZSwgJ0J5dGVzJyk7XG59XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUmxwIH0gZnJvbSAnb3gnXG4gKiBSbHAudG9IZXgoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIDB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnSGV4Jyk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEludGVybmFsXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0byh2YWx1ZSwgdG8pIHtcbiAgICBjb25zdCB0b18gPSB0byA/PyAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyk7XG4gICAgY29uc3QgYnl0ZXMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDMgJiYgdmFsdWUubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSGV4LkludmFsaWRMZW5ndGhFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pKCk7XG4gICAgY29uc3QgY3Vyc29yID0gQ3Vyc29yLmNyZWF0ZShieXRlcywge1xuICAgICAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0b18pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8gPSAnSGV4Jykge1xuICAgIGlmIChjdXJzb3IuYnl0ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoY3Vyc29yLmJ5dGVzKSA6IGN1cnNvci5ieXRlcyk7XG4gICAgY29uc3QgcHJlZml4ID0gY3Vyc29yLnJlYWRCeXRlKCk7XG4gICAgaWYgKHByZWZpeCA8IDB4ODApXG4gICAgICAgIGN1cnNvci5kZWNyZW1lbnRQb3NpdGlvbigxKTtcbiAgICAvLyBieXRlc1xuICAgIGlmIChwcmVmaXggPCAweGMwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIDB4ODApO1xuICAgICAgICBjb25zdCBieXRlcyA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICh0byA9PT0gJ0hleCcgPyBIZXguZnJvbUJ5dGVzKGJ5dGVzKSA6IGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gbGlzdFxuICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIDB4YzApO1xuICAgIHJldHVybiByZWFkTGlzdChjdXJzb3IsIGxlbmd0aCwgdG8pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IDB4ODAgJiYgcHJlZml4IDwgMHg4MClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHByZWZpeCA8PSBvZmZzZXQgKyA1NSlcbiAgICAgICAgcmV0dXJuIHByZWZpeCAtIG9mZnNldDtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDEpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQ4KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyAyKVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MTYoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDMpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQyNCgpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgNClcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDMyKCk7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ0ludmFsaWQgUkxQIHByZWZpeCcpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0bykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnBvc2l0aW9uO1xuICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3NpdGlvbiAtIHBvc2l0aW9uIDwgbGVuZ3RoKVxuICAgICAgICB2YWx1ZS5wdXNoKGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tKCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnLCB7IGFzOiAnSGV4JyB9KVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqXG4gKiBSbHAuZnJvbShCeXRlcy5mcm9tKFsxMzksIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSksIHsgYXM6ICdCeXRlcycgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUkxQIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW5jb2RhYmxlID0gZ2V0RW5jb2RhYmxlKHZhbHVlKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKG5ldyBVaW50OEFycmF5KGVuY29kYWJsZS5sZW5ndGgpKTtcbiAgICBlbmNvZGFibGUuZW5jb2RlKGN1cnNvcik7XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoY3Vyc29yLmJ5dGVzKTtcbiAgICByZXR1cm4gY3Vyc29yLmJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb21CeXRlcyhCeXRlcy5mcm9tKFsxMzksIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSwgIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUkxQIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gZnJvbShieXRlcywgeyBhcyB9KTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUhleCgnMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIEBsb2c6IDB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUkxQIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gZnJvbShoZXgsIHsgYXMgfSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEludGVybmFsXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGdldEVuY29kYWJsZShieXRlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSlcbiAgICAgICAgcmV0dXJuIGdldEVuY29kYWJsZUxpc3QoYnl0ZXMubWFwKCh4KSA9PiBnZXRFbmNvZGFibGUoeCkpKTtcbiAgICByZXR1cm4gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlTGlzdChsaXN0KSB7XG4gICAgY29uc3QgYm9keUxlbmd0aCA9IGxpc3QucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBzaXplT2ZCb2R5TGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJvZHlMZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBib2R5TGVuZ3RoO1xuICAgICAgICByZXR1cm4gMSArIHNpemVPZkJvZHlMZW5ndGggKyBib2R5TGVuZ3RoO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAoYm9keUxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgYm9keUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHhjMCArIDU1ICsgc2l6ZU9mQm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQzMihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBlbmNvZGUgfSBvZiBsaXN0KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlKGN1cnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kYWJsZUJ5dGVzKGJ5dGVzT3JIZXgpIHtcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBieXRlc09ySGV4ID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoYnl0ZXNPckhleCkgOiBieXRlc09ySGV4O1xuICAgIGNvbnN0IHNpemVPZkJ5dGVzTGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJ5dGVzLmxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMSAmJiBieXRlc1swXSA8IDB4ODApXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8PSA1NSlcbiAgICAgICAgICAgIHJldHVybiAxICsgYnl0ZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gMSArIHNpemVPZkJ5dGVzTGVuZ3RoICsgYnl0ZXMubGVuZ3RoO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4ODAgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4ODAgKyA1NSArIHNpemVPZkJ5dGVzTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQnl0ZXNMZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNpemVPZkxlbmd0aChsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmYpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChsZW5ndGggPD0gMHhmZl9mZilcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmX2ZmX2ZmKVxuICAgICAgICByZXR1cm4gMztcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmZfZmZfZmZfZmYpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdMZW5ndGggaXMgdG9vIGxhcmdlLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmxwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Rlp.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Secp256k1.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Secp256k1.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(action-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Address.js */ \"(action-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/entropy.js */ \"(action-browser)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(action-browser)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n\n/** Re-export of noble/curves secp256k1 utilities. */\nconst noble = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nfunction createKeyPair(options = {}) {\n    const { as = 'Hex' } = options;\n    const privateKey = randomPrivateKey({ as });\n    const publicKey = getPublicKey({ privateKey });\n    return {\n        privateKey: privateKey,\n        publicKey,\n    };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nfunction getSharedSecret(options) {\n    const { as = 'Hex', privateKey, publicKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.normPrivateKeyToScalar(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nfunction recoverAddress(options) {\n    return _Address_js__WEBPACK_IMPORTED_MODULE_3__.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload).substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nfunction sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(_Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nfunction verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address)\n        return _Address_js__WEBPACK_IMPORTED_MODULE_3__.isEqual(address, recoverAddress({ payload, signature }));\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(signature, _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toBytes(publicKey), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=Secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNaO0FBQ0o7QUFDSjtBQUNpQjtBQUNMO0FBQzVDO0FBQ08sY0FBYyw4REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGFBQWE7QUFDekIsMENBQTBDLElBQUk7QUFDOUMscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksYUFBYTtBQUN6QixrQkFBa0IsOERBQVMsZ0NBQWdDLHlDQUFRO0FBQ25FLFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxvQ0FBb0M7QUFDaEQsa0JBQWtCLDhEQUFTLHlCQUF5QixnREFBZTtBQUNuRSx1Q0FBdUMsOERBQVMsOEJBQThCLHlDQUFRO0FBQ3RGLHVEQUF1RDtBQUN2RDtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxhQUFhO0FBQ3pCLGtCQUFrQiw4REFBUztBQUMzQjtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksZ0JBQWdCO0FBQzVCLDJCQUEyQiw4REFBUztBQUNwQyw4Q0FBOEMseUNBQVE7QUFDdEQsV0FBVywrQ0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ087QUFDUCxZQUFZLGVBQWUsOERBQW9CLCtCQUErQjtBQUM5RSxZQUFZLGlCQUFpQixFQUFFLDhEQUFTLE1BQU0sMkNBQVUsV0FBVywyQ0FBVTtBQUM3RTtBQUNBO0FBQ0EsY0FBYyx5Q0FBUTtBQUN0QjtBQUNBLHFCQUFxQixnQkFBZ0IsSUFBSTtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFELHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksK0NBQStDO0FBQzNEO0FBQ0EsZUFBZSxnREFBZSwyQkFBMkIsb0JBQW9CO0FBQzdFLFdBQVcsOERBQVMsbUJBQW1CLDJDQUFVLFdBQVcsa0RBQWlCLDJCQUEyQiwyQkFBMkI7QUFDbkk7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcz83MTdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEVudHJvcHkgZnJvbSAnLi9pbnRlcm5hbC9lbnRyb3B5LmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG4vKiogUmUtZXhwb3J0IG9mIG5vYmxlL2N1cnZlcyBzZWNwMjU2azEgdXRpbGl0aWVzLiAqL1xuZXhwb3J0IGNvbnN0IG5vYmxlID0gc2VjcDI1NmsxO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNlY3AyNTZrMSBFQ0RTQSBrZXkgcGFpciBjb25zaXN0aW5nIG9mIGEgcHJpdmF0ZSBrZXkgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gU2VjcDI1NmsxLmNyZWF0ZUtleVBhaXIoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUga2V5IHBhaXIuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGtleSBwYWlyIGNvbnRhaW5pbmcgYm90aCBwcml2YXRlIGFuZCBwdWJsaWMga2V5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleVBhaXIob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSByYW5kb21Qcml2YXRlS2V5KHsgYXMgfSk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICBwdWJsaWNLZXksXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNlY3AyNTZrMSBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBwcm92aWRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShIZXguZnJvbShwcml2YXRlS2V5KS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHBvaW50KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBzaGFyZWQgc2VjcmV0IHVzaW5nIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZS1IZWxsbWFuKSBiZXR3ZWVuIGEgcHJpdmF0ZSBrZXkgYW5kIGEgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUEgfSA9IFNlY3AyNTZrMS5jcmVhdGVLZXlQYWlyKClcbiAqIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlCIH0gPSBTZWNwMjU2azEuY3JlYXRlS2V5UGFpcigpXG4gKlxuICogY29uc3Qgc2hhcmVkU2VjcmV0ID0gU2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldCh7XG4gKiAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlBLFxuICogICBwdWJsaWNLZXk6IHB1YmxpY0tleUJcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHNoYXJlZCBzZWNyZXQuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgc2hhcmVkIHNlY3JldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnLCBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoUHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoMikpO1xuICAgIGNvbnN0IHNoYXJlZFBvaW50ID0gcG9pbnQubXVsdGlwbHkoc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoSGV4LmZyb20ocHJpdmF0ZUtleSkuc2xpY2UoMikpKTtcbiAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSBzaGFyZWRQb2ludC50b1Jhd0J5dGVzKHRydWUpOyAvLyBjb21wcmVzc2VkIGZvcm1hdFxuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHNoYXJlZFNlY3JldCk7XG4gICAgcmV0dXJuIHNoYXJlZFNlY3JldDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIEVDRFNBIHByaXZhdGUga2V5IG9uIHRoZSBzZWNwMjU2azEgY3VydmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUHJpdmF0ZUtleShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIFJlY292ZXJzIHRoZSBzaWduaW5nIGFkZHJlc3MgZnJvbSB0aGUgc2lnbmVkIHBheWxvYWQgYW5kIHNpZ25hdHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgYWRkcmVzcyA9IFNlY3AyNTZrMS5yZWNvdmVyQWRkcmVzcyh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSByZWNvdmVyZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tUHVibGljS2V5KHJlY292ZXJQdWJsaWNLZXkob3B0aW9ucykpO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwb2ludCA9IHNpZ25hdHVyZV8ucmVjb3ZlclB1YmxpY0tleShIZXguZnJvbShwYXlsb2FkKS5zdWJzdHJpbmcoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIFNpZ25zIHRoZSBwYXlsb2FkIHdpdGggdGhlIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5OiAnMHguLi4nIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25pbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBFQ0RTQSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGV4dHJhRW50cm9weSA9IEVudHJvcHkuZXh0cmFFbnRyb3B5LCBoYXNoLCBwYXlsb2FkLCBwcml2YXRlS2V5LCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5IH0gPSBzZWNwMjU2azEuc2lnbihCeXRlcy5mcm9tKHBheWxvYWQpLCBCeXRlcy5mcm9tKHByaXZhdGVLZXkpLCB7XG4gICAgICAgIGV4dHJhRW50cm9weTogdHlwZW9mIGV4dHJhRW50cm9weSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGV4dHJhRW50cm9weVxuICAgICAgICAgICAgOiBIZXguZnJvbShleHRyYUVudHJvcHkpLnNsaWNlKDIpLFxuICAgICAgICBsb3dTOiB0cnVlLFxuICAgICAgICAuLi4oaGFzaCA/IHsgcHJlaGFzaDogdHJ1ZSB9IDoge30pLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHk6IHJlY292ZXJ5LFxuICAgIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGEgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBhZGRyZXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5IHdpdGggRXRoZXJldW0gQWRkcmVzc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHZlcmlmaWVkID0gU2VjcDI1NmsxLnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYWRkcmVzczogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnkgd2l0aCBQdWJsaWMgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSAnMHguLi4nXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBTZWNwMjU2azEuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IFNlY3AyNTZrMS52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB2ZXJpZmljYXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHBheWxvYWQgd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBoYXNoLCBwYXlsb2FkLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuaXNFcXVhbChhZGRyZXNzLCByZWNvdmVyQWRkcmVzcyh7IHBheWxvYWQsIHNpZ25hdHVyZSB9KSk7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoc2lnbmF0dXJlLCBCeXRlcy5mcm9tKHBheWxvYWQpLCBQdWJsaWNLZXkudG9CeXRlcyhwdWJsaWNLZXkpLCAuLi4oaGFzaCA/IFt7IHByZWhhc2g6IHRydWUsIGxvd1M6IHRydWUgfV0gOiBbXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Secp256k1.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(action-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(action-browser)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(action-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nfunction extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nfunction from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nfunction toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nfunction toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nfunction toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nfunction vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nfunction yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nclass MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nclass InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nclass InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nclass InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nclass InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2hCO0FBQ0U7QUFDTjtBQUNFO0FBQ1E7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksWUFBWTtBQUN4QjtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RCwwQ0FBMEMsb0RBQW1CO0FBQzdELGtDQUFrQyxvQkFBb0I7QUFDdEQsMENBQTBDLG9EQUFtQjtBQUM3RCxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0IsNkJBQTZCLDZCQUE2QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDTztBQUNQLG1CQUFtQiw4Q0FBYTtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQiw2QkFBNkIsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDTztBQUNQO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQscUJBQXFCLDBDQUFTO0FBQzlCLHFCQUFxQiwwQ0FBUztBQUM5QjtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEIsZUFBZSw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsTUFBTSxpQkFBaUI7QUFDL0s7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDTztBQUNQLHNCQUFzQiw4Q0FBYTtBQUNuQztBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNPO0FBQ1AsWUFBWSxPQUFPLEVBQUUsOERBQVMsbUJBQW1CLHlDQUFRO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSwyQkFBMkIsUUFBUSw2QkFBNkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QixRQUFRLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRCwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEIsTUFBTSw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QixJQUFJLHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEIsSUFBSSxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQVUsQ0FBQywrQ0FBYyxNQUFNLFVBQVUsR0FBRywrQ0FBYyxNQUFNLFVBQVU7QUFDakc7QUFDQTtBQUNBLFVBQVUsK0NBQWMsa0NBQWtDLFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLDhEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsOERBQVM7QUFDN0IsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLGVBQWUsOEJBQThCLFFBQVEsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakUsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pELDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEIsUUFBUSx1QkFBdUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNPO0FBQ1AsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxXQUFXLCtDQUFjLE1BQU0sVUFBVTtBQUN6QyxXQUFXLCtDQUFjLE1BQU0sVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCLGlCQUFpQiwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RCxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ087QUFDUCxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFZLENBQUMsK0NBQWM7QUFDckQsMEJBQTBCLDZDQUFZLENBQUMsK0NBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNPLHlDQUF5QyxpREFBZ0I7QUFDaEUsa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBUSxDQUFDLHlDQUFRLGNBQWM7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsaURBQWdCO0FBQzVELGtCQUFrQixXQUFXO0FBQzdCLDZCQUE2QiwrQ0FBYyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFnQjtBQUNuRCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFnQjtBQUNuRCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NpZ25hdHVyZS5qcz80MjQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBTb2xpZGl0eSBmcm9tICcuL1NvbGlkaXR5LmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgU2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmFzc2VydCh7XG4gKiAgIHI6IC00OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEludmFsaWRTaWduYXR1cmVSRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGAtNTQ5Li4ubmAgaXMgYW4gaW52YWxpZCByIHZhbHVlLlxuICogLy8gQGVycm9yOiByIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIG9iamVjdCB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHJlY292ZXJlZCB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChyZWNvdmVyZWQgJiYgdHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5yIDwgMG4gfHwgc2lnbmF0dXJlLnIgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUuciB9KTtcbiAgICBpZiAoc2lnbmF0dXJlLnMgPCAwbiB8fCBzaWduYXR1cmUucyA+IFNvbGlkaXR5Lm1heFVpbnQyNTYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU0Vycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS5zIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICdudW1iZXInICYmXG4gICAgICAgIHNpZ25hdHVyZS55UGFyaXR5ICE9PSAwICYmXG4gICAgICAgIHNpZ25hdHVyZS55UGFyaXR5ICE9PSAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUueVBhcml0eSB9KTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBzaWduYXR1cmUgaW50byBhIHN0cnVjdHVyZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7IHI6IDUyMzEuLi5uLCBzOiAzNTIyLi4ubiwgeVBhcml0eTogMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZyb21IZXgoSGV4LmZyb21CeXRlcyhzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I0hleC5IZXh9IHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbUhleCgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJylcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSAxMzAgJiYgc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMyKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgY29uc3QgciA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAwLCAzMikpO1xuICAgIGNvbnN0IHMgPSBCaWdJbnQoSGV4LnNsaWNlKHNpZ25hdHVyZSwgMzIsIDY0KSk7XG4gICAgY29uc3QgeVBhcml0eSA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHlQYXJpdHkgPSBOdW1iZXIoYDB4JHtzaWduYXR1cmUuc2xpY2UoMTMwKX1gKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih5UGFyaXR5KSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdlRvWVBhcml0eSh5UGFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiB5UGFyaXR5IH0pO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBpZiAodHlwZW9mIHlQYXJpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIHMsXG4gICAgICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgeVBhcml0eSxcbiAgICB9O1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBmcm9tIGFuIGFyYml0cmFyeSBvYmplY3QgdGhhdCBtYXkgaW5jbHVkZSBzaWduYXR1cmUgcHJvcGVydGllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmV4dHJhY3Qoe1xuICogICBiYXo6ICdiYXJyeScsXG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogICB6ZWJyYTogJ3N0cmlwZXMnLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcmJpdHJhcnkgb2JqZWN0IHRvIGV4dHJhY3QgdGhlIHNpZ25hdHVyZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGV4dHJhY3RlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBmcm9tKHZhbHVlKTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LCB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0sIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG9yIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgwMScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIExlZ2FjeVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ3MzIzNDU3MDA3NDUzNjU3MjA3ODg5NzMwMjQzODI2OTY1NzYxOTIyMjk2NTk5NjgwNDczODg2NTg4Mjg3MDE1NzU1NjUyNzAxMDcybixcbiAqICAgczogNTcyMjg4MDMyMDI3MjcxMzE1MDI5NDkzNTgzMTM0NTYwNzEyODA0ODgxODQyNzAyNTgyOTM2NzQyNDIxMjQzNDAxMTM4MjQ4ODI3ODhuLFxuICogICB2OiAyNyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ3MzIzNDU3MDA3NDUzNjU3MjA3ODg5NzMwMjQzODI2OTY1NzYxOTIyMjk2NTk5NjgwNDczODg2NTg4Mjg3MDE1NzU1NjUyNzAxMDcybixcbiAqIC8vIEBsb2c6ICAgczogNTcyMjg4MDMyMDI3MjcxMzE1MDI5NDkzNTgzMTM0NTYwNzEyODA0ODgxODQyNzAyNTgyOTM2NzQyNDIxMjQzNDAxMTM4MjQ4ODI3ODhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVfID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21ScGMoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZS52KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21MZWdhY3koc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgICAgICAuLi4odHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8geyB5UGFyaXR5OiBzaWduYXR1cmUueVBhcml0eSB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlXyk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV87XG59XG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURlckJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMzIsIDUxLCAyMywgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRGVyQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZyb21EZXJIZXgoSGV4LmZyb21CeXRlcyhzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURlckhleCgnMHgzMDQ0MDIyMDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmYwMjIwNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiOCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRGVySGV4KHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tREVSKEhleC5mcm9tKHNpZ25hdHVyZSkuc2xpY2UoMikpO1xuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGxlZ2FjeSA9IFNpZ25hdHVyZS5mcm9tTGVnYWN5KHsgcjogMW4sIHM6IDJuLCB2OiAyOCB9KVxuICogLy8gQGxvZzogeyByOiAxbiwgczogMm4sIHlQYXJpdHk6IDEgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUxlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHlQYXJpdHk6IHZUb1lQYXJpdHkoc2lnbmF0dXJlLnYpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbVJwYyh7XG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHNpZ25hdHVyZS52ID8gTnVtYmVyKHNpZ25hdHVyZS52KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHlQYXJpdHkgPSBzaWduYXR1cmUueVBhcml0eSA/IE51bWJlcihzaWduYXR1cmUueVBhcml0eSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgeVBhcml0eSA9IHZUb1lQYXJpdHkodik7XG4gICAgICAgIGlmICh0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUueVBhcml0eSB9KTtcbiAgICAgICAgcmV0dXJuIHlQYXJpdHk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBCaWdJbnQoc2lnbmF0dXJlLnIpLFxuICAgICAgICBzOiBCaWdJbnQoc2lnbmF0dXJlLnMpLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbVR1cGxlKFsnMHgwMScsICcweDdiJywgJzB4MWM4J10pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDEyM24sXG4gKiAvLyBAbG9nOiAgIHM6IDQ1Nm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDEsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbeVBhcml0eSwgciwgc10gPSB0dXBsZTtcbiAgICByZXR1cm4gZnJvbSh7XG4gICAgICAgIHI6IHIgPT09ICcweCcgPyAwbiA6IEJpZ0ludChyKSxcbiAgICAgICAgczogcyA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHMpLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAnMHgnID8gMCA6IE51bWJlcih5UGFyaXR5KSxcbiAgICB9KTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvQnl0ZXMoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEwMiwgMTYsIDEwLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHRvSGV4KHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b0hleCh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogLy8gQGxvZzogJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUpO1xuICAgIGNvbnN0IHIgPSBzaWduYXR1cmUucjtcbiAgICBjb25zdCBzID0gc2lnbmF0dXJlLnM7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IEhleC5jb25jYXQoSGV4LmZyb21OdW1iZXIociwgeyBzaXplOiAzMiB9KSwgSGV4LmZyb21OdW1iZXIocywgeyBzaXplOiAzMiB9KSwgXG4gICAgLy8gSWYgdGhlIHNpZ25hdHVyZSBpcyByZWNvdmVyZWQsIGFkZCB0aGUgcmVjb3ZlcnkgYnl0ZSB0byB0aGUgc2lnbmF0dXJlLlxuICAgIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcidcbiAgICAgICAgPyBIZXguZnJvbU51bWJlcih5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSwgeyBzaXplOiAxIH0pXG4gICAgICAgIDogJzB4Jyk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV87XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIERFUi1lbmNvZGVkIGZvcm1hdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZV9kZXIgPSBTaWduYXR1cmUudG9EZXJCeXRlcyhzaWduYXR1cmUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMzIsIDUxLCAyMywgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKHNpZ25hdHVyZS5yLCBzaWduYXR1cmUucyk7XG4gICAgcmV0dXJuIHNpZy50b0RFUlJhd0J5dGVzKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIERFUi1lbmNvZGVkIGZvcm1hdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZV9kZXIgPSBTaWduYXR1cmUudG9EZXJIZXgoc2lnbmF0dXJlKVxuICogLy8gQGxvZzogJzB4MzA0NDAyMjA2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmMDIyMDRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVySGV4KHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKHNpZ25hdHVyZS5yLCBzaWduYXR1cmUucyk7XG4gICAgcmV0dXJuIGAweCR7c2lnLnRvREVSSGV4KCl9YDtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGxlZ2FjeSA9IFNpZ25hdHVyZS50b0xlZ2FjeSh7IHI6IDFuLCBzOiAybiwgeVBhcml0eTogMSB9KVxuICogLy8gQGxvZzogeyByOiAxbiwgczogMm4sIHY6IDI4IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGVnYWN5KHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgdjogeVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b1JwYyh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogSGV4LmZyb21OdW1iZXIociwgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgczogSGV4LmZyb21OdW1iZXIocywgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgeVBhcml0eTogeVBhcml0eSA9PT0gMCA/ICcweDAnIDogJzB4MScsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gYSBzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGJlIHVzZWQgZm9yIHNpZ25hdHVyZXMgaW4gVHJhbnNhY3Rpb24gRW52ZWxvcGVzLCBFSVAtNzcwMiBBdXRob3JpemF0aW9uIExpc3RzLCBldGMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVUdXBsZSA9IFNpZ25hdHVyZS50b1R1cGxlKHtcbiAqICAgcjogMTIzbixcbiAqICAgczogNDU2bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBbeVBhcml0eTogJzB4MDEnLCByOiAnMHg3YicsIHM6ICcweDFjOCddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4gW1xuICAgICAgICB5UGFyaXR5ID8gJzB4MDEnIDogJzB4JyxcbiAgICAgICAgciA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHIpKSxcbiAgICAgICAgcyA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHMpKSxcbiAgICBdO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBTaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmUudmFsaWRhdGUoe1xuICogICByOiAtNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIG9iamVjdCB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShzaWduYXR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEVDRFNBIGB2YCB2YWx1ZSB0byBhIGB5UGFyaXR5YCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHlQYXJpdHkgPSBTaWduYXR1cmUudlRvWVBhcml0eSgyOClcbiAqIC8vIEBsb2c6IDFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2IC0gVGhlIEVDRFNBIGB2YCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGB5UGFyaXR5YCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZUb1lQYXJpdHkodikge1xuICAgIGlmICh2ID09PSAwIHx8IHYgPT09IDI3KVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAodiA9PT0gMSB8fCB2ID09PSAyOClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHYgPj0gMzUpXG4gICAgICAgIHJldHVybiB2ICUgMiA9PT0gMCA/IDEgOiAwO1xuICAgIHRocm93IG5ldyBJbnZhbGlkVkVycm9yKHsgdmFsdWU6IHYgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgRUNEU0EgYHZgIHZhbHVlIHRvIGEgYHlQYXJpdHlgIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdiA9IFNpZ25hdHVyZS55UGFyaXR5VG9WKDEpXG4gKiAvLyBAbG9nOiAyOFxuICogYGBgXG4gKlxuICogQHBhcmFtIHlQYXJpdHkgLSBUaGUgRUNEU0EgYHlQYXJpdHlgIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYHZgIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24geVBhcml0eVRvVih5UGFyaXR5KSB7XG4gICAgaWYgKHlQYXJpdHkgPT09IDApXG4gICAgICAgIHJldHVybiAyNztcbiAgICBpZiAoeVBhcml0eSA9PT0gMSlcbiAgICAgICAgcmV0dXJuIDI4O1xuICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlIGlzIG9mIGFuIGludmFsaWQgc2l6ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7c2lnbmF0dXJlfVxcYCBpcyBhbiBpbnZhbGlkIHNpZ25hdHVyZSBzaXplLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RlZDogNjQgYnl0ZXMgb3IgNjUgYnl0ZXMuJyxcbiAgICAgICAgICAgICAgICBgUmVjZWl2ZWQgJHtIZXguc2l6ZShIZXguZnJvbShzaWduYXR1cmUpKX0gYnl0ZXMuYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBpcyBtaXNzaW5nIGVpdGhlciBhbiBgcmAsIGBzYCwgb3IgYHlQYXJpdHlgIHByb3BlcnR5LiAqL1xuZXhwb3J0IGNsYXNzIE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaWduYXR1cmUgXFxgJHtKc29uLnN0cmluZ2lmeShzaWduYXR1cmUpfVxcYCBpcyBtaXNzaW5nIGVpdGhlciBhbiBcXGByXFxgLCBcXGBzXFxgLCBvciBcXGB5UGFyaXR5XFxgIHByb3BlcnR5LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGByYCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuIHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRSRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGBzYCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHMgdmFsdWUuIHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRTRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGB5UGFyaXR5YCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkWVBhcml0eUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHktcGFyaXR5IHZhbHVlLiBZLXBhcml0eSBtdXN0IGJlIDAgb3IgMS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkWVBhcml0eUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgdmAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFZFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB2IHZhbHVlLiB2IG11c3QgYmUgMjcsIDI4IG9yID49MzUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFZFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Signature.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU29saWRpdHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NvbGlkaXR5LmpzPzQ5YjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGFycmF5UmVnZXggPSAvXiguKilcXFsoWzAtOV0qKVxcXSQvO1xuLy8gYGJ5dGVzPE0+YDogYmluYXJ5IHR5cGUgb2YgYE1gIGJ5dGVzLCBgMCA8IE0gPD0gMzJgXG4vLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNTVcbmV4cG9ydCBjb25zdCBieXRlc1JlZ2V4ID0gL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC87XG4vLyBgKHUpaW50PE0+YDogKHVuKXNpZ25lZCBpbnRlZ2VyIHR5cGUgb2YgYE1gIGJpdHMsIGAwIDwgTSA8PSAyNTZgLCBgTSAlIDggPT0gMGBcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS82djhocFxuZXhwb3J0IGNvbnN0IGludGVnZXJSZWdleCA9IC9eKHU/aW50KSg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvO1xuZXhwb3J0IGNvbnN0IG1heEludDggPSAybiAqKiAoOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNiA9IDJuICoqICgxNm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNCA9IDJuICoqICgyNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQzMiA9IDJuICoqICgzMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ0MCA9IDJuICoqICg0MG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ0OCA9IDJuICoqICg0OG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ1NiA9IDJuICoqICg1Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ2NCA9IDJuICoqICg2NG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ3MiA9IDJuICoqICg3Mm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ4MCA9IDJuICoqICg4MG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ4OCA9IDJuICoqICg4OG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQ5NiA9IDJuICoqICg5Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMDQgPSAybiAqKiAoMTA0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDExMiA9IDJuICoqICgxMTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTIwID0gMm4gKiogKDEyMG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMjggPSAybiAqKiAoMTI4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEzNiA9IDJuICoqICgxMzZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTQ0ID0gMm4gKiogKDE0NG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNTIgPSAybiAqKiAoMTUybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2MCA9IDJuICoqICgxNjBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTY4ID0gMm4gKiogKDE2OG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNzYgPSAybiAqKiAoMTc2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE4NCA9IDJuICoqICgxODRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTkyID0gMm4gKiogKDE5Mm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMDAgPSAybiAqKiAoMjAwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIwOCA9IDJuICoqICgyMDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjE2ID0gMm4gKiogKDIxNm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMjQgPSAybiAqKiAoMjI0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIzMiA9IDJuICoqICgyMzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQwID0gMm4gKiogKDI0MG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNDggPSAybiAqKiAoMjQ4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI1NiA9IDJuICoqICgyNTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWluSW50OCA9IC0oMm4gKiogKDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNiA9IC0oMm4gKiogKDE2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQgPSAtKDJuICoqICgyNG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDMyID0gLSgybiAqKiAoMzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ0MCA9IC0oMm4gKiogKDQwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NDggPSAtKDJuICoqICg0OG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDU2ID0gLSgybiAqKiAoNTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ2NCA9IC0oMm4gKiogKDY0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NzIgPSAtKDJuICoqICg3Mm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDgwID0gLSgybiAqKiAoODBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4OCA9IC0oMm4gKiogKDg4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50OTYgPSAtKDJuICoqICg5Nm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDEwNCA9IC0oMm4gKiogKDEwNG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDExMiA9IC0oMm4gKiogKDExMm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDEyMCA9IC0oMm4gKiogKDEyMG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDEyOCA9IC0oMm4gKiogKDEyOG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDEzNiA9IC0oMm4gKiogKDEzNm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE0NCA9IC0oMm4gKiogKDE0NG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE1MiA9IC0oMm4gKiogKDE1Mm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE2MCA9IC0oMm4gKiogKDE2MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE2OCA9IC0oMm4gKiogKDE2OG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE3NiA9IC0oMm4gKiogKDE3Nm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE4NCA9IC0oMm4gKiogKDE4NG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE5MiA9IC0oMm4gKiogKDE5Mm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDIwMCA9IC0oMm4gKiogKDIwMG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDIwOCA9IC0oMm4gKiogKDIwOG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDIxNiA9IC0oMm4gKiogKDIxNm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDIyNCA9IC0oMm4gKiogKDIyNG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDIzMiA9IC0oMm4gKiogKDIzMm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDI0MCA9IC0oMm4gKiogKDI0MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDI0OCA9IC0oMm4gKiogKDI0OG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDI1NiA9IC0oMm4gKiogKDI1Nm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4ID0gMm4gKiogOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTYgPSAybiAqKiAxNm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjQgPSAybiAqKiAyNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MzIgPSAybiAqKiAzMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50NDAgPSAybiAqKiA0MG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50NDggPSAybiAqKiA0OG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50NTYgPSAybiAqKiA1Nm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50NjQgPSAybiAqKiA2NG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50NzIgPSAybiAqKiA3Mm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50ODAgPSAybiAqKiA4MG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50ODggPSAybiAqKiA4OG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50OTYgPSAybiAqKiA5Nm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTA0ID0gMm4gKiogMTA0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMTIgPSAybiAqKiAxMTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEyMCA9IDJuICoqIDEyMG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTI4ID0gMm4gKiogMTI4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMzYgPSAybiAqKiAxMzZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE0NCA9IDJuICoqIDE0NG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTUyID0gMm4gKiogMTUybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNjAgPSAybiAqKiAxNjBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2OCA9IDJuICoqIDE2OG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTc2ID0gMm4gKiogMTc2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxODQgPSAybiAqKiAxODRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE5MiA9IDJuICoqIDE5Mm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjAwID0gMm4gKiogMjAwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMDggPSAybiAqKiAyMDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIxNiA9IDJuICoqIDIxNm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjI0ID0gMm4gKiogMjI0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMzIgPSAybiAqKiAyMzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0MCA9IDJuICoqIDI0MG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjQ4ID0gMm4gKiogMjQ4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNTYgPSAybiAqKiAyNTZuIC0gMW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tb2xpZGl0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvV2l0aGRyYXdhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0M7QUFDaEM7QUFDQSxlQUFlLHlCQUF5QixPQUFPLCtCQUErQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQkFBK0I7QUFDNUQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQyxPQUFPLHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQWM7QUFDOUIsZUFBZSwrQ0FBYztBQUM3Qix3QkFBd0IsK0NBQWM7QUFDdEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvV2l0aGRyYXdhbC5qcz9kNTU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1dpdGhkcmF3YWwuUnBjfSB0byBhbiB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdpdGhkcmF3YWwgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB3aXRoZHJhd2FsID0gV2l0aGRyYXdhbC5mcm9tUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAgIGFtb3VudDogJzB4NjIwMzIzJyxcbiAqICAgaW5kZXg6ICcweDAnLFxuICogICB2YWxpZGF0b3JJbmRleDogJzB4MScsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqIC8vIEBsb2c6ICAgYW1vdW50OiA2NDIzMzMxbixcbiAqIC8vIEBsb2c6ICAgaW5kZXg6IDAsXG4gKiAvLyBAbG9nOiAgIHZhbGlkYXRvckluZGV4OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2l0aGRyYXdhbCAtIFRoZSBSUEMgd2l0aGRyYXdhbCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ud2l0aGRyYXdhbCxcbiAgICAgICAgYW1vdW50OiBCaWdJbnQod2l0aGRyYXdhbC5hbW91bnQpLFxuICAgICAgICBpbmRleDogTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogTnVtYmVyKHdpdGhkcmF3YWwudmFsaWRhdG9ySW5kZXgpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0gdG8gYW4ge0BsaW5rIG94I1dpdGhkcmF3YWwuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdpdGhkcmF3YWwgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB3aXRoZHJhd2FsID0gV2l0aGRyYXdhbC50b1JwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogICBhbW91bnQ6IDY0MjMzMzFuLFxuICogICBpbmRleDogMCxcbiAqICAgdmFsaWRhdG9ySW5kZXg6IDEsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqIC8vIEBsb2c6ICAgYW1vdW50OiAnMHg2MjAzMjMnLFxuICogLy8gQGxvZzogICBpbmRleDogJzB4MCcsXG4gKiAvLyBAbG9nOiAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3aXRoZHJhd2FsIC0gVGhlIFdpdGhkcmF3YWwgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQyBXaXRoZHJhd2FsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMod2l0aGRyYXdhbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IHdpdGhkcmF3YWwuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBIZXguZnJvbU51bWJlcih3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBIZXguZnJvbU51bWJlcih3aXRoZHJhd2FsLmluZGV4KSxcbiAgICAgICAgdmFsaWRhdG9ySW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwudmFsaWRhdG9ySW5kZXgpLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaXRoZHJhd2FsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: () => (/* binding */ getAmbiguousTypes),\n/* harmony export */   isArgOfType: () => (/* binding */ isArgOfType),\n/* harmony export */   normalizeSignature: () => (/* binding */ normalizeSignature)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(action-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */\nfunction normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nfunction isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpSXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUNGO0FBQ3ZDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWdCLFFBQVEsZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJLFNBQVMsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFnQjtBQUN2QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHVCQUF1QixpREFBZ0I7QUFDdkM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpSXRlbS5qcz81OGI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yLCB3ZSB3YW50IHRvIHJlYWN0aXZhdGUuXG4gICAgICAgIGlmIChbJygnLCAnKScsICcsJ10uaW5jbHVkZXMoY2hhcikpXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgXCJsZXZlbFwiIHRva2VuLCB3ZSB3YW50IHRvIGluY3JlbWVudC9kZWNyZW1lbnQuXG4gICAgICAgIGlmIChjaGFyID09PSAnKCcpXG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICBpZiAoY2hhciA9PT0gJyknKVxuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IGFjdGl2ZSwgd2UgZG9uJ3Qgd2FudCB0byBtdXRhdGUgdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBhdCB0aGUgZGVmaW5pdGlvbiBsZXZlbC5cbiAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnICYmIFsnZXZlbnQnLCAnZnVuY3Rpb24nLCAnZXJyb3InLCAnJ10uaW5jbHVkZXMocmVzdWx0KSlcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWZpbml0aW9uLCB3ZSBtdXN0IGJlIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgc3BhY2VzXG4gICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3IsIGFuZCB0aGUgY3VycmVudCBzZWN0aW9uIGlzbid0IGVtcHR5LCB3ZSB3YW50IHRvIGRlYWN0aXZhdGUuXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlW2kgLSAxXSAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsJyAmJiBjdXJyZW50ICE9PSAnLCgnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gICAgaWYgKCF2YWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ1VuYWJsZSB0byBub3JtYWxpemUgc2lnbmF0dXJlLicpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpIHtcbiAgICBjb25zdCBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJUeXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XG4gICAgc3dpdGNoIChhYmlQYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBpZiAoYWJpUGFyYW1ldGVyVHlwZSA9PT0gJ3R1cGxlJyAmJiAnY29tcG9uZW50cycgaW4gYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFiaVBhcmFtZXRlci5jb21wb25lbnRzKS5ldmVyeSgoY29tcG9uZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcmdPZlR5cGUoT2JqZWN0LnZhbHVlcyhhcmcpW2luZGV4XSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG4gICAgICAgICAgICBpZiAoL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdudW1iZXInIHx8IGFyZ1R5cGUgPT09ICdiaWdpbnQnO1xuICAgICAgICAgICAgLy8gYGJ5dGVzPE0+YDogYmluYXJ5IHR5cGUgb2YgYE1gIGJ5dGVzLCBgMCA8IE0gPD0gMzJgXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNTVcbiAgICAgICAgICAgIGlmICgvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICAgICAgLy8gZml4ZWQtbGVuZ3RoIChgPHR5cGU+W01dYCkgYW5kIGR5bmFtaWMgKGA8dHlwZT5bXWApIGFycmF5c1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTZpXG4gICAgICAgICAgICBpZiAoL1thLXpdK1sxLTldezAsM30oXFxbWzAtOV17MCx9XFxdKSskLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZykgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJnLmV2ZXJ5KCh4KSA9PiBpc0FyZ09mVHlwZSh4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3Agb2ZmIGBbXWAgb3IgYFtNXWAgZnJvbSBlbmQgb2YgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYWJpUGFyYW1ldGVyVHlwZS5yZXBsYWNlKC8oXFxbWzAtOV17MCx9XFxdKSQvLCAnJyksXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVycywgdGFyZ2V0UGFyYW1ldGVycywgYXJncykge1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVySW5kZXggaW4gc291cmNlUGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBzb3VyY2VQYXJhbWV0ZXIgPSBzb3VyY2VQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFyYW1ldGVyID0gdGFyZ2V0UGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGlmIChzb3VyY2VQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgdGFyZ2V0UGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiBzb3VyY2VQYXJhbWV0ZXIgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiB0YXJnZXRQYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVyLmNvbXBvbmVudHMsIHRhcmdldFBhcmFtZXRlci5jb21wb25lbnRzLCBhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMyMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAoYW1iaWd1b3VzKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/abiItem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(action-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"(action-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/** @internal */\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))), 32];\n}\n/** @internal */\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeBool(cursor) {\n    return [_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data), 32];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [value, 32];\n}\n/** @internal */\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, { signed })\n            : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nfunction prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */\nfunction encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize, 10),\n            value,\n        });\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value) };\n}\n/** @internal */\nfunction encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value)) };\n}\n/** @internal */\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nfunction encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNaO0FBQ0o7QUFDRTtBQUNOO0FBQ2E7QUFDOUM7QUFDTztBQUNQLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0IsSUFBSSx5Q0FBeUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3RELGNBQWMsK0RBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDO0FBQ2xELFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EseUNBQXlDLGlEQUFnQjtBQUN6RCxpQkFBaUIsOENBQWEsQ0FBQyw0Q0FBVztBQUMxQztBQUNBO0FBQ087QUFDUCxZQUFZLDBDQUEwQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxnREFBZSx5QkFBeUIsVUFBVTtBQUM5RDtBQUNBO0FBQ08sc0NBQXNDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQWE7QUFDN0I7QUFDQSxrQkFBa0IsOENBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBYyxVQUFVLFFBQVE7QUFDOUMsY0FBYywrQ0FBYyxVQUFVLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGdCQUFnQjtBQUN2RDtBQUNBLG1CQUFtQiwrQ0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtDQUFjLENBQUMsK0NBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixzQ0FBc0M7QUFDMUU7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLHdEQUF3RDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0RBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBOEI7QUFDNUM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLGtDQUFrQywrQ0FBYyw2QkFBNkIsVUFBVTtBQUN2RjtBQUNBLDJCQUEyQix5Q0FBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUFVO0FBQ3JCO0FBQ0E7QUFDTztBQUNQLFlBQVksbUJBQW1CO0FBQy9CLElBQUksK0NBQWMsVUFBVSxrQkFBa0I7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0Esa0JBQWtCLHVFQUFzQztBQUN4RDtBQUNBO0FBQ0EscUJBQXFCLGVBQWUsR0FBRyxPQUFPO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQ0FBYyw4QkFBOEIsVUFBVTtBQUNqRjtBQUNBO0FBQ0EseURBQXlELDJDQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVUsOEJBQThCLFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ08sOEJBQThCLE1BQU07QUFDM0M7QUFDQSxzQkFBc0IseUNBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBWTtBQUNqQztBQUNBO0FBQ0EscUJBQXFCLDJDQUFVLENBQUMsNENBQVcsQ0FBQywrQ0FBYyxjQUFjLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFvQztBQUN0RDtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEseUJBQXlCLDZDQUFZO0FBQ2xEO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLGlEQUFnQiw0QkFBNEIsTUFBTSxXQUFXLGFBQWE7QUFDNUYsYUFBYSx5QkFBeUIsNENBQVcsQ0FBQyxnREFBZTtBQUNqRTtBQUNBO0FBQ08sK0JBQStCLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFjO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUIsK0NBQWM7QUFDbkMsa0NBQWtDLHlDQUFRO0FBQzFDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxtQkFBbUIsNkNBQVksQ0FBQywwQ0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVUsQ0FBQyw2Q0FBWSxDQUFDLCtDQUFjLENBQUMseUNBQVEsY0FBYyxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUFVLDhCQUE4QixTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanM/N2JjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4uL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG5pbXBvcnQgeyBpbnRlZ2VyUmVnZXggfSBmcm9tICcuLi9Tb2xpZGl0eS5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XG4gICAgICAgIHJldHVybiBkZWNvZGVBcnJheShjdXJzb3IsIHsgLi4ucGFyYW0sIHR5cGUgfSwgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbS50eXBlID09PSAndHVwbGUnKVxuICAgICAgICByZXR1cm4gZGVjb2RlVHVwbGUoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnYWRkcmVzcycpXG4gICAgICAgIHJldHVybiBkZWNvZGVBZGRyZXNzKGN1cnNvciwgeyBjaGVja3N1bTogY2hlY2tzdW1BZGRyZXNzIH0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnYm9vbCcpXG4gICAgICAgIHJldHVybiBkZWNvZGVCb29sKGN1cnNvcik7XG4gICAgaWYgKHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgndWludCcpIHx8IHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpXG4gICAgICAgIHJldHVybiBkZWNvZGVOdW1iZXIoY3Vyc29yLCBwYXJhbSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZGVjb2RlU3RyaW5nKGN1cnNvciwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtLnR5cGUpO1xufVxuY29uc3Qgc2l6ZU9mTGVuZ3RoID0gMzI7XG5jb25zdCBzaXplT2ZPZmZzZXQgPSAzMjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBZGRyZXNzKGN1cnNvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGVja3N1bSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gY3Vyc29yLnJlYWRCeXRlcygzMik7XG4gICAgY29uc3Qgd3JhcCA9IChhZGRyZXNzKSA9PiBjaGVja3N1bSA/IEFkZHJlc3MuY2hlY2tzdW0oYWRkcmVzcykgOiBhZGRyZXNzO1xuICAgIHJldHVybiBbd3JhcChIZXguZnJvbUJ5dGVzKEJ5dGVzLnNsaWNlKHZhbHVlLCAtMjApKSksIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMgbm90IGtub3duIGluIGFkdmFuY2UgKGR5bmFtaWMgYXJyYXkpLFxuICAgIC8vIHRoaXMgbWVhbnMgd2Ugd2lsbCBuZWVkIHRvIHdvbmRlciBvZmYgdG8gdGhlIHBvaW50ZXIgYW5kIGRlY29kZS5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggYSBkeW5hbWljIHR5cGUsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBzdGFydCArIHNpemVPZkxlbmd0aDtcbiAgICAgICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGZyb20gdGhlIG9mZnNldC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZMZW5ndGgpKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5IGhhcyBhbnkgZHluYW1pYyBjaGlsZHJlbi5cbiAgICAgICAgY29uc3QgZHluYW1pY0NoaWxkID0gaGFzRHluYW1pY0NoaWxkKHBhcmFtKTtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBjaGlsZHJlbiBpcyBkeW5hbWljLCB0aGVuIGFsbCBlbGVtZW50cyB3aWxsIGJlIG9mZnNldCBwb2ludGVyLCB0aHVzIHNpemUgb2Ygb25lIHNsb3QgKDMyIGJ5dGVzKS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZWxlbWVudHMgd2lsbCBiZSB0aGUgc2l6ZSBvZiB0aGVpciBlbmNvZGluZyAoY29uc3VtZWQgYnl0ZXMpLlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0T2ZEYXRhICsgKGR5bmFtaWNDaGlsZCA/IGkgKiAzMiA6IGNvbnN1bWVkKSk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydE9mRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIGtub3duIGluIGFkdmFuY2UsXG4gICAgLy8gYW5kIHRoZSBsZW5ndGggb2YgYW4gZWxlbWVudCBkZWVwbHkgbmVzdGVkIGluIHRoZSBhcnJheSBpcyBub3Qga25vd24sXG4gICAgLy8gd2UgbmVlZCB0byBkZWNvZGUgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICBpZiAoaGFzRHluYW1pY0NoaWxkKHBhcmFtKSkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggZHluYW1pYyB0eXBlcywgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgY3VycmVudCBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGN1cnNvciBhbG9uZyB0byB0aGUgbmV4dCBzbG90IChuZXh0IG9mZnNldCBwb2ludGVyKS5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGkgKiAzMik7XG4gICAgICAgICAgICBjb25zdCBbZGF0YV0gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBrbm93biBpbiBhZHZhbmNlIGFuZCB0aGUgYXJyYXkgaXMgZGVlcGx5IHN0YXRpYyxcbiAgICAvLyB0aGVuIHdlIGNhbiBqdXN0IGRlY29kZSBlYWNoIGVsZW1lbnQgaW4gc2VxdWVuY2UuXG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXRpY1Bvc2l0aW9uICsgY29uc3VtZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCb29sKGN1cnNvcikge1xuICAgIHJldHVybiBbQnl0ZXMudG9Cb29sZWFuKGN1cnNvci5yZWFkQnl0ZXMoMzIpLCB7IHNpemU6IDMyIH0pLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQnl0ZXMoY3Vyc29yLCBwYXJhbSwgeyBzdGF0aWNQb3NpdGlvbiB9KSB7XG4gICAgY29uc3QgW18sIHNpemVdID0gcGFyYW0udHlwZS5zcGxpdCgnYnl0ZXMnKTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlcyBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgICAgIC8vIFNldCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIHRvIHN0YXJ0IG9mIGJ5dGVzIGRhdGEuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbGVuZ3RoLCB3ZSBoYXZlIHplcm8gZGF0YS5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgICAgICByZXR1cm4gWycweCcsIDMyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW0hleC5mcm9tQnl0ZXMoZGF0YSksIDMyXTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBIZXguZnJvbUJ5dGVzKGN1cnNvci5yZWFkQnl0ZXMoTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSwgMzIpKTtcbiAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTnVtYmVyKGN1cnNvciwgcGFyYW0pIHtcbiAgICBjb25zdCBzaWduZWQgPSBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpO1xuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIucGFyc2VJbnQocGFyYW0udHlwZS5zcGxpdCgnaW50JylbMV0gfHwgJzI1NicsIDEwKTtcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNpemUgPiA0OFxuICAgICAgICAgICAgPyBCeXRlcy50b0JpZ0ludCh2YWx1ZSwgeyBzaWduZWQgfSlcbiAgICAgICAgICAgIDogQnl0ZXMudG9OdW1iZXIodmFsdWUsIHsgc2lnbmVkIH0pLFxuICAgICAgICAzMixcbiAgICBdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgLy8gVHVwbGVzIGNhbiBoYXZlIHVubmFtZWQgY29tcG9uZW50cyAoaS5lLiB0aGV5IGFyZSBhcnJheXMpLCBzbyB3ZSBtdXN0XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHR1cGxlIGlzIG5hbWVkIG9yIHVubmFtZWQuIEluIHRoZSBjYXNlIG9mIGEgbmFtZWRcbiAgICAvLyB0dXBsZSwgdGhlIHZhbHVlIHdpbGwgYmUgYW4gb2JqZWN0IHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdGhlIG5hbWUgb2YgdGhlXG4gICAgLy8gY29tcG9uZW50LiBJbiB0aGUgY2FzZSBvZiBhbiB1bm5hbWVkIHR1cGxlLCB0aGUgdmFsdWUgd2lsbCBiZSBhbiBhcnJheS5cbiAgICBjb25zdCBoYXNVbm5hbWVkQ2hpbGQgPSBwYXJhbS5jb21wb25lbnRzLmxlbmd0aCA9PT0gMCB8fCBwYXJhbS5jb21wb25lbnRzLnNvbWUoKHsgbmFtZSB9KSA9PiAhbmFtZSk7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdmFsdWUgdG8gYW4gb2JqZWN0IG9yIGFuIGFycmF5LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGVcbiAgICAvLyB0dXBsZSBpcyBuYW1lZCBvciB1bm5hbWVkLlxuICAgIGNvbnN0IHZhbHVlID0gaGFzVW5uYW1lZENoaWxkID8gW10gOiB7fTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIC8vIElmIHRoZSB0dXBsZSBoYXMgYSBkeW5hbWljIGNoaWxkLCB3ZSBtdXN0IGZpcnN0IGRlY29kZSB0aGUgb2Zmc2V0IHRvIHRoZVxuICAgIC8vIHR1cGxlIGRhdGEuXG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSB0dXBsZSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIHJlZmVyZW5jaW5nIHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGNvbnN1bWVkKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgY29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHR1cGxlIGhhcyBzdGF0aWMgY2hpbGRyZW4sIHdlIGNhbiBqdXN0IGRlY29kZSBlYWNoIGNvbXBvbmVudFxuICAgIC8vIGluIHNlcXVlbmNlLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBwYXJhbS5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZVtoYXNVbm5hbWVkQ2hpbGQgPyBpIDogY29tcG9uZW50Py5uYW1lXSA9IGRhdGE7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgY29uc3VtZWRdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZyhjdXJzb3IsIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIC8vIEdldCBvZmZzZXQgdG8gc3RhcnQgb2Ygc3RyaW5nIGRhdGEuXG4gICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgY3VycmVudCBzbG90ICsgb2Zmc2V0LlxuICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbGVuZ3RoLCB3ZSBoYXZlIHplcm8gZGF0YSAoZW1wdHkgc3RyaW5nKS5cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFsnJywgMzJdO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgsIDMyKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJ5dGVzLnRvU3RyaW5nKEJ5dGVzLnRyaW1MZWZ0KGRhdGEpKTtcbiAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXJzKHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXJzLCB2YWx1ZXMsIH0pIHtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtZXRlcnNbaV0sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJlZFBhcmFtZXRlcnM7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVBhcmFtZXRlcih7IGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlLCBwYXJhbWV0ZXI6IHBhcmFtZXRlcl8sIHZhbHVlLCB9KSB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyXztcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW1ldGVyLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XG4gICAgICAgIHJldHVybiBlbmNvZGVBcnJheSh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAndHVwbGUnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVUdXBsZSh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW06IGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBjb25zdCBzaWduZWQgPSBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICAgICAgY29uc3QgWywgLCBzaXplID0gJzI1NiddID0gaW50ZWdlclJlZ2V4LmV4ZWMocGFyYW1ldGVyLnR5cGUpID8/IFtdO1xuICAgICAgICByZXR1cm4gZW5jb2RlTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICBzaXplOiBOdW1iZXIoc2l6ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQnl0ZXModmFsdWUsIHsgdHlwZTogcGFyYW1ldGVyLnR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3IocGFyYW1ldGVyLnR5cGUpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpIHtcbiAgICAvLyAxLiBDb21wdXRlIHRoZSBzaXplIG9mIHRoZSBzdGF0aWMgcGFydCBvZiB0aGUgcGFyYW1ldGVycy5cbiAgICBsZXQgc3RhdGljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKVxuICAgICAgICAgICAgc3RhdGljU2l6ZSArPSAzMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RhdGljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICB9XG4gICAgLy8gMi4gU3BsaXQgdGhlIHBhcmFtZXRlcnMgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMuXG4gICAgY29uc3Qgc3RhdGljUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGR5bmFtaWNQYXJhbWV0ZXJzID0gW107XG4gICAgbGV0IGR5bmFtaWNTaXplID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGR5bmFtaWMsIGVuY29kZWQgfSA9IHByZXBhcmVkUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChIZXguZnJvbU51bWJlcihzdGF0aWNTaXplICsgZHluYW1pY1NpemUsIHsgc2l6ZTogMzIgfSkpO1xuICAgICAgICAgICAgZHluYW1pY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgICAgIGR5bmFtaWNTaXplICs9IEhleC5zaXplKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGljUGFyYW1ldGVycy5wdXNoKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDMuIENvbmNhdGVuYXRlIHN0YXRpYyBhbmQgZHluYW1pYyBwYXJ0cy5cbiAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5zdGF0aWNQYXJhbWV0ZXJzLCAuLi5keW5hbWljUGFyYW1ldGVycyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQWRkcmVzcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW0gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBBZGRyZXNzLmFzc2VydCh2YWx1ZSwgeyBzdHJpY3Q6IGNoZWNrc3VtIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXgucGFkTGVmdCh2YWx1ZS50b0xvd2VyQ2FzZSgpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFycmF5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgcGFyYW1ldGVyIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBsZW5ndGggPT09IG51bGw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3IodmFsdWUpO1xuICAgIGlmICghZHluYW1pYyAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgdHlwZTogYCR7cGFyYW1ldGVyLnR5cGV9WyR7bGVuZ3RofV1gLFxuICAgICAgICB9KTtcbiAgICBsZXQgZHluYW1pY0NoaWxkID0gZmFsc2U7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pY0NoaWxkID0gdHJ1ZTtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZWRQYXJhbSk7XG4gICAgfVxuICAgIGlmIChkeW5hbWljIHx8IGR5bmFtaWNDaGlsZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBIZXguZnJvbU51bWJlcihwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoLCB7IHNpemU6IDMyIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuY29kZWQ6IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGggPiAwID8gSGV4LmNvbmNhdChsZW5ndGgsIGRhdGEpIDogbGVuZ3RoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIHsgZHluYW1pYzogdHJ1ZSwgZW5jb2RlZDogZGF0YSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQnl0ZXModmFsdWUsIHsgdHlwZSB9KSB7XG4gICAgY29uc3QgWywgcGFyYW1ldGVyc2l6ZV0gPSB0eXBlLnNwbGl0KCdieXRlcycpO1xuICAgIGNvbnN0IGJ5dGVzU2l6ZSA9IEhleC5zaXplKHZhbHVlKTtcbiAgICBpZiAoIXBhcmFtZXRlcnNpemUpIHtcbiAgICAgICAgbGV0IHZhbHVlXyA9IHZhbHVlO1xuICAgICAgICAvLyBJZiB0aGUgc2l6ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IDMyIGJ5dGVzLCBwYWQgdGhlIGVuZFxuICAgICAgICAvLyB3aXRoIGVtcHR5IGJ5dGVzIHRvIHRoZSBjZWlsaW5nIDMyIGJ5dGVzLlxuICAgICAgICBpZiAoYnl0ZXNTaXplICUgMzIgIT09IDApXG4gICAgICAgICAgICB2YWx1ZV8gPSBIZXgucGFkUmlnaHQodmFsdWVfLCBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMiAvIDMyKSAqIDMyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgICAgICBlbmNvZGVkOiBIZXguY29uY2F0KEhleC5wYWRMZWZ0KEhleC5mcm9tTnVtYmVyKGJ5dGVzU2l6ZSwgeyBzaXplOiAzMiB9KSksIHZhbHVlXyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChieXRlc1NpemUgIT09IE51bWJlci5wYXJzZUludChwYXJhbWV0ZXJzaXplLCAxMCkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSwgMTApLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkUmlnaHQodmFsdWUpIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQm9vbGVhbih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoYEludmFsaWQgYm9vbGVhbiB2YWx1ZTogXCIke3ZhbHVlfVwiICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pLiBFeHBlY3RlZDogXFxgdHJ1ZVxcYCBvciBcXGBmYWxzZVxcYC5gKTtcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogSGV4LnBhZExlZnQoSGV4LmZyb21Cb29sZWFuKHZhbHVlKSkgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVOdW1iZXIodmFsdWUsIHsgc2lnbmVkLCBzaXplIH0pIHtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IG1heCA9IDJuICoqIChCaWdJbnQoc2l6ZSkgLSAoc2lnbmVkID8gMW4gOiAwbikpIC0gMW47XG4gICAgICAgIGNvbnN0IG1pbiA9IHNpZ25lZCA/IC1tYXggLSAxbiA6IDBuO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heDogbWF4LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbWluOiBtaW4udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSAvIDgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5mcm9tTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICBzaXplOiAzMixcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBoZXhWYWx1ZSA9IEhleC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXJ0c0xlbmd0aCA9IE1hdGguY2VpbChIZXguc2l6ZShoZXhWYWx1ZSkgLyAzMik7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChIZXgucGFkUmlnaHQoSGV4LnNsaWNlKGhleFZhbHVlLCBpICogMzIsIChpICsgMSkgKiAzMikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkUmlnaHQoSGV4LmZyb21OdW1iZXIoSGV4LnNpemUoaGV4VmFsdWUpLCB7IHNpemU6IDMyIH0pKSwgLi4ucGFydHMpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVHVwbGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgcGFyYW1ldGVyIH0gPSBvcHRpb25zO1xuICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXIuY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJhbV8gPSBwYXJhbWV0ZXIuY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGkgOiBwYXJhbV8ubmFtZTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbV8sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVbaW5kZXhdLFxuICAgICAgICB9KTtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZWRQYXJhbSk7XG4gICAgICAgIGlmIChwcmVwYXJlZFBhcmFtLmR5bmFtaWMpXG4gICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYyxcbiAgICAgICAgZW5jb2RlZDogZHluYW1pY1xuICAgICAgICAgICAgPyBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKVxuICAgICAgICAgICAgOiBIZXguY29uY2F0KC4uLnByZXBhcmVkUGFyYW1ldGVycy5tYXAoKHsgZW5jb2RlZCB9KSA9PiBlbmNvZGVkKSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcnJheUNvbXBvbmVudHModHlwZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0eXBlLm1hdGNoKC9eKC4qKVxcWyhcXGQrKT9cXF0kLyk7XG4gICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgPyAvLyBSZXR1cm4gYG51bGxgIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljLlxuICAgICAgICAgICAgW21hdGNoZXNbMl0gPyBOdW1iZXIobWF0Y2hlc1syXSkgOiBudWxsLCBtYXRjaGVzWzFdXVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNEeW5hbWljQ2hpbGQocGFyYW0pIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHBhcmFtO1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlLmVuZHNXaXRoKCdbXScpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3R1cGxlJylcbiAgICAgICAgcmV0dXJuIHBhcmFtLmNvbXBvbmVudHM/LnNvbWUoaGFzRHluYW1pY0NoaWxkKTtcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cyAmJlxuICAgICAgICBoYXNEeW5hbWljQ2hpbGQoe1xuICAgICAgICAgICAgLi4ucGFyYW0sXG4gICAgICAgICAgICB0eXBlOiBhcnJheUNvbXBvbmVudHNbMV0sXG4gICAgICAgIH0pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(action-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUM7QUFDckM7QUFDTztBQUNQLFFBQVEsMkNBQVU7QUFDbEIsa0JBQWtCLHdEQUF1QjtBQUN6Qyx1QkFBdUIsMkNBQVU7QUFDakM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsMERBQTBELDJDQUFVO0FBQ3BFLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsMkNBQVU7QUFDbEIsa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQztBQUN2QyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUNBQWlDO0FBQ3hDLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9ieXRlcy5qcz8zNTIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4uL0J5dGVzLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTaXplKGJ5dGVzLCBzaXplXykge1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSA+IHNpemVfKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3Ioe1xuICAgICAgICAgICAgZ2l2ZW5TaXplOiBCeXRlcy5zaXplKGJ5dGVzKSxcbiAgICAgICAgICAgIG1heFNpemU6IHNpemVfLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBCeXRlcy5zaXplKHZhbHVlKSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmXG4gICAgICAgIEJ5dGVzLnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBjaGFyQ29kZU1hcCA9IHtcbiAgICB6ZXJvOiA0OCxcbiAgICBuaW5lOiA1NyxcbiAgICBBOiA2NSxcbiAgICBGOiA3MCxcbiAgICBhOiA5NyxcbiAgICBmOiAxMDIsXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYXJDb2RlVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGNoYXJDb2RlTWFwLnplcm8gJiYgY2hhciA8PSBjaGFyQ29kZU1hcC5uaW5lKVxuICAgICAgICByZXR1cm4gY2hhciAtIGNoYXJDb2RlTWFwLnplcm87XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuQSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLkYpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGNoYXJDb2RlTWFwLkEgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuYSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLmYpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGNoYXJDb2RlTWFwLmEgLSAxMCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWQoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcih7XG4gICAgICAgICAgICBzaXplOiBieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICB0YXJnZXRTaXplOiBzaXplLFxuICAgICAgICAgICAgdHlwZTogJ0J5dGVzJyxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBwYWRFbmQgPSBkaXIgPT09ICdyaWdodCc7XG4gICAgICAgIHBhZGRlZEJ5dGVzW3BhZEVuZCA/IGkgOiBzaXplIC0gaSAtIDFdID1cbiAgICAgICAgICAgIGJ5dGVzW3BhZEVuZCA/IGkgOiBieXRlcy5sZW5ndGggLSBpIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBwYWRkZWRCeXRlcztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nfunction create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nclass NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nclass PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nclass RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvY3Vyc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ08seUJBQXlCLDZCQUE2QixJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQixRQUFRO0FBQzFCLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGlEQUFnQjtBQUM5RCxrQkFBa0Isa0JBQWtCO0FBQ3BDLDRCQUE0QixTQUFTLHdDQUF3QyxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sOENBQThDLGlEQUFnQjtBQUNyRSxrQkFBa0IsY0FBYztBQUNoQywyQ0FBMkMsTUFBTSx1Q0FBdUMsTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcz9lMTgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuY29uc3Qgc3RhdGljQ3Vyc29yID0ge1xuICAgIGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgIGRhdGFWaWV3OiBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSxcbiAgICBwb3NpdGlvbjogMCxcbiAgICBwb3NpdGlvblJlYWRDb3VudDogbmV3IE1hcCgpLFxuICAgIHJlY3Vyc2l2ZVJlYWRDb3VudDogMCxcbiAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBhc3NlcnRSZWFkTGltaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgKyAxLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gLSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBnZXRSZWFkQ291bnQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25SZWFkQ291bnQuZ2V0KHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb24pIHx8IDA7XG4gICAgfSxcbiAgICBpbmNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGUocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZXMobGVuZ3RoLCBwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIGxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQ4KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQxNihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQyNChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDIpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbikgPDwgOCkgK1xuICAgICAgICAgICAgdGhpcy5kYXRhVmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MzIocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHB1c2hCeXRlKGJ5dGUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGJ5dGU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hCeXRlcyhieXRlcykge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzLmxlbmd0aDtcbiAgICB9LFxuICAgIHB1c2hVaW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hVaW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMSk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIH0sXG4gICAgcHVzaFVpbnQyNCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUgPj4gOCk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIsIHZhbHVlICYgfjQyOTQ5NjcwNDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgfSxcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDMpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBzaXplKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplID8/IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MTYoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDI0KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQyNCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MzIoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLnBvc2l0aW9uID0gb2xkUG9zaXRpb24pO1xuICAgIH0sXG4gICAgX3RvdWNoKCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkTGltaXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldFJlYWRDb3VudCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uUmVhZENvdW50LnNldCh0aGlzLnBvc2l0aW9uLCBjb3VudCArIDEpO1xuICAgICAgICBpZiAoY291bnQgPiAwKVxuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQrKztcbiAgICB9LFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYnl0ZXMsIHsgcmVjdXJzaXZlUmVhZExpbWl0ID0gOF8xOTIgfSA9IHt9KSB7XG4gICAgY29uc3QgY3Vyc29yID0gT2JqZWN0LmNyZWF0ZShzdGF0aWNDdXJzb3IpO1xuICAgIGN1cnNvci5ieXRlcyA9IGJ5dGVzO1xuICAgIGN1cnNvci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIGN1cnNvci5wb3NpdGlvblJlYWRDb3VudCA9IG5ldyBNYXAoKTtcbiAgICBjdXJzb3IucmVjdXJzaXZlUmVhZExpbWl0ID0gcmVjdXJzaXZlUmVhZExpbWl0O1xuICAgIHJldHVybiBjdXJzb3I7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgTmVnYXRpdmVPZmZzZXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0IH0pIHtcbiAgICAgICAgc3VwZXIoYE9mZnNldCBcXGAke29mZnNldH1cXGAgY2Fubm90IGJlIG5lZ2F0aXZlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLk5lZ2F0aXZlT2Zmc2V0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGxlbmd0aCwgcG9zaXRpb24gfSkge1xuICAgICAgICBzdXBlcihgUG9zaXRpb24gXFxgJHtwb3NpdGlvbn1cXGAgaXMgb3V0IG9mIGJvdW5kcyAoXFxgMCA8IHBvc2l0aW9uIDwgJHtsZW5ndGh9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5Qb3NpdGlvbk91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjb3VudCwgbGltaXQgfSkge1xuICAgICAgICBzdXBlcihgUmVjdXJzaXZlIHJlYWQgbGltaXQgb2YgXFxgJHtsaW1pdH1cXGAgZXhjZWVkZWQgKHJlY3Vyc2l2ZSByZWFkIGNvdW50OiBcXGAke2NvdW50fVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Vyc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/entropy.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/entropy.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extraEntropy: () => (/* binding */ extraEntropy),\n/* harmony export */   setExtraEntropy: () => (/* binding */ setExtraEntropy)\n/* harmony export */ });\nlet extraEntropy = false;\n/** @internal */\nfunction setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n}\n//# sourceMappingURL=entropy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvZW50cm9weS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2VudHJvcHkuanM/NWIzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgbGV0IGV4dHJhRW50cm9weSA9IGZhbHNlO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEV4dHJhRW50cm9weShlbnRyb3B5KSB7XG4gICAgZXh0cmFFbnRyb3B5ID0gZW50cm9weTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudHJvcHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/entropy.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(action-browser)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDeEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxnREFBTztBQUNsQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRyxJQUFJLDJCQUEyQixFQUFFLE1BQU07QUFDOUU7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvZXJyb3JzLmpzP2ZiOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24uanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHZlcnNpb247XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcHJldHR5UHJpbnQoYXJncykge1xuICAgIGlmICghYXJncylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBtYXhMZW5ndGggPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBba2V5XSkgPT4gTWF0aC5tYXgoYWNjLCBrZXkubGVuZ3RoKSwgMCk7XG4gICAgcmV0dXJuIGVudHJpZXNcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgICAke2Ake2tleX06YC5wYWRFbmQobWF4TGVuZ3RoICsgMSl9ICAke3ZhbHVlfWApXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpQztBQUNqQztBQUNPO0FBQ1AsUUFBUSx5Q0FBUTtBQUNoQixrQkFBa0Isc0RBQXFCO0FBQ3ZDLHVCQUF1Qix5Q0FBUTtBQUMvQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCwwREFBMEQseUNBQVE7QUFDbEUsa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFRO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSx5Q0FBUTtBQUNoQixrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IseUNBQVE7QUFDMUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLCtCQUErQjtBQUN0QyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQTtBQUNPLGlDQUFpQztBQUN4QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcz82ZjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9IZXguanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoaGV4LCBzaXplXykge1xuICAgIGlmIChIZXguc2l6ZShoZXgpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBIZXguU2l6ZU92ZXJmbG93RXJyb3Ioe1xuICAgICAgICAgICAgZ2l2ZW5TaXplOiBIZXguc2l6ZShoZXgpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEhleC5zaXplKHZhbHVlKSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgSGV4LnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IGVuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChoZXhfLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciwgc2l6ZSA9IDMyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzaXplID09PSAwKVxuICAgICAgICByZXR1cm4gaGV4XztcbiAgICBjb25zdCBoZXggPSBoZXhfLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGlmIChoZXgubGVuZ3RoID4gc2l6ZSAqIDIpXG4gICAgICAgIHRocm93IG5ldyBIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMiksXG4gICAgICAgICAgICB0YXJnZXRTaXplOiBzaXplLFxuICAgICAgICAgICAgdHlwZTogJ0hleCcsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiBgMHgke2hleFtkaXIgPT09ICdyaWdodCcgPyAncGFkRW5kJyA6ICdwYWRTdGFydCddKHNpemUgKiAyLCAnMCcpfWA7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIgPSAnbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRhdGEgPSB2YWx1ZS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIGlmIChkYXRhID09PSAnMCcpXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIGlmIChkaXIgPT09ICdyaWdodCcgJiYgZGF0YS5sZW5ndGggJSAyID09PSAxKVxuICAgICAgICByZXR1cm4gYDB4JHtkYXRhfTBgO1xuICAgIHJldHVybiBgMHgke2RhdGF9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvbHJ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2xydS5qcz9mYmYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGludGVybmFsXG4gKlxuICogTWFwIHdpdGggYSBMUlUgKExlYXN0IHJlY2VudGx5IHVzZWQpIHBvbGljeS5cbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXMjTFJVXG4gKi9cbmV4cG9ydCBjbGFzcyBMcnVNYXAgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuZ2V0KGtleSk7XG4gICAgICAgIGlmIChzdXBlci5oYXMoa2V5KSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5tYXhTaXplICYmIHRoaXMuc2l6ZSA+IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXkpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoZmlyc3RLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxydS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvdmVyc2lvbi5qcz8wYjBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzAuMS4xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc6492/SignatureErc6492.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   universalSignatureValidatorAbi: () => (/* binding */ universalSignatureValidatorAbi),\n/* harmony export */   universalSignatureValidatorBytecode: () => (/* binding */ universalSignatureValidatorBytecode),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nconst magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nconst universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nconst universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nfunction assert(wrapped) {\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nfunction from(wrapped) {\n    if (typeof wrapped === 'string')\n        return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from('address, bytes, bytes'), wrapped);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nfunction wrap(value) {\n    const { data, signature, to } = value;\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from('address, bytes, bytes'), [\n        to,\n        data,\n        signature,\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nfunction validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nclass InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc6492.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc6492.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2VyYzY0OTIvU2lnbmF0dXJlRXJjNjQ5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDZDtBQUNOO0FBQ3RDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSwrQ0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCLEtBQUssaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsNEJBQTRCLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtDQUFrQywwREFBb0IsQ0FBQyx3REFBa0I7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHNCQUFzQjtBQUNsQyxXQUFXLGdEQUFVLENBQUMsMERBQW9CLENBQUMsd0RBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLHNEQUFnQjtBQUNsRTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2VyYzY0OTIvU2lnbmF0dXJlRXJjNjQ5Mi5qcz8yNTZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi4vY29yZS9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9jb3JlL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuLyoqXG4gKiBNYWdpYyBieXRlcyB1c2VkIHRvIGlkZW50aWZ5IEVSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hZ2ljQnl0ZXMgPSAnMHg2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyJztcbi8qKlxuICogRGVwbG95bGVzcyBFUkMtNjQ5MiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGJ5dGVjb2RlLlxuICovXG5leHBvcnQgY29uc3QgdW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQnl0ZWNvZGUgPSAnMHg2MDgwNjA0MDUyMzQ4MDE1NjEwMDEwNTc2MDAwODBmZDViNTA2MDQwNTE2MTA2OTQzODAzODA2MTA2OTQ4MzM5ODEwMTYwNDA4MTkwNTI2MTAwMmY5MTYxMDUxZTU2NWI2MDAwNjEwMDNjODQ4NDg0NjEwMDQ4NTY1YjkwNTA4MDYwMDA1MjYwMDE2MDFmZjM1YjYwMDA3ZjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2MTAwNzQ4MzYxMDQwYzU2NWIwMzYxMDFlNzU3NjAwMDYwNjA4MDg0ODA2MDIwMDE5MDUxODEwMTkwNjEwMDkyOTE5MDYxMDU3NzU2NWI2MDQwNTE5Mjk1NTA5MDkzNTA5MTUwNjAwMDkwNjAwMTYwMDE2MGEwMWIwMzg1MTY5MDYxMDBiNjkwODU5MDYxMDVkZDU2NWI2MDAwNjA0MDUxODA4MzAzODE2MDAwODY1YWYxOTE1MDUwM2Q4MDYwMDA4MTE0NjEwMGYzNTc2MDQwNTE5MTUwNjAxZjE5NjAzZjNkMDExNjgyMDE2MDQwNTIzZDgyNTIzZDYwMDA2MDIwODQwMTNlNjEwMGY4NTY1YjYwNjA5MTUwNWI1MDUwOTA1MDg3NjAwMTYwMDE2MGEwMWIwMzE2M2I2MDAwMDM2MTAxNjA1NzgwNjEwMTYwNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMWU2MDI0ODIwMTUyN2Y1MzY5Njc2ZTYxNzQ3NTcyNjU1NjYxNmM2OTY0NjE3NDZmNzIzYTIwNjQ2NTcwNmM2Zjc5NmQ2NTZlNzQwMDAwNjA0NDgyMDE1MjYwNjQwMTViNjA0MDUxODA5MTAzOTBmZDViNjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzhhMTY5MDYzMTYyNmJhN2U5MDYxMDE5MDkwOGI5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMWFkNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAxZDE5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5NDUwNTA1MDUwNTA2MTA0MDU1NjViNjAwMTYwMDE2MGEwMWIwMzg0MTYzYjE1NjEwMjdhNTc2MDQwNTE2MzBiMTM1ZDNmNjBlMTFiODA4MjUyOTA2MDAxNjAwMTYwYTAxYjAzODYxNjkwNjMxNjI2YmE3ZTkwNjEwMjI3OTA4NzkwODc5MDYwMDQwMTYxMDVmOTU2NWI2MDIwNjA0MDUxODA4MzAzODE4NjVhZmExNTgwMTU2MTAyNDQ1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNTA2MDQwNTEzZDYwMWYxOTYwMWY4MjAxMTY4MjAxODA2MDQwNTI1MDgxMDE5MDYxMDI2ODkxOTA2MTA2MzM1NjViNjAwMTYwMDE2MGUwMWIwMzE5MTYxNDkwNTA2MTA0MDU1NjViODE1MTYwNDExNDYxMDJkZjU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDNhNjAyNDgyMDE1MjYwMDA4MDUxNjAyMDYxMDY3NDgzMzk4MTUxOTE1MjYwNDQ4MjAxNTI3ZjNhMjA2OTZlNzY2MTZjNjk2NDIwNzM2OTY3NmU2MTc0NzU3MjY1MjA2YzY1NmU2Nzc0NjgwMDAwMDAwMDAwMDA2MDY0ODIwMTUyNjA4NDAxNjEwMTU3NTY1YjYxMDJlNzYxMDQyNTU2NWI1MDYwMjA4MjAxNTE2MDQwODA4NDAxNTE4NDUxODU5MzkyNjAwMDkxODU5MTkwODExMDYxMDMwYzU3NjEwMzBjNjEwNjVkNTY1YjAxNjAyMDAxNTE2MGY4MWM5MDUwNjAxYjgxMTQ4MDE1OTA2MTAzMmI1NzUwODA2MGZmMTY2MDFjMTQxNTViMTU2MTAzOGM1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYjYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNzYyMDc2NjE2Yzc1NjUwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MDQwODA1MTYwMDA4MTUyNjAyMDgxMDE4MDgzNTI4OTkwNTI2MGZmODMxNjkxODEwMTkxOTA5MTUyNjA2MDgxMDE4NDkwNTI2MDgwODEwMTgzOTA1MjYwMDE2MDAxNjBhMDFiMDM4OTE2OTA2MDAxOTA2MGEwMDE2MDIwNjA0MDUxNjAyMDgxMDM5MDgwODQwMzkwODU1YWZhMTU4MDE1NjEwM2VhNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDYwMjA2MDQwNTEwMzUxNjAwMTYwMDE2MGEwMWIwMzE2MTQ5NDUwNTA1MDUwNTA1YjkzOTI1MDUwNTA1NjViNjAwMDYwMjA4MjUxMTAxNTYxMDQxZDU3NjAwMDgwZmQ1YjUwODA1MTAxNTE5MDU2NWI2MDQwNTE4MDYwNjAwMTYwNDA1MjgwNjAwMzkwNjAyMDgyMDI4MDM2ODMzNzUwOTE5MjkxNTA1MDU2NWI2MDAxNjAwMTYwYTAxYjAzODExNjgxMTQ2MTA0NTg1NzYwMDA4MGZkNWI1MDU2NWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjA0MTYwMDQ1MjYwMjQ2MDAwZmQ1YjYwMDA1YjgzODExMDE1NjEwNDhjNTc4MTgxMDE1MTgzODIwMTUyNjAyMDAxNjEwNDc0NTY1YjUwNTA2MDAwOTEwMTUyNTY1YjYwMDA4MjYwMWY4MzAxMTI2MTA0YTY1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDRiZjU3NjEwNGJmNjEwNDViNTY1YjYwNDA1MTYwMWY4MjAxNjAxZjE5OTA4MTE2NjAzZjAxMTY4MTAxNjAwMTYwMDE2MDQwMWIwMzgxMTE4MjgyMTAxNzE1NjEwNGVkNTc2MTA0ZWQ2MTA0NWI1NjViNjA0MDUyODE4MTUyODM4MjAxNjAyMDAxODUxMDE1NjEwNTA1NTc2MDAwODBmZDViNjEwNTE2ODI2MDIwODMwMTYwMjA4NzAxNjEwNDcxNTY1Yjk0OTM1MDUwNTA1MDU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTA1MzM1NzYwMDA4MGZkNWI4MzUxNjEwNTNlODE2MTA0NDM1NjViNjAyMDg1MDE1MTYwNDA4NjAxNTE5MTk0NTA5MjUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYxMDU2ZDg2ODI4NzAxNjEwNDk1NTY1YjkxNTA1MDkyNTA5MjUwOTI1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNThjNTc2MDAwODBmZDViODM1MTYxMDU5NzgxNjEwNDQzNTY1YjYwMjA4NTAxNTE5MDkzNTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwNWIzNTc2MDAwODBmZDViNjEwNWJmODY4Mjg3MDE2MTA0OTU1NjViNjA0MDg2MDE1MTkwOTM1MDkwNTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwNTYxNTc2MDAwODBmZDViNjAwMDgyNTE2MTA1ZWY4MTg0NjAyMDg3MDE2MTA0NzE1NjViOTE5MDkxMDE5MjkxNTA1MDU2NWI4MjgxNTI2MDQwNjAyMDgyMDE1MjYwMDA4MjUxODA2MDQwODQwMTUyNjEwNjFlODE2MDYwODUwMTYwMjA4NzAxNjEwNDcxNTY1YjYwMWYwMTYwMWYxOTE2OTE5MDkxMDE2MDYwMDE5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxMDY0NTU3NjAwMDgwZmQ1YjgxNTE2MDAxNjAwMTYwZTAxYjAzMTk4MTE2ODExNDYxMDQwNTU3NjAwMDgwZmQ1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDMyNjAwNDUyNjAyNDYwMDBmZGZlNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyMjM3MjY1NjM2Zjc2NjU3MjUzNjk2NzZlNjU3Mic7XG4vKipcbiAqIEFCSSBmb3IgdGhlIEVSQy02NDkyIHVuaXZlcnNhbCBkZXBsb3lsZXNzIHNpZ25hdHVyZSB2YWxpZGF0b3IgY29udHJhY3QuXG4gKlxuICogQ29uc3RydWN0b3IgcmV0dXJuIHZhbHVlIGlzIGAweDFgICh2YWxpZCkgb3IgYDB4MGAgKGludmFsaWQpLlxuICovXG5leHBvcnQgY29uc3QgdW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQWJpID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19oYXNoJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdjb25zdHJ1Y3RvcicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfaGFzaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbmFtZTogJ2lzVmFsaWRTaWcnLFxuICAgIH0sXG5dO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInXG4gKlxuICogU2lnbmF0dXJlRXJjNjQ5Mi5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yOiBWYWx1ZSBgMHhkZWFkYmVlZmAgaXMgYW4gaW52YWxpZCBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gVGhlIHdyYXBwZWQgc2lnbmF0dXJlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh3cmFwcGVkKSB7XG4gICAgaWYgKEhleC5zbGljZSh3cmFwcGVkLCAtMzIpICE9PSBtYWdpY0J5dGVzKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcih3cmFwcGVkKTtcbn1cbi8qKlxuICogUGFyc2VzIGFuIFtFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyI3NwZWNpZmljYXRpb24pIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBmcm9tIHNlcmlhbGl6ZWQgZm9ybWF0LiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjNjQ5Mi5mcm9tKCcweC4uLicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHsgZGF0YTogJzB4Li4uJywgc2lnbmF0dXJlOiB7IC4uLiB9LCB0bzogJzB4Li4uJywgfSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBjb25zdGl0dWVudCBwYXJ0cy4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzY0OTIuZnJvbSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgZGF0YTogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqICAgdG86ICcweC4uLicsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiAvLyBAbG9nOiB7IGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSwgdG86ICcweC4uLicsIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBXcmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20od3JhcHBlZCkge1xuICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1bndyYXAod3JhcHBlZCk7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MiNzcGVjaWZpY2F0aW9uKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJ1xuICpcbiAqIGNvbnN0IHsgZGF0YSwgc2lnbmF0dXJlLCB0byB9ID0gU2lnbmF0dXJlRXJjNjQ5Mi51bndyYXAoJzB4Li4uJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBXcmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh3cmFwcGVkKSB7XG4gICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgIGNvbnN0IFt0bywgZGF0YSwgc2lnbmF0dXJlXSA9IEFiaVBhcmFtZXRlcnMuZGVjb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcywgYnl0ZXMsIGJ5dGVzJyksIHdyYXBwZWQpO1xuICAgIHJldHVybiB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhbiBbRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MiNzcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MicgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzY0OTIud3JhcCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgZGF0YTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLnRvSGV4KHNpZ25hdHVyZSksIC8vIFshY29kZSBmb2N1c11cbiAqICAgdG86ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBXcmFwcGVkIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBTZXJpYWxpemVkIHdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2lnbmF0dXJlLCB0byB9ID0gdmFsdWU7XG4gICAgcmV0dXJuIEhleC5jb25jYXQoQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzLCBieXRlcywgYnl0ZXMnKSwgW1xuICAgICAgICB0byxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgIF0pLCBtYWdpY0J5dGVzKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgd3JhcHBlZCBzaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MidcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVyYzY0OTIudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gVGhlIHdyYXBwZWQgc2lnbmF0dXJlIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh3cmFwcGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3dyYXBwZWR9XFxgIGlzIGFuIGludmFsaWQgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFcmM2NDkyLkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZUVyYzY0OTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc8010/SignatureErc8010.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   suffixParameters: () => (/* binding */ suffixParameters),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(action-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Authorization.js */ \"(action-browser)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Errors.js */ \"(action-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(action-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(action-browser)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Signature.js */ \"(action-browser)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nconst magicBytes = '0x8010801080108010801080108010801080108010801080108010801080108010';\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nconst suffixParameters = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.from('(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data');\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nfunction assert(value) {\n    if (typeof value === 'string') {\n        if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, -32) !== magicBytes)\n            throw new InvalidWrappedSignatureError(value);\n    }\n    else\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nfunction from(value) {\n    if (typeof value === 'string')\n        return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -64, -32));\n    const suffix = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -suffixLength - 64, -64);\n    const signature = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(suffixParameters, suffix);\n    const authorization = _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s,\n    });\n    return {\n        authorization,\n        signature,\n        ...(data && data !== '0x' ? { data, to } : {}),\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nfunction wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress({\n        payload: _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.getSignPayload(value.authorization),\n        signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.from(value.authorization),\n    });\n    const suffix = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId),\n        },\n        value.to ?? self,\n        data ?? '0x',\n    ]);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(suffix), { size: 32 });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nclass InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc8010.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc8010.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2VyYzgwMTAvU2lnbmF0dXJlRXJjODAxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNBO0FBQ2Q7QUFDTjtBQUNZO0FBQ0E7QUFDbEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPLHlCQUF5Qix3REFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksK0NBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUIsS0FBSyw4QkFBOEIsUUFBUTtBQUMxRTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyxpQkFBaUIsS0FBSyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlCQUF5QixrREFBWSxDQUFDLCtDQUFTO0FBQy9DLG1CQUFtQiwrQ0FBUztBQUM1QixzQkFBc0IsK0NBQVM7QUFDL0IsNkJBQTZCLDBEQUFvQjtBQUNqRCwwQkFBMEIsd0RBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVyxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDJDQUEyQztBQUMzQyxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsaUJBQWlCLDhEQUF3QjtBQUN6QyxpQkFBaUIsa0VBQTRCO0FBQzdDLG1CQUFtQixvREFBYztBQUNqQyxLQUFLO0FBQ0wsbUJBQW1CLDBEQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQWMsQ0FBQyw4Q0FBUSxZQUFZLFVBQVU7QUFDdEUsV0FBVyxnREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQ0FBMkMsc0RBQWdCO0FBQ2xFO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L19lc20vZXJjODAxMC9TaWduYXR1cmVFcmM4MDEwLmpzP2JjNTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuLi9jb3JlL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuLi9jb3JlL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL2NvcmUvRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9jb3JlL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBTZWNwMjU2azEgZnJvbSAnLi4vY29yZS9TZWNwMjU2azEuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4uL2NvcmUvU2lnbmF0dXJlLmpzJztcbi8qKlxuICogTWFnaWMgYnl0ZXMgdXNlZCB0byBpZGVudGlmeSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYWdpY0J5dGVzID0gJzB4ODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMCc7XG4vKiogU3VmZml4IEFCSSBwYXJhbWV0ZXJzIGZvciB0aGUgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmUuICovXG5leHBvcnQgY29uc3Qgc3VmZml4UGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbSgnKHVpbnQyNTYgY2hhaW5JZCwgYWRkcmVzcyBkZWxlZ2F0aW9uLCB1aW50MjU2IG5vbmNlLCB1aW50OCB5UGFyaXR5LCB1aW50MjU2IHIsIHVpbnQyNTYgcyksIGFkZHJlc3MgdG8sIGJ5dGVzIGRhdGEnKTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJ1xuICpcbiAqIFNpZ25hdHVyZUVyYzgwMTAuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcjogVmFsdWUgYDB4ZGVhZGJlZWZgIGlzIGFuIGludmFsaWQgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmUuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKEhleC5zbGljZSh2YWx1ZSwgLTMyKSAhPT0gbWFnaWNCeXRlcylcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBTaWduYXR1cmUuYXNzZXJ0KHZhbHVlLmF1dGhvcml6YXRpb24pO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gW0VSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2dpdGh1Yi5jb20vanhvbS9FUkNzL2Jsb2IvMTZmN2UzODkxZmZmMmUxZTljMjVkZWEwNDg1NDk3NzM5ZGI4YTgxNi9FUkNTL2VyYy04MDEwLm1kKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCcgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBzZXJpYWxpemVkIGZvcm1hdC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzgwMTAuZnJvbSgnMHguLi4nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7IGF1dGhvcml6YXRpb246IHsgLi4uIH0sIGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSB9IC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBmcm9tIGNvbnN0aXR1ZW50IHBhcnRzLiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC5mcm9tKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhdXRob3JpemF0aW9uOiB7IC4uLiB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweC4uLicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogeyBhdXRob3JpemF0aW9uOiB7IC4uLiB9LCBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBQYXJzZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1bndyYXAodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogVW53cmFwcyBhbiBbRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qeG9tL0VSQ3MvYmxvYi8xNmY3ZTM4OTFmZmYyZTFlOWMyNWRlYTA0ODU0OTc3MzlkYjhhODE2L0VSQ1MvZXJjLTgwMTAubWQpIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnXG4gKlxuICogY29uc3QgeyBhdXRob3JpemF0aW9uLCBkYXRhLCBzaWduYXR1cmUgfSA9IFNpZ25hdHVyZUVyYzgwMTAudW53cmFwKCcweC4uLicpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHVud3JhcC5cbiAqIEByZXR1cm5zIFVud3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAod3JhcHBlZCkge1xuICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICBjb25zdCBzdWZmaXhMZW5ndGggPSBIZXgudG9OdW1iZXIoSGV4LnNsaWNlKHdyYXBwZWQsIC02NCwgLTMyKSk7XG4gICAgY29uc3Qgc3VmZml4ID0gSGV4LnNsaWNlKHdyYXBwZWQsIC1zdWZmaXhMZW5ndGggLSA2NCwgLTY0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBIZXguc2xpY2Uod3JhcHBlZCwgMCwgLXN1ZmZpeExlbmd0aCAtIDY0KTtcbiAgICBjb25zdCBbYXV0aCwgdG8sIGRhdGFdID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoc3VmZml4UGFyYW1ldGVycywgc3VmZml4KTtcbiAgICBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAgICAgICAgYWRkcmVzczogYXV0aC5kZWxlZ2F0aW9uLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoYXV0aC5jaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IGF1dGgubm9uY2UsXG4gICAgICAgIHlQYXJpdHk6IGF1dGgueVBhcml0eSxcbiAgICAgICAgcjogYXV0aC5yLFxuICAgICAgICBzOiBhdXRoLnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yaXphdGlvbixcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAuLi4oZGF0YSAmJiBkYXRhICE9PSAnMHgnID8geyBkYXRhLCB0byB9IDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFdyYXBzIGEgc2lnbmF0dXJlIGludG8gW0VSQy04MDEwIGZvcm1hdF0oaHR0cHM6Ly9naXRodWIuY29tL2p4b20vRVJDcy9ibG9iLzE2ZjdlMzg5MWZmZjJlMWU5YzI1ZGVhMDQ4NTQ5NzczOWRiOGE4MTYvRVJDUy9lcmMtODAxMC5tZCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCcgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzgwMTAud3JhcCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYXV0aG9yaXphdGlvbjogeyAuLi4gfSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBkYXRhOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlOiBTaWduYXR1cmUudG9IZXgoc2lnbmF0dXJlKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWVzIHRvIHdyYXAuXG4gKiBAcmV0dXJucyBXcmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSB9ID0gdmFsdWU7XG4gICAgYXNzZXJ0KHZhbHVlKTtcbiAgICBjb25zdCBzZWxmID0gU2VjcDI1NmsxLnJlY292ZXJBZGRyZXNzKHtcbiAgICAgICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZCh2YWx1ZS5hdXRob3JpemF0aW9uKSxcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbSh2YWx1ZS5hdXRob3JpemF0aW9uKSxcbiAgICB9KTtcbiAgICBjb25zdCBzdWZmaXggPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShzdWZmaXhQYXJhbWV0ZXJzLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIC4uLnZhbHVlLmF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICBkZWxlZ2F0aW9uOiB2YWx1ZS5hdXRob3JpemF0aW9uLmFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkOiBCaWdJbnQodmFsdWUuYXV0aG9yaXphdGlvbi5jaGFpbklkKSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUudG8gPz8gc2VsZixcbiAgICAgICAgZGF0YSA/PyAnMHgnLFxuICAgIF0pO1xuICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IEhleC5mcm9tTnVtYmVyKEhleC5zaXplKHN1ZmZpeCksIHsgc2l6ZTogMzIgfSk7XG4gICAgcmV0dXJuIEhleC5jb25jYXQoc2lnbmF0dXJlLCBzdWZmaXgsIHN1ZmZpeExlbmd0aCwgbWFnaWNCeXRlcyk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHdyYXBwZWQgc2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmVFcmM4MDEwLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmUgaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZCkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt3cmFwcGVkfVxcYCBpcyBhbiBpbnZhbGlkIEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlRXJjODAxMC5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmVFcmM4MDEwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/errors.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/version.js\");\n\nclass BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: abitype@${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`,\n        ].join('\\n');\n        super(message);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiTypeError'\n        });\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDaEM7QUFDUCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVM7QUFDakUsdUNBQXVDLFFBQVE7QUFDL0MsZ0NBQWdDLGdEQUFPLENBQUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2Vycm9ycy5qcz9lYzE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIGFyZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gYXJncy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvclxuICAgICAgICAgICAgPyBhcmdzLmNhdXNlLmRldGFpbHNcbiAgICAgICAgICAgIDogYXJncy5jYXVzZT8ubWVzc2FnZVxuICAgICAgICAgICAgICAgID8gYXJncy5jYXVzZS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBhcmdzLmRldGFpbHM7XG4gICAgICAgIGNvbnN0IGRvY3NQYXRoID0gYXJncy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvclxuICAgICAgICAgICAgPyBhcmdzLmNhdXNlLmRvY3NQYXRoIHx8IGFyZ3MuZG9jc1BhdGhcbiAgICAgICAgICAgIDogYXJncy5kb2NzUGF0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uKGFyZ3MubWV0YU1lc3NhZ2VzID8gWy4uLmFyZ3MubWV0YU1lc3NhZ2VzLCAnJ10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZG9jc1BhdGggPyBbYERvY3M6IGh0dHBzOi8vYWJpdHlwZS5kZXYke2RvY3NQYXRofWBdIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgPyBbYERldGFpbHM6ICR7ZGV0YWlsc31gXSA6IFtdKSxcbiAgICAgICAgICAgIGBWZXJzaW9uOiBhYml0eXBlQCR7dmVyc2lvbn1gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzUGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhTWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvcnRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXJncy5jYXVzZSlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBhcmdzLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWV0YU1lc3NhZ2VzID0gYXJncy5tZXRhTWVzc2FnZXM7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAbiItemError: () => (/* binding */ InvalidAbiItemError),\n/* harmony export */   UnknownSolidityTypeError: () => (/* binding */ UnknownSolidityTypeError),\n/* harmony export */   UnknownTypeError: () => (/* binding */ UnknownTypeError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidAbiItemError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature }) {\n        super('Failed to parse ABI item.', {\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n            docsPath: '/api/human#parseabiitem-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiItemError'\n        });\n    }\n}\nclass UnknownTypeError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownTypeError'\n        });\n    }\n}\nclass UnknownSolidityTypeError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSolidityTypeError'\n        });\n    }\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvYWJpSXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ3JDLGtDQUFrQyxpREFBUztBQUNsRCxrQkFBa0IsV0FBVztBQUM3QjtBQUNBLHFDQUFxQyxtQ0FBbUM7QUFDeEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sK0JBQStCLGlEQUFTO0FBQy9DLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTyx1Q0FBdUMsaURBQVM7QUFDdkQsa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9hYmlJdGVtLmpzPzE2NjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmV4cG9ydCBjbGFzcyBJbnZhbGlkQWJpSXRlbUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gcGFyc2UgQUJJIGl0ZW0uJywge1xuICAgICAgICAgICAgZGV0YWlsczogYHBhcnNlQWJpSXRlbSgke0pTT04uc3RyaW5naWZ5KHNpZ25hdHVyZSwgbnVsbCwgMil9KWAsXG4gICAgICAgICAgICBkb2NzUGF0aDogJy9hcGkvaHVtYW4jcGFyc2VhYmlpdGVtLTEnLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRBYmlJdGVtRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbmtub3duVHlwZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHR5cGUgfSkge1xuICAgICAgICBzdXBlcignVW5rbm93biB0eXBlLicsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBUeXBlIFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIEFCSSB0eXBlLiBQZXJoYXBzIHlvdSBmb3Jnb3QgdG8gaW5jbHVkZSBhIHN0cnVjdCBzaWduYXR1cmU/YCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVW5rbm93blR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVua25vd25Tb2xpZGl0eVR5cGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB0eXBlIH0pIHtcbiAgICAgICAgc3VwZXIoJ1Vua25vd24gdHlwZS4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3QgYSB2YWxpZCBBQkkgdHlwZS5gXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdVbmtub3duU29saWRpdHlUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAbiParameterError: () => (/* binding */ InvalidAbiParameterError),\n/* harmony export */   InvalidAbiParametersError: () => (/* binding */ InvalidAbiParametersError),\n/* harmony export */   InvalidAbiTypeParameterError: () => (/* binding */ InvalidAbiTypeParameterError),\n/* harmony export */   InvalidFunctionModifierError: () => (/* binding */ InvalidFunctionModifierError),\n/* harmony export */   InvalidModifierError: () => (/* binding */ InvalidModifierError),\n/* harmony export */   InvalidParameterError: () => (/* binding */ InvalidParameterError),\n/* harmony export */   SolidityProtectedKeywordError: () => (/* binding */ SolidityProtectedKeywordError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidAbiParameterError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param }) {\n        super('Failed to parse ABI parameter.', {\n            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n            docsPath: '/api/human#parseabiparameter-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParameterError'\n        });\n    }\n}\nclass InvalidAbiParametersError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ params }) {\n        super('Failed to parse ABI parameters.', {\n            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n            docsPath: '/api/human#parseabiparameters-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParametersError'\n        });\n    }\n}\nclass InvalidParameterError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParameterError'\n        });\n    }\n}\nclass SolidityProtectedKeywordError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param, name }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SolidityProtectedKeywordError'\n        });\n    }\n}\nclass InvalidModifierError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidModifierError'\n        });\n    }\n}\nclass InvalidFunctionModifierError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidFunctionModifierError'\n        });\n    }\n}\nclass InvalidAbiTypeParameterError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ abiParameter, }) {\n        super('Invalid ABI parameter.', {\n            details: JSON.stringify(abiParameter, null, 2),\n            metaMessages: ['ABI parameter type is invalid.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiTypeParameterError'\n        });\n    }\n}\n//# sourceMappingURL=abiParameter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvYWJpUGFyYW1ldGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ3JDLHVDQUF1QyxpREFBUztBQUN2RCxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLDBDQUEwQywrQkFBK0I7QUFDekU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sd0NBQXdDLGlEQUFTO0FBQ3hELGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTyxvQ0FBb0MsaURBQVM7QUFDcEQsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTyw0Q0FBNEMsaURBQVM7QUFDNUQsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sbUNBQW1DLGlEQUFTO0FBQ25ELGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsZUFBZSxlQUFlLEtBQUssYUFBYTtBQUN0RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTywyQ0FBMkMsaURBQVM7QUFDM0Qsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUyxlQUFlLGVBQWUsS0FBSyxhQUFhO0FBQ3RGLGlHQUFpRyxTQUFTO0FBQzFHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLDJDQUEyQyxpREFBUztBQUMzRCxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9hYmlQYXJhbWV0ZXIuanM/NGRjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMuanMnO1xuZXhwb3J0IGNsYXNzIEludmFsaWRBYmlQYXJhbWV0ZXJFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYXJhbSB9KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gcGFyc2UgQUJJIHBhcmFtZXRlci4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBgcGFyc2VBYmlQYXJhbWV0ZXIoJHtKU09OLnN0cmluZ2lmeShwYXJhbSwgbnVsbCwgMil9KWAsXG4gICAgICAgICAgICBkb2NzUGF0aDogJy9hcGkvaHVtYW4jcGFyc2VhYmlwYXJhbWV0ZXItMScsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZEFiaVBhcmFtZXRlckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZEFiaVBhcmFtZXRlcnNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYXJhbXMgfSkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHBhcnNlIEFCSSBwYXJhbWV0ZXJzLicsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IGBwYXJzZUFiaVBhcmFtZXRlcnMoJHtKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDIpfSlgLFxuICAgICAgICAgICAgZG9jc1BhdGg6ICcvYXBpL2h1bWFuI3BhcnNlYWJpcGFyYW1ldGVycy0xJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkQWJpUGFyYW1ldGVyc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZFBhcmFtZXRlckVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHBhcmFtIH0pIHtcbiAgICAgICAgc3VwZXIoJ0ludmFsaWQgQUJJIHBhcmFtZXRlci4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBwYXJhbSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkUGFyYW1ldGVyRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTb2xpZGl0eVByb3RlY3RlZEtleXdvcmRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYXJhbSwgbmFtZSB9KSB7XG4gICAgICAgIHN1cGVyKCdJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuJywge1xuICAgICAgICAgICAgZGV0YWlsczogcGFyYW0sXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgXCIke25hbWV9XCIgaXMgYSBwcm90ZWN0ZWQgU29saWRpdHkga2V5d29yZC4gTW9yZSBpbmZvOiBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvY2hlYXRzaGVldC5odG1sYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU29saWRpdHlQcm90ZWN0ZWRLZXl3b3JkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZhbGlkTW9kaWZpZXJFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYXJhbSwgdHlwZSwgbW9kaWZpZXIsIH0pIHtcbiAgICAgICAgc3VwZXIoJ0ludmFsaWQgQUJJIHBhcmFtZXRlci4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBwYXJhbSxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBNb2RpZmllciBcIiR7bW9kaWZpZXJ9XCIgbm90IGFsbG93ZWQke3R5cGUgPyBgIGluIFwiJHt0eXBlfVwiIHR5cGVgIDogJyd9LmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRNb2RpZmllckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZEZ1bmN0aW9uTW9kaWZpZXJFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYXJhbSwgdHlwZSwgbW9kaWZpZXIsIH0pIHtcbiAgICAgICAgc3VwZXIoJ0ludmFsaWQgQUJJIHBhcmFtZXRlci4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBwYXJhbSxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBNb2RpZmllciBcIiR7bW9kaWZpZXJ9XCIgbm90IGFsbG93ZWQke3R5cGUgPyBgIGluIFwiJHt0eXBlfVwiIHR5cGVgIDogJyd9LmAsXG4gICAgICAgICAgICAgICAgYERhdGEgbG9jYXRpb24gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIGZvciBhcnJheSwgc3RydWN0LCBvciBtYXBwaW5nIHR5cGVzLCBidXQgXCIke21vZGlmaWVyfVwiIHdhcyBnaXZlbi5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdJbnZhbGlkRnVuY3Rpb25Nb2RpZmllckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZEFiaVR5cGVQYXJhbWV0ZXJFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhYmlQYXJhbWV0ZXIsIH0pIHtcbiAgICAgICAgc3VwZXIoJ0ludmFsaWQgQUJJIHBhcmFtZXRlci4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBKU09OLnN0cmluZ2lmeShhYmlQYXJhbWV0ZXIsIG51bGwsIDIpLFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0FCSSBwYXJhbWV0ZXIgdHlwZSBpcyBpbnZhbGlkLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRBYmlUeXBlUGFyYW1ldGVyRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaVBhcmFtZXRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidSignatureError: () => (/* binding */ InvalidSignatureError),\n/* harmony export */   InvalidStructSignatureError: () => (/* binding */ InvalidStructSignatureError),\n/* harmony export */   UnknownSignatureError: () => (/* binding */ UnknownSignatureError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidSignatureError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature, type, }) {\n        super(`Invalid ${type} signature.`, {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidSignatureError'\n        });\n    }\n}\nclass UnknownSignatureError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature }) {\n        super('Unknown signature.', {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSignatureError'\n        });\n    }\n}\nclass InvalidStructSignatureError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ signature }) {\n        super('Invalid struct signature.', {\n            details: signature,\n            metaMessages: ['No properties exist.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidStructSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDckMsb0NBQW9DLGlEQUFTO0FBQ3BELGtCQUFrQixrQkFBa0I7QUFDcEMseUJBQXlCLE1BQU07QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sb0NBQW9DLGlEQUFTO0FBQ3BELGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sMENBQTBDLGlEQUFTO0FBQzFELGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL3NpZ25hdHVyZS5qcz9iMTZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5leHBvcnQgY2xhc3MgSW52YWxpZFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgSW52YWxpZCAke3R5cGV9IHNpZ25hdHVyZS5gLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5rbm93blNpZ25hdHVyZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKCdVbmtub3duIHNpZ25hdHVyZS4nLCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVW5rbm93blNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZFN0cnVjdFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKCdJbnZhbGlkIHN0cnVjdCBzaWduYXR1cmUuJywge1xuICAgICAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlLFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ05vIHByb3BlcnRpZXMgZXhpc3QuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZFN0cnVjdFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidParenthesisError: () => (/* binding */ InvalidParenthesisError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass InvalidParenthesisError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ current, depth }) {\n        super('Unbalanced parentheses.', {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,\n            ],\n            details: `Depth \"${depth}\"`,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParenthesisError'\n        });\n    }\n}\n//# sourceMappingURL=splitParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvc3BsaXRQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQ3JDLHNDQUFzQyxpREFBUztBQUN0RCxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZSxpQkFBaUIsbUNBQW1DO0FBQ3ZGO0FBQ0EsK0JBQStCLE1BQU07QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvc3BsaXRQYXJhbWV0ZXJzLmpzP2U3NmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmV4cG9ydCBjbGFzcyBJbnZhbGlkUGFyZW50aGVzaXNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjdXJyZW50LCBkZXB0aCB9KSB7XG4gICAgICAgIHN1cGVyKCdVbmJhbGFuY2VkIHBhcmVudGhlc2VzLicsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBcIiR7Y3VycmVudC50cmltKCl9XCIgaGFzIHRvbyBtYW55ICR7ZGVwdGggPiAwID8gJ29wZW5pbmcnIDogJ2Nsb3NpbmcnfSBwYXJlbnRoZXNlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRldGFpbHM6IGBEZXB0aCBcIiR7ZGVwdGh9XCJgLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRQYXJlbnRoZXNpc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGxpdFBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircularReferenceError: () => (/* binding */ CircularReferenceError)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/errors.js\");\n\nclass CircularReferenceError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ type }) {\n        super('Circular reference detected.', {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'CircularReferenceError'\n        });\n    }\n}\n//# sourceMappingURL=struct.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvc3RydWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQ3JDLHFDQUFxQyxpREFBUztBQUNyRCxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL3N0cnVjdC5qcz8wMjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5leHBvcnQgY2xhc3MgQ2lyY3VsYXJSZWZlcmVuY2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB0eXBlIH0pIHtcbiAgICAgICAgc3VwZXIoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZC4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtgU3RydWN0IFwiJHt0eXBlfVwiIGlzIGEgY2lyY3VsYXIgcmVmZXJlbmNlLmBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0NpcmN1bGFyUmVmZXJlbmNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cnVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiItem: () => (/* binding */ formatAbiItem)\n/* harmony export */ });\n/* harmony import */ var _formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatAbiParameters.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nfunction formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs?.length\n            ? ` returns (${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${(0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkIsYUFBYSxHQUFHLDRFQUFtQixpQkFBaUIsR0FBRztBQUNsRixrQkFBa0Isd0JBQXdCO0FBQzFDLGlCQUFpQixFQUFFO0FBQ25CLDJCQUEyQiw0RUFBbUIsa0JBQWtCO0FBQ2hFLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QixhQUFhLEdBQUcsNEVBQW1CLGlCQUFpQjtBQUM1RTtBQUNBLHdCQUF3QixhQUFhLEdBQUcsNEVBQW1CLGlCQUFpQjtBQUM1RTtBQUNBLDhCQUE4Qiw0RUFBbUIsaUJBQWlCLEdBQUcsd0RBQXdEO0FBQzdIO0FBQ0EscUNBQXFDLHdEQUF3RDtBQUM3RjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaUl0ZW0uanM/ZjU3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRBYmlQYXJhbWV0ZXJzLCB9IGZyb20gJy4vZm9ybWF0QWJpUGFyYW1ldGVycy5qcyc7XG4vKipcbiAqIEZvcm1hdHMgQUJJIGl0ZW0gKGUuZy4gZXJyb3IsIGV2ZW50LCBmdW5jdGlvbikgaW50byBodW1hbi1yZWFkYWJsZSBBQkkgaXRlbVxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gQUJJIGl0ZW1cbiAqIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIEFCSSBpdGVtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBYmlJdGVtKGFiaUl0ZW0pIHtcbiAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gYGZ1bmN0aW9uICR7YWJpSXRlbS5uYW1lfSgke2Zvcm1hdEFiaVBhcmFtZXRlcnMoYWJpSXRlbS5pbnB1dHMpfSkke2FiaUl0ZW0uc3RhdGVNdXRhYmlsaXR5ICYmIGFiaUl0ZW0uc3RhdGVNdXRhYmlsaXR5ICE9PSAnbm9ucGF5YWJsZSdcbiAgICAgICAgICAgID8gYCAke2FiaUl0ZW0uc3RhdGVNdXRhYmlsaXR5fWBcbiAgICAgICAgICAgIDogJyd9JHthYmlJdGVtLm91dHB1dHM/Lmxlbmd0aFxuICAgICAgICAgICAgPyBgIHJldHVybnMgKCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLm91dHB1dHMpfSlgXG4gICAgICAgICAgICA6ICcnfWA7XG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2V2ZW50JylcbiAgICAgICAgcmV0dXJuIGBldmVudCAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pYDtcbiAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZXJyb3InKVxuICAgICAgICByZXR1cm4gYGVycm9yICR7YWJpSXRlbS5uYW1lfSgke2Zvcm1hdEFiaVBhcmFtZXRlcnMoYWJpSXRlbS5pbnB1dHMpfSlgO1xuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicpXG4gICAgICAgIHJldHVybiBgY29uc3RydWN0b3IoJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSA9PT0gJ3BheWFibGUnID8gJyBwYXlhYmxlJyA6ICcnfWA7XG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2ZhbGxiYWNrJylcbiAgICAgICAgcmV0dXJuIGBmYWxsYmFjaygpIGV4dGVybmFsJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSA9PT0gJ3BheWFibGUnID8gJyBwYXlhYmxlJyA6ICcnfWA7XG4gICAgcmV0dXJuICdyZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRBYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiParameter: () => (/* binding */ formatAbiParameter)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../regex.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nfunction formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(tupleRegex, abiParameter.type);\n        type += `)${result?.array || ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlQYXJhbWV0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQkFBK0I7QUFDdEU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFTO0FBQ2hDLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSxFQUFFLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9iYWJsZS1tYXJrZXRzLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaVBhcmFtZXRlci5qcz9hNDU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWNUeXBlZCB9IGZyb20gJy4uL3JlZ2V4LmpzJztcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS83ZjdydlxuY29uc3QgdHVwbGVSZWdleCA9IC9edHVwbGUoPzxhcnJheT4oXFxbKFxcZCopXFxdKSopJC87XG4vKipcbiAqIEZvcm1hdHMge0BsaW5rIEFiaVBhcmFtZXRlcn0gdG8gaHVtYW4tcmVhZGFibGUgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gYWJpUGFyYW1ldGVyIC0gQUJJIHBhcmFtZXRlclxuICogQHJldHVybnMgSHVtYW4tcmVhZGFibGUgQUJJIHBhcmFtZXRlclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRBYmlQYXJhbWV0ZXIoeyB0eXBlOiAnYWRkcmVzcycsIG5hbWU6ICdmcm9tJyB9KVxuICogLy8gICAgXj8gY29uc3QgcmVzdWx0OiAnYWRkcmVzcyBmcm9tJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QWJpUGFyYW1ldGVyKGFiaVBhcmFtZXRlcikge1xuICAgIGxldCB0eXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XG4gICAgaWYgKHR1cGxlUmVnZXgudGVzdChhYmlQYXJhbWV0ZXIudHlwZSkgJiYgJ2NvbXBvbmVudHMnIGluIGFiaVBhcmFtZXRlcikge1xuICAgICAgICB0eXBlID0gJygnO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhYmlQYXJhbWV0ZXIuY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFiaVBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgdHlwZSArPSBmb3JtYXRBYmlQYXJhbWV0ZXIoY29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICB0eXBlICs9ICcsICc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1R5cGVkKHR1cGxlUmVnZXgsIGFiaVBhcmFtZXRlci50eXBlKTtcbiAgICAgICAgdHlwZSArPSBgKSR7cmVzdWx0Py5hcnJheSB8fCAnJ31gO1xuICAgICAgICByZXR1cm4gZm9ybWF0QWJpUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBZGQgYGluZGV4ZWRgIHRvIHR5cGUgaWYgaW4gYGFiaVBhcmFtZXRlcmBcbiAgICBpZiAoJ2luZGV4ZWQnIGluIGFiaVBhcmFtZXRlciAmJiBhYmlQYXJhbWV0ZXIuaW5kZXhlZClcbiAgICAgICAgdHlwZSA9IGAke3R5cGV9IGluZGV4ZWRgO1xuICAgIC8vIFJldHVybiBodW1hbi1yZWFkYWJsZSBBQkkgcGFyYW1ldGVyXG4gICAgaWYgKGFiaVBhcmFtZXRlci5uYW1lKVxuICAgICAgICByZXR1cm4gYCR7dHlwZX0gJHthYmlQYXJhbWV0ZXIubmFtZX1gO1xuICAgIHJldHVybiB0eXBlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0QWJpUGFyYW1ldGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiParameters: () => (/* binding */ formatAbiParameters)\n/* harmony export */ });\n/* harmony import */ var _formatAbiParameter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatAbiParameter.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\");\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nfunction formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += (0,_formatAbiParameter_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameter)(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThEO0FBQzlEO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLCtCQUErQjtBQUN0QyxPQUFPLGtDQUFrQztBQUN6QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSxrQkFBa0IsMEVBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZm9ybWF0QWJpUGFyYW1ldGVycy5qcz9iNTYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdEFiaVBhcmFtZXRlciwgfSBmcm9tICcuL2Zvcm1hdEFiaVBhcmFtZXRlci5qcyc7XG4vKipcbiAqIEZvcm1hdHMge0BsaW5rIEFiaVBhcmFtZXRlcn1zIHRvIGh1bWFuLXJlYWRhYmxlIEFCSSBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSBhYmlQYXJhbWV0ZXJzIC0gQUJJIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIEFCSSBwYXJhbWV0ZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdEFiaVBhcmFtZXRlcnMoW1xuICogICAvLyAgXj8gY29uc3QgcmVzdWx0OiAnYWRkcmVzcyBmcm9tLCB1aW50MjU2IHRva2VuSWQnXG4gKiAgIHsgdHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAnZnJvbScgfSxcbiAqICAgeyB0eXBlOiAndWludDI1NicsIG5hbWU6ICd0b2tlbklkJyB9LFxuICogXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEFiaVBhcmFtZXRlcnMoYWJpUGFyYW1ldGVycykge1xuICAgIGxldCBwYXJhbXMgPSAnJztcbiAgICBjb25zdCBsZW5ndGggPSBhYmlQYXJhbWV0ZXJzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IGFiaVBhcmFtZXRlcnNbaV07XG4gICAgICAgIHBhcmFtcyArPSBmb3JtYXRBYmlQYXJhbWV0ZXIoYWJpUGFyYW1ldGVyKTtcbiAgICAgICAgaWYgKGkgIT09IGxlbmd0aCAtIDEpXG4gICAgICAgICAgICBwYXJhbXMgKz0gJywgJztcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdEFiaVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAbiItem: () => (/* binding */ parseAbiItem)\n/* harmony export */ });\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors/abiItem.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/signatures.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _runtime_structs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/structs.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\");\n/* harmony import */ var _runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/utils.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nfunction parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === 'string')\n        abiItem = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseSignature)(signature);\n    else {\n        const structs = (0,_runtime_structs_js__WEBPACK_IMPORTED_MODULE_1__.parseStructs)(signature);\n        const length = signature.length;\n        for (let i = 0; i < length; i++) {\n            const signature_ = signature[i];\n            if ((0,_runtime_signatures_js__WEBPACK_IMPORTED_MODULE_2__.isStructSignature)(signature_))\n                continue;\n            abiItem = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseSignature)(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem)\n        throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAbiItemError({ signature });\n    return abiItem;\n}\n//# sourceMappingURL=parseAbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEQ7QUFDRTtBQUNSO0FBQ0E7QUFDcEQ7QUFDQSxzRUFBc0UsV0FBVztBQUNqRjtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQixrQkFBa0Isd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhLGtCQUFrQix5QkFBeUI7QUFDckY7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFjO0FBQ2hDO0FBQ0Esd0JBQXdCLGlFQUFZO0FBQ3BDO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSxnQkFBZ0IseUVBQWlCO0FBQ2pDO0FBQ0Esc0JBQXNCLGlFQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFtQixHQUFHLFdBQVc7QUFDbkQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaUl0ZW0uanM/NjY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkQWJpSXRlbUVycm9yIH0gZnJvbSAnLi9lcnJvcnMvYWJpSXRlbS5qcyc7XG5pbXBvcnQgeyBpc1N0cnVjdFNpZ25hdHVyZSB9IGZyb20gJy4vcnVudGltZS9zaWduYXR1cmVzLmpzJztcbmltcG9ydCB7IHBhcnNlU3RydWN0cyB9IGZyb20gJy4vcnVudGltZS9zdHJ1Y3RzLmpzJztcbmltcG9ydCB7IHBhcnNlU2lnbmF0dXJlIH0gZnJvbSAnLi9ydW50aW1lL3V0aWxzLmpzJztcbi8qKlxuICogUGFyc2VzIGh1bWFuLXJlYWRhYmxlIEFCSSBpdGVtIChlLmcuIGVycm9yLCBldmVudCwgZnVuY3Rpb24pIGludG8ge0BsaW5rIEFiaX0gaXRlbVxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBIdW1hbi1yZWFkYWJsZSBBQkkgaXRlbVxuICogQHJldHVybnMgUGFyc2VkIHtAbGluayBBYml9IGl0ZW1cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYWJpSXRlbSA9IHBhcnNlQWJpSXRlbSgnZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIpIHZpZXcgcmV0dXJucyAodWludDI1NiknKVxuICogLy8gICAgXj8gY29uc3QgYWJpSXRlbTogeyBuYW1lOiBcImJhbGFuY2VPZlwiOyB0eXBlOiBcImZ1bmN0aW9uXCI7IHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCI7Li4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFiaUl0ZW0gPSBwYXJzZUFiaUl0ZW0oW1xuICogICAvLyAgXj8gY29uc3QgYWJpSXRlbTogeyBuYW1lOiBcImZvb1wiOyB0eXBlOiBcImZ1bmN0aW9uXCI7IHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCI7IGlucHV0czouLi5cbiAqICAgJ2Z1bmN0aW9uIGZvbyhCYXogYmFyKSB2aWV3IHJldHVybnMgKHN0cmluZyknLFxuICogICAnc3RydWN0IEJheiB7IHN0cmluZyBuYW1lOyB9JyxcbiAqIF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFiaUl0ZW0oc2lnbmF0dXJlKSB7XG4gICAgbGV0IGFiaUl0ZW07XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKVxuICAgICAgICBhYmlJdGVtID0gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RydWN0cyA9IHBhcnNlU3RydWN0cyhzaWduYXR1cmUpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBzaWduYXR1cmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVfID0gc2lnbmF0dXJlW2ldO1xuICAgICAgICAgICAgaWYgKGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZV8pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZV8sIHN0cnVjdHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhYmlJdGVtKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFiaUl0ZW1FcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICByZXR1cm4gYWJpSXRlbTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlQWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAbiParameters: () => (/* binding */ parseAbiParameters)\n/* harmony export */ });\n/* harmony import */ var _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors/abiParameter.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\");\n/* harmony import */ var _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/signatures.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _runtime_structs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/structs.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\");\n/* harmony import */ var _runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/utils.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nfunction parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === 'string') {\n        const parameters = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.splitParameters)(params);\n        const length = parameters.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push((0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseAbiParameter)(parameters[i], { modifiers: _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.modifiers }));\n        }\n    }\n    else {\n        const structs = (0,_runtime_structs_js__WEBPACK_IMPORTED_MODULE_2__.parseStructs)(params);\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            const signature = params[i];\n            if ((0,_runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.isStructSignature)(signature))\n                continue;\n            const parameters = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.splitParameters)(signature);\n            const length = parameters.length;\n            for (let k = 0; k < length; k++) {\n                abiParameters.push((0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseAbiParameter)(parameters[k], { modifiers: _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.modifiers, structs }));\n            }\n        }\n    }\n    if (abiParameters.length === 0)\n        throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAbiParametersError({ params });\n    return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUU7QUFDRTtBQUNuQjtBQUNDO0FBQ3dCO0FBQzdFO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCLGVBQWUsSUFBSSxnQkFBZ0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWUsZUFBZSxnQkFBZ0I7QUFDbEY7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFlO0FBQzFDO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsK0JBQStCLG9FQUFrQixrQkFBa0IsU0FBUyxpRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUVBQVk7QUFDcEM7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBLGdCQUFnQix5RUFBaUI7QUFDakM7QUFDQSwrQkFBK0Isa0VBQWU7QUFDOUM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QyxtQ0FBbUMsb0VBQWtCLGtCQUFrQixTQUFTLDBFQUFXO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhFQUF5QixHQUFHLFFBQVE7QUFDdEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaVBhcmFtZXRlcnMuanM/NTdlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkQWJpUGFyYW1ldGVyc0Vycm9yIH0gZnJvbSAnLi9lcnJvcnMvYWJpUGFyYW1ldGVyLmpzJztcbmltcG9ydCB7IGlzU3RydWN0U2lnbmF0dXJlLCBtb2RpZmllcnMgfSBmcm9tICcuL3J1bnRpbWUvc2lnbmF0dXJlcy5qcyc7XG5pbXBvcnQgeyBwYXJzZVN0cnVjdHMgfSBmcm9tICcuL3J1bnRpbWUvc3RydWN0cy5qcyc7XG5pbXBvcnQgeyBzcGxpdFBhcmFtZXRlcnMgfSBmcm9tICcuL3J1bnRpbWUvdXRpbHMuanMnO1xuaW1wb3J0IHsgcGFyc2VBYmlQYXJhbWV0ZXIgYXMgcGFyc2VBYmlQYXJhbWV0ZXJfIH0gZnJvbSAnLi9ydW50aW1lL3V0aWxzLmpzJztcbi8qKlxuICogUGFyc2VzIGh1bWFuLXJlYWRhYmxlIEFCSSBwYXJhbWV0ZXJzIGludG8ge0BsaW5rIEFiaVBhcmFtZXRlcn1zXG4gKlxuICogQHBhcmFtIHBhcmFtcyAtIEh1bWFuLXJlYWRhYmxlIEFCSSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyBQYXJzZWQge0BsaW5rIEFiaVBhcmFtZXRlcn1zXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBwYXJzZUFiaVBhcmFtZXRlcnMoJ2FkZHJlc3MgZnJvbSwgYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQnKVxuICogLy8gICAgXj8gY29uc3QgYWJpUGFyYW1ldGVyczogW3sgdHlwZTogXCJhZGRyZXNzXCI7IG5hbWU6IFwiZnJvbVwiOyB9LCB7IHR5cGU6IFwiYWRkcmVzc1wiOy4uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBhYmlQYXJhbWV0ZXJzID0gcGFyc2VBYmlQYXJhbWV0ZXJzKFtcbiAqICAgLy8gIF4/IGNvbnN0IGFiaVBhcmFtZXRlcnM6IFt7IHR5cGU6IFwidHVwbGVcIjsgY29tcG9uZW50czogW3sgdHlwZTogXCJzdHJpbmdcIjsgbmFtZTouLi5cbiAqICAgJ0JheiBiYXInLFxuICogICAnc3RydWN0IEJheiB7IHN0cmluZyBuYW1lOyB9JyxcbiAqIF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc3BsaXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhYmlQYXJhbWV0ZXJzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXJfKHBhcmFtZXRlcnNbaV0sIHsgbW9kaWZpZXJzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RydWN0cyA9IHBhcnNlU3RydWN0cyhwYXJhbXMpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAoaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBzcGxpdFBhcmFtZXRlcnMoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChwYXJzZUFiaVBhcmFtZXRlcl8ocGFyYW1ldGVyc1trXSwgeyBtb2RpZmllcnMsIHN0cnVjdHMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYmlQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBYmlQYXJhbWV0ZXJzRXJyb3IoeyBwYXJhbXMgfSk7XG4gICAgcmV0dXJuIGFiaVBhcmFtZXRlcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUFiaVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getParameterCacheKey: () => (/* binding */ getParameterCacheKey),\n/* harmony export */   parameterCache: () => (/* binding */ parameterCache)\n/* harmony export */ });\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type} and {@link structs}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`) and ensures different struct definitions with the same name are cached separately.\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @param structs Struct definitions to include in cache key\n * @returns Cache key for {@link parameterCache}\n */\nfunction getParameterCacheKey(param, type, structs) {\n    let structKey = '';\n    if (structs)\n        for (const struct of Object.entries(structs)) {\n            if (!struct)\n                continue;\n            let propertyKey = '';\n            for (const property of struct[1]) {\n                propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;\n            }\n            structKey += `(${struct[0]}{${propertyKey}})`;\n        }\n    if (type)\n        return `${type}:${param}${structKey}`;\n    return `${param}${structKey}`;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nconst parameterCache = new Map([\n    // Unnamed\n    ['address', { type: 'address' }],\n    ['bool', { type: 'bool' }],\n    ['bytes', { type: 'bytes' }],\n    ['bytes32', { type: 'bytes32' }],\n    ['int', { type: 'int256' }],\n    ['int256', { type: 'int256' }],\n    ['string', { type: 'string' }],\n    ['uint', { type: 'uint256' }],\n    ['uint8', { type: 'uint8' }],\n    ['uint16', { type: 'uint16' }],\n    ['uint24', { type: 'uint24' }],\n    ['uint32', { type: 'uint32' }],\n    ['uint64', { type: 'uint64' }],\n    ['uint96', { type: 'uint96' }],\n    ['uint112', { type: 'uint112' }],\n    ['uint160', { type: 'uint160' }],\n    ['uint192', { type: 'uint192' }],\n    ['uint256', { type: 'uint256' }],\n    // Named\n    ['address owner', { type: 'address', name: 'owner' }],\n    ['address to', { type: 'address', name: 'to' }],\n    ['bool approved', { type: 'bool', name: 'approved' }],\n    ['bytes _data', { type: 'bytes', name: '_data' }],\n    ['bytes data', { type: 'bytes', name: 'data' }],\n    ['bytes signature', { type: 'bytes', name: 'signature' }],\n    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n    ['bytes32 r', { type: 'bytes32', name: 'r' }],\n    ['bytes32 root', { type: 'bytes32', name: 'root' }],\n    ['bytes32 s', { type: 'bytes32', name: 's' }],\n    ['string name', { type: 'string', name: 'name' }],\n    ['string symbol', { type: 'string', name: 'symbol' }],\n    ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint8 v', { type: 'uint8', name: 'v' }],\n    ['uint256 balance', { type: 'uint256', name: 'balance' }],\n    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint256 value', { type: 'uint256', name: 'value' }],\n    // Indexed\n    [\n        'event:address indexed from',\n        { type: 'address', name: 'from', indexed: true },\n    ],\n    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n    [\n        'event:uint indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n    [\n        'event:uint256 indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n]);\n//# sourceMappingURL=cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL2NhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxTQUFTLHNCQUFzQix5QkFBeUIsWUFBWSxLQUFLLGNBQWM7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLEVBQUUsb0JBQW9CLGNBQWMsT0FBTztBQUM1RjtBQUNBLDZCQUE2QixXQUFXLEVBQUUsYUFBYTtBQUN2RDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssR0FBRyxNQUFNLEVBQUUsVUFBVTtBQUM1QyxjQUFjLE1BQU0sRUFBRSxVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsZUFBZTtBQUMvQixrQkFBa0IsaUJBQWlCO0FBQ25DLGNBQWMsZ0JBQWdCO0FBQzlCLGlCQUFpQixnQkFBZ0I7QUFDakMsaUJBQWlCLGdCQUFnQjtBQUNqQyxlQUFlLGlCQUFpQjtBQUNoQyxnQkFBZ0IsZUFBZTtBQUMvQixpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixnQkFBZ0I7QUFDakMsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixnQkFBZ0I7QUFDakMsa0JBQWtCLGlCQUFpQjtBQUNuQyxrQkFBa0IsaUJBQWlCO0FBQ25DLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQscUJBQXFCLDZCQUE2QjtBQUNsRCx3QkFBd0IsZ0NBQWdDO0FBQ3hELHNCQUFzQiw4QkFBOEI7QUFDcEQscUJBQXFCLDZCQUE2QjtBQUNsRCwwQkFBMEIsa0NBQWtDO0FBQzVELHVCQUF1QiwrQkFBK0I7QUFDdEQsb0JBQW9CLDRCQUE0QjtBQUNoRCx1QkFBdUIsK0JBQStCO0FBQ3RELG9CQUFvQiw0QkFBNEI7QUFDaEQsc0JBQXNCLDhCQUE4QjtBQUNwRCx3QkFBd0IsZ0NBQWdDO0FBQ3hELDBCQUEwQixrQ0FBa0M7QUFDNUQsdUJBQXVCLGtDQUFrQztBQUN6RCxrQkFBa0IsMEJBQTBCO0FBQzVDLDBCQUEwQixrQ0FBa0M7QUFDNUQsMEJBQTBCLGtDQUFrQztBQUM1RCx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQThDO0FBQ3hEO0FBQ0EsbUNBQW1DLDRDQUE0QztBQUMvRTtBQUNBO0FBQ0EsVUFBVSxpREFBaUQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpREFBaUQ7QUFDM0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL2NhY2hlLmpzPzc3MzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZXRzIHtAbGluayBwYXJhbWV0ZXJDYWNoZX0gY2FjaGUga2V5IG5hbWVzcGFjZWQgYnkge0BsaW5rIHR5cGV9IGFuZCB7QGxpbmsgc3RydWN0c30uIFRoaXMgcHJldmVudHMgcGFyYW1ldGVycyBmcm9tIGJlaW5nIGFjY2Vzc2libGUgdG8gdHlwZXMgdGhhdCBkb24ndCBhbGxvdyB0aGVtIChlLmcuIGBzdHJpbmcgaW5kZXhlZCBmb29gIG5vdCBhbGxvd2VkIG91dHNpZGUgb2YgYHR5cGU6ICdldmVudCdgKSBhbmQgZW5zdXJlcyBkaWZmZXJlbnQgc3RydWN0IGRlZmluaXRpb25zIHdpdGggdGhlIHNhbWUgbmFtZSBhcmUgY2FjaGVkIHNlcGFyYXRlbHkuXG4gKiBAcGFyYW0gcGFyYW0gQUJJIHBhcmFtZXRlciBzdHJpbmdcbiAqIEBwYXJhbSB0eXBlIEFCSSBwYXJhbWV0ZXIgdHlwZVxuICogQHBhcmFtIHN0cnVjdHMgU3RydWN0IGRlZmluaXRpb25zIHRvIGluY2x1ZGUgaW4gY2FjaGUga2V5XG4gKiBAcmV0dXJucyBDYWNoZSBrZXkgZm9yIHtAbGluayBwYXJhbWV0ZXJDYWNoZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlckNhY2hlS2V5KHBhcmFtLCB0eXBlLCBzdHJ1Y3RzKSB7XG4gICAgbGV0IHN0cnVjdEtleSA9ICcnO1xuICAgIGlmIChzdHJ1Y3RzKVxuICAgICAgICBmb3IgKGNvbnN0IHN0cnVjdCBvZiBPYmplY3QuZW50cmllcyhzdHJ1Y3RzKSkge1xuICAgICAgICAgICAgaWYgKCFzdHJ1Y3QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHlLZXkgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2Ygc3RydWN0WzFdKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgKz0gYFske3Byb3BlcnR5LnR5cGV9JHtwcm9wZXJ0eS5uYW1lID8gYDoke3Byb3BlcnR5Lm5hbWV9YCA6ICcnfV1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RydWN0S2V5ICs9IGAoJHtzdHJ1Y3RbMF19eyR7cHJvcGVydHlLZXl9fSlgO1xuICAgICAgICB9XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBgJHt0eXBlfToke3BhcmFtfSR7c3RydWN0S2V5fWA7XG4gICAgcmV0dXJuIGAke3BhcmFtfSR7c3RydWN0S2V5fWA7XG59XG4vKipcbiAqIEJhc2ljIGNhY2hlIHNlZWRlZCB3aXRoIGNvbW1vbiBBQkkgcGFyYW1ldGVyIHN0cmluZ3MuXG4gKlxuICogKipOb3RlOiBXaGVuIHNlZWRpbmcgbW9yZSBwYXJhbWV0ZXJzLCBtYWtlIHN1cmUgeW91IGJlbmNobWFyayBwZXJmb3JtYW5jZS4gVGhlIGN1cnJlbnQgbnVtYmVyIGlzIHRoZSBpZGVhbCBiYWxhbmNlIGJldHdlZW4gcGVyZm9ybWFuY2UgYW5kIGhhdmluZyBhbiBhbHJlYWR5IGV4aXN0aW5nIGNhY2hlLioqXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJhbWV0ZXJDYWNoZSA9IG5ldyBNYXAoW1xuICAgIC8vIFVubmFtZWRcbiAgICBbJ2FkZHJlc3MnLCB7IHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAgICBbJ2Jvb2wnLCB7IHR5cGU6ICdib29sJyB9XSxcbiAgICBbJ2J5dGVzJywgeyB0eXBlOiAnYnl0ZXMnIH1dLFxuICAgIFsnYnl0ZXMzMicsIHsgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIFsnaW50JywgeyB0eXBlOiAnaW50MjU2JyB9XSxcbiAgICBbJ2ludDI1NicsIHsgdHlwZTogJ2ludDI1NicgfV0sXG4gICAgWydzdHJpbmcnLCB7IHR5cGU6ICdzdHJpbmcnIH1dLFxuICAgIFsndWludCcsIHsgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICAgIFsndWludDgnLCB7IHR5cGU6ICd1aW50OCcgfV0sXG4gICAgWyd1aW50MTYnLCB7IHR5cGU6ICd1aW50MTYnIH1dLFxuICAgIFsndWludDI0JywgeyB0eXBlOiAndWludDI0JyB9XSxcbiAgICBbJ3VpbnQzMicsIHsgdHlwZTogJ3VpbnQzMicgfV0sXG4gICAgWyd1aW50NjQnLCB7IHR5cGU6ICd1aW50NjQnIH1dLFxuICAgIFsndWludDk2JywgeyB0eXBlOiAndWludDk2JyB9XSxcbiAgICBbJ3VpbnQxMTInLCB7IHR5cGU6ICd1aW50MTEyJyB9XSxcbiAgICBbJ3VpbnQxNjAnLCB7IHR5cGU6ICd1aW50MTYwJyB9XSxcbiAgICBbJ3VpbnQxOTInLCB7IHR5cGU6ICd1aW50MTkyJyB9XSxcbiAgICBbJ3VpbnQyNTYnLCB7IHR5cGU6ICd1aW50MjU2JyB9XSxcbiAgICAvLyBOYW1lZFxuICAgIFsnYWRkcmVzcyBvd25lcicsIHsgdHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAnb3duZXInIH1dLFxuICAgIFsnYWRkcmVzcyB0bycsIHsgdHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAndG8nIH1dLFxuICAgIFsnYm9vbCBhcHByb3ZlZCcsIHsgdHlwZTogJ2Jvb2wnLCBuYW1lOiAnYXBwcm92ZWQnIH1dLFxuICAgIFsnYnl0ZXMgX2RhdGEnLCB7IHR5cGU6ICdieXRlcycsIG5hbWU6ICdfZGF0YScgfV0sXG4gICAgWydieXRlcyBkYXRhJywgeyB0eXBlOiAnYnl0ZXMnLCBuYW1lOiAnZGF0YScgfV0sXG4gICAgWydieXRlcyBzaWduYXR1cmUnLCB7IHR5cGU6ICdieXRlcycsIG5hbWU6ICdzaWduYXR1cmUnIH1dLFxuICAgIFsnYnl0ZXMzMiBoYXNoJywgeyB0eXBlOiAnYnl0ZXMzMicsIG5hbWU6ICdoYXNoJyB9XSxcbiAgICBbJ2J5dGVzMzIgcicsIHsgdHlwZTogJ2J5dGVzMzInLCBuYW1lOiAncicgfV0sXG4gICAgWydieXRlczMyIHJvb3QnLCB7IHR5cGU6ICdieXRlczMyJywgbmFtZTogJ3Jvb3QnIH1dLFxuICAgIFsnYnl0ZXMzMiBzJywgeyB0eXBlOiAnYnl0ZXMzMicsIG5hbWU6ICdzJyB9XSxcbiAgICBbJ3N0cmluZyBuYW1lJywgeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ25hbWUnIH1dLFxuICAgIFsnc3RyaW5nIHN5bWJvbCcsIHsgdHlwZTogJ3N0cmluZycsIG5hbWU6ICdzeW1ib2wnIH1dLFxuICAgIFsnc3RyaW5nIHRva2VuVVJJJywgeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ3Rva2VuVVJJJyB9XSxcbiAgICBbJ3VpbnQgdG9rZW5JZCcsIHsgdHlwZTogJ3VpbnQyNTYnLCBuYW1lOiAndG9rZW5JZCcgfV0sXG4gICAgWyd1aW50OCB2JywgeyB0eXBlOiAndWludDgnLCBuYW1lOiAndicgfV0sXG4gICAgWyd1aW50MjU2IGJhbGFuY2UnLCB7IHR5cGU6ICd1aW50MjU2JywgbmFtZTogJ2JhbGFuY2UnIH1dLFxuICAgIFsndWludDI1NiB0b2tlbklkJywgeyB0eXBlOiAndWludDI1NicsIG5hbWU6ICd0b2tlbklkJyB9XSxcbiAgICBbJ3VpbnQyNTYgdmFsdWUnLCB7IHR5cGU6ICd1aW50MjU2JywgbmFtZTogJ3ZhbHVlJyB9XSxcbiAgICAvLyBJbmRleGVkXG4gICAgW1xuICAgICAgICAnZXZlbnQ6YWRkcmVzcyBpbmRleGVkIGZyb20nLFxuICAgICAgICB7IHR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ2Zyb20nLCBpbmRleGVkOiB0cnVlIH0sXG4gICAgXSxcbiAgICBbJ2V2ZW50OmFkZHJlc3MgaW5kZXhlZCB0bycsIHsgdHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAndG8nLCBpbmRleGVkOiB0cnVlIH1dLFxuICAgIFtcbiAgICAgICAgJ2V2ZW50OnVpbnQgaW5kZXhlZCB0b2tlbklkJyxcbiAgICAgICAgeyB0eXBlOiAndWludDI1NicsIG5hbWU6ICd0b2tlbklkJywgaW5kZXhlZDogdHJ1ZSB9LFxuICAgIF0sXG4gICAgW1xuICAgICAgICAnZXZlbnQ6dWludDI1NiBpbmRleGVkIHRva2VuSWQnLFxuICAgICAgICB7IHR5cGU6ICd1aW50MjU2JywgbmFtZTogJ3Rva2VuSWQnLCBpbmRleGVkOiB0cnVlIH0sXG4gICAgXSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventModifiers: () => (/* binding */ eventModifiers),\n/* harmony export */   execConstructorSignature: () => (/* binding */ execConstructorSignature),\n/* harmony export */   execErrorSignature: () => (/* binding */ execErrorSignature),\n/* harmony export */   execEventSignature: () => (/* binding */ execEventSignature),\n/* harmony export */   execFallbackSignature: () => (/* binding */ execFallbackSignature),\n/* harmony export */   execFunctionSignature: () => (/* binding */ execFunctionSignature),\n/* harmony export */   execStructSignature: () => (/* binding */ execStructSignature),\n/* harmony export */   functionModifiers: () => (/* binding */ functionModifiers),\n/* harmony export */   isConstructorSignature: () => (/* binding */ isConstructorSignature),\n/* harmony export */   isErrorSignature: () => (/* binding */ isErrorSignature),\n/* harmony export */   isEventSignature: () => (/* binding */ isEventSignature),\n/* harmony export */   isFallbackSignature: () => (/* binding */ isFallbackSignature),\n/* harmony export */   isFunctionSignature: () => (/* binding */ isFunctionSignature),\n/* harmony export */   isReceiveSignature: () => (/* binding */ isReceiveSignature),\n/* harmony export */   isStructSignature: () => (/* binding */ isStructSignature),\n/* harmony export */   modifiers: () => (/* binding */ modifiers)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../regex.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(errorSignatureRegex, signature);\n}\n// https://regexr.com/7gmoq\nconst eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(eventSignatureRegex, signature);\n}\n// https://regexr.com/7gmot\nconst functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(functionSignatureRegex, signature);\n}\n// https://regexr.com/7gmp3\nconst structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(structSignatureRegex, signature);\n}\n// https://regexr.com/78u01\nconst constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(constructorSignatureRegex, signature);\n}\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex = /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\nfunction execFallbackSignature(signature) {\n    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.execTyped)(fallbackSignatureRegex, signature);\n}\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nconst modifiers = new Set([\n    'memory',\n    'indexed',\n    'storage',\n    'calldata',\n]);\nconst eventModifiers = new Set(['indexed']);\nconst functionModifiers = new Set([\n    'calldata',\n    'memory',\n    'storage',\n]);\n//# sourceMappingURL=signatures.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3NpZ25hdHVyZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDM0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyxvREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsb0RBQVM7QUFDcEI7QUFDQTtBQUNBLDhIQUE4SCxFQUFFLHVEQUF1RCxFQUFFO0FBQ2xMO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyxvREFBUztBQUNwQjtBQUNBO0FBQ0EsMEVBQTBFLG9CQUFvQjtBQUN2RjtBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsb0RBQVM7QUFDcEI7QUFDQTtBQUNBLHFHQUFxRyxFQUFFO0FBQ2hHO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyxvREFBUztBQUNwQjtBQUNBO0FBQ0Esc0ZBQXNGLEVBQUU7QUFDakY7QUFDUDtBQUNBO0FBQ087QUFDUCxXQUFXLG9EQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3NpZ25hdHVyZXMuanM/MTY5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjVHlwZWQgfSBmcm9tICcuLi8uLi9yZWdleC5qcyc7XG4vLyBodHRwczovL3JlZ2V4ci5jb20vN2dtb2tcbmNvbnN0IGVycm9yU2lnbmF0dXJlUmVnZXggPSAvXmVycm9yICg/PG5hbWU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKVxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3JTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGVycm9yU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZXhlY1R5cGVkKGVycm9yU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XG59XG4vLyBodHRwczovL3JlZ2V4ci5jb20vN2dtb3FcbmNvbnN0IGV2ZW50U2lnbmF0dXJlUmVnZXggPSAvXmV2ZW50ICg/PG5hbWU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKVxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGV2ZW50U2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNFdmVudFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZXhlY1R5cGVkKGV2ZW50U2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XG59XG4vLyBodHRwczovL3JlZ2V4ci5jb20vN2dtb3RcbmNvbnN0IGZ1bmN0aW9uU2lnbmF0dXJlUmVnZXggPSAvXmZ1bmN0aW9uICg/PG5hbWU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKVxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSg/OiAoPzxzY29wZT5leHRlcm5hbHxwdWJsaWN7MX0pKT8oPzogKD88c3RhdGVNdXRhYmlsaXR5PnB1cmV8dmlld3xub25wYXlhYmxlfHBheWFibGV7MX0pKT8oPzogcmV0dXJuc1xccz9cXCgoPzxyZXR1cm5zPi4qPylcXCkpPyQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZXhlY1R5cGVkKGZ1bmN0aW9uU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XG59XG4vLyBodHRwczovL3JlZ2V4ci5jb20vN2dtcDNcbmNvbnN0IHN0cnVjdFNpZ25hdHVyZVJlZ2V4ID0gL15zdHJ1Y3QgKD88bmFtZT5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSopIFxceyg/PHByb3BlcnRpZXM+Lio/KVxcfSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBzdHJ1Y3RTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhlY1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZXhlY1R5cGVkKHN0cnVjdFNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzc4dTAxXG5jb25zdCBjb25zdHJ1Y3RvclNpZ25hdHVyZVJlZ2V4ID0gL15jb25zdHJ1Y3RvclxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSg/Olxccyg/PHN0YXRlTXV0YWJpbGl0eT5wYXlhYmxlezF9KSk/JC87XG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3JTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhlY0NvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBleGVjVHlwZWQoY29uc3RydWN0b3JTaWduYXR1cmVSZWdleCwgc2lnbmF0dXJlKTtcbn1cbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS83c3J0blxuY29uc3QgZmFsbGJhY2tTaWduYXR1cmVSZWdleCA9IC9eZmFsbGJhY2tcXChcXCkgZXh0ZXJuYWwoPzpcXHMoPzxzdGF0ZU11dGFiaWxpdHk+cGF5YWJsZXsxfSkpPyQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZXhlY1R5cGVkKGZhbGxiYWNrU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XG59XG4vLyBodHRwczovL3JlZ2V4ci5jb20vNzh1MWtcbmNvbnN0IHJlY2VpdmVTaWduYXR1cmVSZWdleCA9IC9ecmVjZWl2ZVxcKFxcKSBleHRlcm5hbCBwYXlhYmxlJC87XG5leHBvcnQgZnVuY3Rpb24gaXNSZWNlaXZlU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiByZWNlaXZlU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZXhwb3J0IGNvbnN0IG1vZGlmaWVycyA9IG5ldyBTZXQoW1xuICAgICdtZW1vcnknLFxuICAgICdpbmRleGVkJyxcbiAgICAnc3RvcmFnZScsXG4gICAgJ2NhbGxkYXRhJyxcbl0pO1xuZXhwb3J0IGNvbnN0IGV2ZW50TW9kaWZpZXJzID0gbmV3IFNldChbJ2luZGV4ZWQnXSk7XG5leHBvcnQgY29uc3QgZnVuY3Rpb25Nb2RpZmllcnMgPSBuZXcgU2V0KFtcbiAgICAnY2FsbGRhdGEnLFxuICAgICdtZW1vcnknLFxuICAgICdzdG9yYWdlJyxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseStructs: () => (/* binding */ parseStructs)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../regex.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/abiItem.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors/abiParameter.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\");\n/* harmony import */ var _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/signature.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js\");\n/* harmony import */ var _errors_struct_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/struct.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/struct.js\");\n/* harmony import */ var _signatures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signatures.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n\n\n\nfunction parseStructs(signatures) {\n    // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for (let i = 0; i < signaturesLength; i++) {\n        const signature = signatures[i];\n        if (!(0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isStructSignature)(signature))\n            continue;\n        const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execStructSignature)(signature);\n        if (!match)\n            throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'struct' });\n        const properties = match.properties.split(';');\n        const components = [];\n        const propertiesLength = properties.length;\n        for (let k = 0; k < propertiesLength; k++) {\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed)\n                continue;\n            const abiParameter = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseAbiParameter)(trimmed, {\n                type: 'struct',\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length)\n            throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidStructSignatureError({ signature });\n        shallowStructs[match.name] = components;\n    }\n    // Resolve nested structs inside each parameter\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for (let i = 0; i < entriesLength; i++) {\n        const [name, parameters] = entries[i];\n        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters = [], structs = {}, ancestors = new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        const isTuple = _regex_js__WEBPACK_IMPORTED_MODULE_3__.isTupleRegex.test(abiParameter.type);\n        if (isTuple)\n            components.push(abiParameter);\n        else {\n            const match = (0,_regex_js__WEBPACK_IMPORTED_MODULE_3__.execTyped)(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type)\n                throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidAbiTypeParameterError({ abiParameter });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type))\n                    throw new _errors_struct_js__WEBPACK_IMPORTED_MODULE_5__.CircularReferenceError({ type });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? ''}`,\n                    components: resolveStructs(structs[type], structs, new Set([...ancestors, type])),\n                });\n            }\n            else {\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isSolidityType)(type))\n                    components.push(abiParameter);\n                else\n                    throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_6__.UnknownTypeError({ type });\n            }\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=structs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3N0cnVjdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDRDtBQUNpQjtBQUNvQjtBQUNoQztBQUNZO0FBQ1Y7QUFDeEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsYUFBYSxpRUFBaUI7QUFDOUI7QUFDQSxzQkFBc0IsbUVBQW1CO0FBQ3pDO0FBQ0Esc0JBQXNCLHVFQUFxQixHQUFHLDJCQUEyQjtBQUN6RSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQWlCO0FBQ2xEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2RUFBMkIsR0FBRyxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLHdCQUF3QixtREFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQVM7QUFDbkM7QUFDQSwwQkFBMEIsaUZBQTRCLEdBQUcsY0FBYztBQUN2RSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0EsOEJBQThCLHFFQUFzQixHQUFHLE1BQU07QUFDN0Q7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0IseURBQWM7QUFDbEM7QUFDQTtBQUNBLDhCQUE4QixnRUFBZ0IsR0FBRyxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9zdHJ1Y3RzLmpzPzcyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlY1R5cGVkLCBpc1R1cGxlUmVnZXggfSBmcm9tICcuLi8uLi9yZWdleC5qcyc7XG5pbXBvcnQgeyBVbmtub3duVHlwZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2FiaUl0ZW0uanMnO1xuaW1wb3J0IHsgSW52YWxpZEFiaVR5cGVQYXJhbWV0ZXJFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9hYmlQYXJhbWV0ZXIuanMnO1xuaW1wb3J0IHsgSW52YWxpZFNpZ25hdHVyZUVycm9yLCBJbnZhbGlkU3RydWN0U2lnbmF0dXJlRXJyb3IsIH0gZnJvbSAnLi4vZXJyb3JzL3NpZ25hdHVyZS5qcyc7XG5pbXBvcnQgeyBDaXJjdWxhclJlZmVyZW5jZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3N0cnVjdC5qcyc7XG5pbXBvcnQgeyBleGVjU3RydWN0U2lnbmF0dXJlLCBpc1N0cnVjdFNpZ25hdHVyZSB9IGZyb20gJy4vc2lnbmF0dXJlcy5qcyc7XG5pbXBvcnQgeyBpc1NvbGlkaXR5VHlwZSwgcGFyc2VBYmlQYXJhbWV0ZXIgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlcykge1xuICAgIC8vIENyZWF0ZSBcInNoYWxsb3dcIiB2ZXJzaW9uIG9mIGVhY2ggc3RydWN0IChhbmQgZmlsdGVyIG91dCBub24tc3RydWN0cyBvciBpbnZhbGlkIHN0cnVjdHMpXG4gICAgY29uc3Qgc2hhbGxvd1N0cnVjdHMgPSB7fTtcbiAgICBjb25zdCBzaWduYXR1cmVzTGVuZ3RoID0gc2lnbmF0dXJlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcbiAgICAgICAgaWYgKCFpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXhlY1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogJ3N0cnVjdCcgfSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYXRjaC5wcm9wZXJ0aWVzLnNwbGl0KCc7Jyk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHByb3BlcnRpZXNMZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2tdO1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHByb3BlcnR5LnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghdHJpbW1lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IHBhcnNlQWJpUGFyYW1ldGVyKHRyaW1tZWQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGFiaVBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RydWN0U2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgICAgIHNoYWxsb3dTdHJ1Y3RzW21hdGNoLm5hbWVdID0gY29tcG9uZW50cztcbiAgICB9XG4gICAgLy8gUmVzb2x2ZSBuZXN0ZWQgc3RydWN0cyBpbnNpZGUgZWFjaCBwYXJhbWV0ZXJcbiAgICBjb25zdCByZXNvbHZlZFN0cnVjdHMgPSB7fTtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc2hhbGxvd1N0cnVjdHMpO1xuICAgIGNvbnN0IGVudHJpZXNMZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBbbmFtZSwgcGFyYW1ldGVyc10gPSBlbnRyaWVzW2ldO1xuICAgICAgICByZXNvbHZlZFN0cnVjdHNbbmFtZV0gPSByZXNvbHZlU3RydWN0cyhwYXJhbWV0ZXJzLCBzaGFsbG93U3RydWN0cyk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZFN0cnVjdHM7XG59XG5jb25zdCB0eXBlV2l0aG91dFR1cGxlUmVnZXggPSAvXig/PHR5cGU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKSg/PGFycmF5Pig/OlxcW1xcZCo/XFxdKSs/KT8kLztcbmZ1bmN0aW9uIHJlc29sdmVTdHJ1Y3RzKGFiaVBhcmFtZXRlcnMgPSBbXSwgc3RydWN0cyA9IHt9LCBhbmNlc3RvcnMgPSBuZXcgU2V0KCkpIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gYWJpUGFyYW1ldGVycy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSBhYmlQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBjb25zdCBpc1R1cGxlID0gaXNUdXBsZVJlZ2V4LnRlc3QoYWJpUGFyYW1ldGVyLnR5cGUpO1xuICAgICAgICBpZiAoaXNUdXBsZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChhYmlQYXJhbWV0ZXIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gZXhlY1R5cGVkKHR5cGVXaXRob3V0VHVwbGVSZWdleCwgYWJpUGFyYW1ldGVyLnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaD8udHlwZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFiaVR5cGVQYXJhbWV0ZXJFcnJvcih7IGFiaVBhcmFtZXRlciB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJyYXksIHR5cGUgfSA9IG1hdGNoO1xuICAgICAgICAgICAgaWYgKHR5cGUgaW4gc3RydWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2lyY3VsYXJSZWZlcmVuY2VFcnJvcih7IHR5cGUgfSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWJpUGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBgdHVwbGUke2FycmF5ID8/ICcnfWAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHJlc29sdmVTdHJ1Y3RzKHN0cnVjdHNbdHlwZV0sIHN0cnVjdHMsIG5ldyBTZXQoWy4uLmFuY2VzdG9ycywgdHlwZV0pKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1NvbGlkaXR5VHlwZSh0eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGFiaVBhcmFtZXRlcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5rbm93blR5cGVFcnJvcih7IHR5cGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJ1Y3RzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSolidityKeyword: () => (/* binding */ isSolidityKeyword),\n/* harmony export */   isSolidityType: () => (/* binding */ isSolidityType),\n/* harmony export */   isValidDataLocation: () => (/* binding */ isValidDataLocation),\n/* harmony export */   parseAbiParameter: () => (/* binding */ parseAbiParameter),\n/* harmony export */   parseConstructorSignature: () => (/* binding */ parseConstructorSignature),\n/* harmony export */   parseErrorSignature: () => (/* binding */ parseErrorSignature),\n/* harmony export */   parseEventSignature: () => (/* binding */ parseEventSignature),\n/* harmony export */   parseFallbackSignature: () => (/* binding */ parseFallbackSignature),\n/* harmony export */   parseFunctionSignature: () => (/* binding */ parseFunctionSignature),\n/* harmony export */   parseSignature: () => (/* binding */ parseSignature),\n/* harmony export */   splitParameters: () => (/* binding */ splitParameters)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../regex.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\");\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/abiItem.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors/abiParameter.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\");\n/* harmony import */ var _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/signature.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/signature.js\");\n/* harmony import */ var _errors_splitParameters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/splitParameters.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js\");\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/cache.js\");\n/* harmony import */ var _signatures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signatures.js */ \"(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n\n\n\n\n\n\n\nfunction parseSignature(signature, structs = {}) {\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isFunctionSignature)(signature))\n        return parseFunctionSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isEventSignature)(signature))\n        return parseEventSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isErrorSignature)(signature))\n        return parseErrorSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isConstructorSignature)(signature))\n        return parseConstructorSignature(signature, structs);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isFallbackSignature)(signature))\n        return parseFallbackSignature(signature);\n    if ((0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.isReceiveSignature)(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.UnknownSignatureError({ signature });\n}\nfunction parseFunctionSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execFunctionSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'function' });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n        inputs.push(parseAbiParameter(inputParams[i], {\n            modifiers: _signatures_js__WEBPACK_IMPORTED_MODULE_0__.functionModifiers,\n            structs,\n            type: 'function',\n        }));\n    }\n    const outputs = [];\n    if (match.returns) {\n        const outputParams = splitParameters(match.returns);\n        const outputLength = outputParams.length;\n        for (let i = 0; i < outputLength; i++) {\n            outputs.push(parseAbiParameter(outputParams[i], {\n                modifiers: _signatures_js__WEBPACK_IMPORTED_MODULE_0__.functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n    }\n    return {\n        name: match.name,\n        type: 'function',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs,\n        outputs,\n    };\n}\nfunction parseEventSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execEventSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'event' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], {\n            modifiers: _signatures_js__WEBPACK_IMPORTED_MODULE_0__.eventModifiers,\n            structs,\n            type: 'event',\n        }));\n    return { name: match.name, type: 'event', inputs: abiParameters };\n}\nfunction parseErrorSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execErrorSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'error' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n    return { name: match.name, type: 'error', inputs: abiParameters };\n}\nfunction parseConstructorSignature(signature, structs = {}) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execConstructorSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'constructor' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n    return {\n        type: 'constructor',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs: abiParameters,\n    };\n}\nfunction parseFallbackSignature(signature) {\n    const match = (0,_signatures_js__WEBPACK_IMPORTED_MODULE_0__.execFallbackSignature)(signature);\n    if (!match)\n        throw new _errors_signature_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSignatureError({ signature, type: 'fallback' });\n    return {\n        type: 'fallback',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n    };\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\\spayable)?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n    // optional namespace cache by `type`\n    const parameterCacheKey = (0,_cache_js__WEBPACK_IMPORTED_MODULE_2__.getParameterCacheKey)(param, options?.type, options?.structs);\n    if (_cache_js__WEBPACK_IMPORTED_MODULE_2__.parameterCache.has(parameterCacheKey))\n        return _cache_js__WEBPACK_IMPORTED_MODULE_2__.parameterCache.get(parameterCacheKey);\n    const isTuple = _regex_js__WEBPACK_IMPORTED_MODULE_3__.isTupleRegex.test(param);\n    const match = (0,_regex_js__WEBPACK_IMPORTED_MODULE_3__.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            // remove `modifiers` from `options` to prevent from being added to tuple components\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else if (match.type === 'address payable') {\n        type = 'address';\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_5__.UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        // Check if resolved `type` is valid if there is a function modifier\n        if (_signatures_js__WEBPACK_IMPORTED_MODULE_0__.functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new _errors_abiParameter_js__WEBPACK_IMPORTED_MODULE_4__.InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    _cache_js__WEBPACK_IMPORTED_MODULE_2__.parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\n// s/o latika for this\nfunction splitParameters(params, result = [], current = '', depth = 0) {\n    const length = params.trim().length;\n    // biome-ignore lint/correctness/noUnreachable: recursive\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    if (current === '')\n        return result;\n    if (depth !== 0)\n        throw new _errors_splitParameters_js__WEBPACK_IMPORTED_MODULE_6__.InvalidParenthesisError({ current, depth });\n    result.push(current.trim());\n    return result;\n}\nfunction isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.bytesRegex.test(type) ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.integerRegex.test(type));\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nfunction isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.bytesRegex.test(name) ||\n        _regex_js__WEBPACK_IMPORTED_MODULE_3__.integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\n/** @internal */\nfunction isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjtBQUNwQjtBQUNzRjtBQUMvRDtBQUNoQjtBQUNMO0FBQzZPO0FBQ3hTLCtDQUErQztBQUN0RCxRQUFRLG1FQUFtQjtBQUMzQjtBQUNBLFFBQVEsZ0VBQWdCO0FBQ3hCO0FBQ0EsUUFBUSxnRUFBZ0I7QUFDeEI7QUFDQSxRQUFRLHNFQUFzQjtBQUM5QjtBQUNBLFFBQVEsbUVBQW1CO0FBQzNCO0FBQ0EsUUFBUSxrRUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUFxQixHQUFHLFdBQVc7QUFDakQ7QUFDTyx1REFBdUQ7QUFDOUQsa0JBQWtCLHFFQUFxQjtBQUN2QztBQUNBLGtCQUFrQix1RUFBcUIsR0FBRyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBLHVCQUF1Qiw2REFBaUI7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLDJCQUEyQiw2REFBaUI7QUFDNUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9EQUFvRDtBQUMzRCxrQkFBa0Isa0VBQWtCO0FBQ3BDO0FBQ0Esa0JBQWtCLHVFQUFxQixHQUFHLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLHVCQUF1QiwwREFBYztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYjtBQUNPLG9EQUFvRDtBQUMzRCxrQkFBa0Isa0VBQWtCO0FBQ3BDO0FBQ0Esa0JBQWtCLHVFQUFxQixHQUFHLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQywwREFBMEQsd0JBQXdCO0FBQ2xGLGFBQWE7QUFDYjtBQUNPLDBEQUEwRDtBQUNqRSxrQkFBa0Isd0VBQXdCO0FBQzFDO0FBQ0Esa0JBQWtCLHVFQUFxQixHQUFHLGdDQUFnQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQywwREFBMEQsOEJBQThCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLHFFQUFxQjtBQUN2QztBQUNBLGtCQUFrQix1RUFBcUIsR0FBRyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlLQUFpSyxFQUFFO0FBQ25LLCtIQUErSCxFQUFFO0FBQ2pJO0FBQ087QUFDUDtBQUNBLDhCQUE4QiwrREFBb0I7QUFDbEQsUUFBUSxxREFBYztBQUN0QixlQUFlLHFEQUFjO0FBQzdCLG9CQUFvQixtREFBWTtBQUNoQyxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQSxrQkFBa0IsMEVBQXFCLEdBQUcsT0FBTztBQUNqRDtBQUNBLGtCQUFrQixrRkFBNkIsR0FBRyx5QkFBeUI7QUFDM0UsZ0NBQWdDLG1CQUFtQjtBQUNuRCxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0VBQXdCLEdBQUcsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5RUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWSw2REFBaUI7QUFDN0I7QUFDQSxzQkFBc0IsaUZBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLEtBQUssRUFBRSxrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRLEVBQUUsS0FBSztBQUN0RTtBQUNBLHdEQUF3RCxRQUFRLEVBQUUsS0FBSztBQUN2RTtBQUNBLHdEQUF3RCxRQUFRLEVBQUUsS0FBSztBQUN2RTtBQUNBLHdEQUF3RCxRQUFRLEVBQUUsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtFQUF1QixHQUFHLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBVTtBQUNsQixRQUFRLG1EQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQVU7QUFDbEIsUUFBUSxtREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS91dGlscy5qcz84MmRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzUmVnZXgsIGV4ZWNUeXBlZCwgaW50ZWdlclJlZ2V4LCBpc1R1cGxlUmVnZXgsIH0gZnJvbSAnLi4vLi4vcmVnZXguanMnO1xuaW1wb3J0IHsgVW5rbm93blNvbGlkaXR5VHlwZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2FiaUl0ZW0uanMnO1xuaW1wb3J0IHsgSW52YWxpZEZ1bmN0aW9uTW9kaWZpZXJFcnJvciwgSW52YWxpZE1vZGlmaWVyRXJyb3IsIEludmFsaWRQYXJhbWV0ZXJFcnJvciwgU29saWRpdHlQcm90ZWN0ZWRLZXl3b3JkRXJyb3IsIH0gZnJvbSAnLi4vZXJyb3JzL2FiaVBhcmFtZXRlci5qcyc7XG5pbXBvcnQgeyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IsIFVua25vd25TaWduYXR1cmVFcnJvciwgfSBmcm9tICcuLi9lcnJvcnMvc2lnbmF0dXJlLmpzJztcbmltcG9ydCB7IEludmFsaWRQYXJlbnRoZXNpc0Vycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3NwbGl0UGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgeyBnZXRQYXJhbWV0ZXJDYWNoZUtleSwgcGFyYW1ldGVyQ2FjaGUgfSBmcm9tICcuL2NhY2hlLmpzJztcbmltcG9ydCB7IGV2ZW50TW9kaWZpZXJzLCBleGVjQ29uc3RydWN0b3JTaWduYXR1cmUsIGV4ZWNFcnJvclNpZ25hdHVyZSwgZXhlY0V2ZW50U2lnbmF0dXJlLCBleGVjRmFsbGJhY2tTaWduYXR1cmUsIGV4ZWNGdW5jdGlvblNpZ25hdHVyZSwgZnVuY3Rpb25Nb2RpZmllcnMsIGlzQ29uc3RydWN0b3JTaWduYXR1cmUsIGlzRXJyb3JTaWduYXR1cmUsIGlzRXZlbnRTaWduYXR1cmUsIGlzRmFsbGJhY2tTaWduYXR1cmUsIGlzRnVuY3Rpb25TaWduYXR1cmUsIGlzUmVjZWl2ZVNpZ25hdHVyZSwgfSBmcm9tICcuL3NpZ25hdHVyZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyA9IHt9KSB7XG4gICAgaWYgKGlzRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKTtcbiAgICBpZiAoaXNFdmVudFNpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudFNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMpO1xuICAgIGlmIChpc0Vycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgIHJldHVybiBwYXJzZUVycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyk7XG4gICAgaWYgKGlzQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgcmV0dXJuIHBhcnNlQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKTtcbiAgICBpZiAoaXNGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgICByZXR1cm4gcGFyc2VGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmIChpc1JlY2VpdmVTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWNlaXZlJyxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3BheWFibGUnLFxuICAgICAgICB9O1xuICAgIHRocm93IG5ldyBVbmtub3duU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhlY0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogJ2Z1bmN0aW9uJyB9KTtcbiAgICBjb25zdCBpbnB1dFBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5wYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBpbnB1dHMgPSBbXTtcbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0UGFyYW1zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5wdXRzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXIoaW5wdXRQYXJhbXNbaV0sIHtcbiAgICAgICAgICAgIG1vZGlmaWVyczogZnVuY3Rpb25Nb2RpZmllcnMsXG4gICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgaWYgKG1hdGNoLnJldHVybnMpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0UGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnJldHVybnMpO1xuICAgICAgICBjb25zdCBvdXRwdXRMZW5ndGggPSBvdXRwdXRQYXJhbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXIob3V0cHV0UGFyYW1zW2ldLCB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBmdW5jdGlvbk1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbWF0Y2gubmFtZSxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBtYXRjaC5zdGF0ZU11dGFiaWxpdHkgPz8gJ25vbnBheWFibGUnLFxuICAgICAgICBpbnB1dHMsXG4gICAgICAgIG91dHB1dHMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV2ZW50U2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyA9IHt9KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlLCB0eXBlOiAnZXZlbnQnIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5wYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBhYmlQYXJhbWV0ZXJzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7XG4gICAgICAgICAgICBtb2RpZmllcnM6IGV2ZW50TW9kaWZpZXJzLFxuICAgICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgIH0pKTtcbiAgICByZXR1cm4geyBuYW1lOiBtYXRjaC5uYW1lLCB0eXBlOiAnZXZlbnQnLCBpbnB1dHM6IGFiaVBhcmFtZXRlcnMgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyA9IHt9KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjRXJyb3JTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlLCB0eXBlOiAnZXJyb3InIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5wYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBhYmlQYXJhbWV0ZXJzLnB1c2gocGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7IHN0cnVjdHMsIHR5cGU6ICdlcnJvcicgfSkpO1xuICAgIHJldHVybiB7IG5hbWU6IG1hdGNoLm5hbWUsIHR5cGU6ICdlcnJvcicsIGlucHV0czogYWJpUGFyYW1ldGVycyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzID0ge30pIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUsIHR5cGU6ICdjb25zdHJ1Y3RvcicgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHsgc3RydWN0cywgdHlwZTogJ2NvbnN0cnVjdG9yJyB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBtYXRjaC5zdGF0ZU11dGFiaWxpdHkgPz8gJ25vbnBheWFibGUnLFxuICAgICAgICBpbnB1dHM6IGFiaVBhcmFtZXRlcnMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhlY0ZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogJ2ZhbGxiYWNrJyB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZmFsbGJhY2snLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IG1hdGNoLnN0YXRlTXV0YWJpbGl0eSA/PyAnbm9ucGF5YWJsZScsXG4gICAgfTtcbn1cbmNvbnN0IGFiaVBhcmFtZXRlcldpdGhvdXRUdXBsZVJlZ2V4ID0gL14oPzx0eXBlPlthLXpBLVokX11bYS16QS1aMC05JF9dKig/Olxcc3BheWFibGUpPykoPzxhcnJheT4oPzpcXFtcXGQqP1xcXSkrPyk/KD86XFxzKD88bW9kaWZpZXI+Y2FsbGRhdGF8aW5kZXhlZHxtZW1vcnl8c3RvcmFnZXsxfSkpPyg/Olxccyg/PG5hbWU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKSk/JC87XG5jb25zdCBhYmlQYXJhbWV0ZXJXaXRoVHVwbGVSZWdleCA9IC9eXFwoKD88dHlwZT4uKz8pXFwpKD88YXJyYXk+KD86XFxbXFxkKj9cXF0pKz8pPyg/Olxccyg/PG1vZGlmaWVyPmNhbGxkYXRhfGluZGV4ZWR8bWVtb3J5fHN0b3JhZ2V7MX0pKT8oPzpcXHMoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKikpPyQvO1xuY29uc3QgZHluYW1pY0ludGVnZXJSZWdleCA9IC9edT9pbnQkLztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFiaVBhcmFtZXRlcihwYXJhbSwgb3B0aW9ucykge1xuICAgIC8vIG9wdGlvbmFsIG5hbWVzcGFjZSBjYWNoZSBieSBgdHlwZWBcbiAgICBjb25zdCBwYXJhbWV0ZXJDYWNoZUtleSA9IGdldFBhcmFtZXRlckNhY2hlS2V5KHBhcmFtLCBvcHRpb25zPy50eXBlLCBvcHRpb25zPy5zdHJ1Y3RzKTtcbiAgICBpZiAocGFyYW1ldGVyQ2FjaGUuaGFzKHBhcmFtZXRlckNhY2hlS2V5KSlcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlckNhY2hlLmdldChwYXJhbWV0ZXJDYWNoZUtleSk7XG4gICAgY29uc3QgaXNUdXBsZSA9IGlzVHVwbGVSZWdleC50ZXN0KHBhcmFtKTtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNUeXBlZChpc1R1cGxlID8gYWJpUGFyYW1ldGVyV2l0aFR1cGxlUmVnZXggOiBhYmlQYXJhbWV0ZXJXaXRob3V0VHVwbGVSZWdleCwgcGFyYW0pO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1ldGVyRXJyb3IoeyBwYXJhbSB9KTtcbiAgICBpZiAobWF0Y2gubmFtZSAmJiBpc1NvbGlkaXR5S2V5d29yZChtYXRjaC5uYW1lKSlcbiAgICAgICAgdGhyb3cgbmV3IFNvbGlkaXR5UHJvdGVjdGVkS2V5d29yZEVycm9yKHsgcGFyYW0sIG5hbWU6IG1hdGNoLm5hbWUgfSk7XG4gICAgY29uc3QgbmFtZSA9IG1hdGNoLm5hbWUgPyB7IG5hbWU6IG1hdGNoLm5hbWUgfSA6IHt9O1xuICAgIGNvbnN0IGluZGV4ZWQgPSBtYXRjaC5tb2RpZmllciA9PT0gJ2luZGV4ZWQnID8geyBpbmRleGVkOiB0cnVlIH0gOiB7fTtcbiAgICBjb25zdCBzdHJ1Y3RzID0gb3B0aW9ucz8uc3RydWN0cyA/PyB7fTtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgY29tcG9uZW50cyA9IHt9O1xuICAgIGlmIChpc1R1cGxlKSB7XG4gICAgICAgIHR5cGUgPSAndHVwbGUnO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gudHlwZSk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHNfID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBgbW9kaWZpZXJzYCBmcm9tIGBvcHRpb25zYCB0byBwcmV2ZW50IGZyb20gYmVpbmcgYWRkZWQgdG8gdHVwbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgY29tcG9uZW50c18ucHVzaChwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHsgc3RydWN0cyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50cyA9IHsgY29tcG9uZW50czogY29tcG9uZW50c18gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2gudHlwZSBpbiBzdHJ1Y3RzKSB7XG4gICAgICAgIHR5cGUgPSAndHVwbGUnO1xuICAgICAgICBjb21wb25lbnRzID0geyBjb21wb25lbnRzOiBzdHJ1Y3RzW21hdGNoLnR5cGVdIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGR5bmFtaWNJbnRlZ2VyUmVnZXgudGVzdChtYXRjaC50eXBlKSkge1xuICAgICAgICB0eXBlID0gYCR7bWF0Y2gudHlwZX0yNTZgO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXRjaC50eXBlID09PSAnYWRkcmVzcyBwYXlhYmxlJykge1xuICAgICAgICB0eXBlID0gJ2FkZHJlc3MnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9IG1hdGNoLnR5cGU7XG4gICAgICAgIGlmICghKG9wdGlvbnM/LnR5cGUgPT09ICdzdHJ1Y3QnKSAmJiAhaXNTb2xpZGl0eVR5cGUodHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5rbm93blNvbGlkaXR5VHlwZUVycm9yKHsgdHlwZSB9KTtcbiAgICB9XG4gICAgaWYgKG1hdGNoLm1vZGlmaWVyKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG1vZGlmaWVyIGV4aXN0cywgYnV0IGlzIG5vdCBhbGxvd2VkIChlLmcuIGBpbmRleGVkYCBpbiBgZnVuY3Rpb25Nb2RpZmllcnNgKVxuICAgICAgICBpZiAoIW9wdGlvbnM/Lm1vZGlmaWVycz8uaGFzPy4obWF0Y2gubW9kaWZpZXIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNb2RpZmllckVycm9yKHtcbiAgICAgICAgICAgICAgICBwYXJhbSxcbiAgICAgICAgICAgICAgICB0eXBlOiBvcHRpb25zPy50eXBlLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBtYXRjaC5tb2RpZmllcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayBpZiByZXNvbHZlZCBgdHlwZWAgaXMgdmFsaWQgaWYgdGhlcmUgaXMgYSBmdW5jdGlvbiBtb2RpZmllclxuICAgICAgICBpZiAoZnVuY3Rpb25Nb2RpZmllcnMuaGFzKG1hdGNoLm1vZGlmaWVyKSAmJlxuICAgICAgICAgICAgIWlzVmFsaWREYXRhTG9jYXRpb24odHlwZSwgISFtYXRjaC5hcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEZ1bmN0aW9uTW9kaWZpZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgcGFyYW0sXG4gICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucz8udHlwZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogbWF0Y2gubW9kaWZpZXIsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYWJpUGFyYW1ldGVyID0ge1xuICAgICAgICB0eXBlOiBgJHt0eXBlfSR7bWF0Y2guYXJyYXkgPz8gJyd9YCxcbiAgICAgICAgLi4ubmFtZSxcbiAgICAgICAgLi4uaW5kZXhlZCxcbiAgICAgICAgLi4uY29tcG9uZW50cyxcbiAgICB9O1xuICAgIHBhcmFtZXRlckNhY2hlLnNldChwYXJhbWV0ZXJDYWNoZUtleSwgYWJpUGFyYW1ldGVyKTtcbiAgICByZXR1cm4gYWJpUGFyYW1ldGVyO1xufVxuLy8gcy9vIGxhdGlrYSBmb3IgdGhpc1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0UGFyYW1ldGVycyhwYXJhbXMsIHJlc3VsdCA9IFtdLCBjdXJyZW50ID0gJycsIGRlcHRoID0gMCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy50cmltKCkubGVuZ3RoO1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL25vVW5yZWFjaGFibGU6IHJlY3Vyc2l2ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHBhcmFtc1tpXTtcbiAgICAgICAgY29uc3QgdGFpbCA9IHBhcmFtcy5zbGljZShpICsgMSk7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIFsuLi5yZXN1bHQsIGN1cnJlbnQudHJpbSgpXSlcbiAgICAgICAgICAgICAgICAgICAgOiBzcGxpdFBhcmFtZXRlcnModGFpbCwgcmVzdWx0LCBgJHtjdXJyZW50fSR7Y2hhcn1gLCBkZXB0aCk7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgIHJldHVybiBzcGxpdFBhcmFtZXRlcnModGFpbCwgcmVzdWx0LCBgJHtjdXJyZW50fSR7Y2hhcn1gLCBkZXB0aCAtIDEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50ID09PSAnJylcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoZGVwdGggIT09IDApXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyZW50aGVzaXNFcnJvcih7IGN1cnJlbnQsIGRlcHRoIH0pO1xuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU29saWRpdHlUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdhZGRyZXNzJyB8fFxuICAgICAgICB0eXBlID09PSAnYm9vbCcgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBieXRlc1JlZ2V4LnRlc3QodHlwZSkgfHxcbiAgICAgICAgaW50ZWdlclJlZ2V4LnRlc3QodHlwZSkpO1xufVxuY29uc3QgcHJvdGVjdGVkS2V5d29yZHNSZWdleCA9IC9eKD86YWZ0ZXJ8YWxpYXN8YW5vbnltb3VzfGFwcGx5fGF1dG98Ynl0ZXxjYWxsZGF0YXxjYXNlfGNhdGNofGNvbnN0YW50fGNvcHlvZnxkZWZhdWx0fGRlZmluZWR8ZXJyb3J8ZXZlbnR8ZXh0ZXJuYWx8ZmFsc2V8ZmluYWx8ZnVuY3Rpb258aW1tdXRhYmxlfGltcGxlbWVudHN8aW58aW5kZXhlZHxpbmxpbmV8aW50ZXJuYWx8bGV0fG1hcHBpbmd8bWF0Y2h8bWVtb3J5fG11dGFibGV8bnVsbHxvZnxvdmVycmlkZXxwYXJ0aWFsfHByaXZhdGV8cHJvbWlzZXxwdWJsaWN8cHVyZXxyZWZlcmVuY2V8cmVsb2NhdGFibGV8cmV0dXJufHJldHVybnN8c2l6ZW9mfHN0YXRpY3xzdG9yYWdlfHN0cnVjdHxzdXBlcnxzdXBwb3J0c3xzd2l0Y2h8dGhpc3x0cnVlfHRyeXx0eXBlZGVmfHR5cGVvZnx2YXJ8dmlld3x2aXJ0dWFsKSQvO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU29saWRpdHlLZXl3b3JkKG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUgPT09ICdhZGRyZXNzJyB8fFxuICAgICAgICBuYW1lID09PSAnYm9vbCcgfHxcbiAgICAgICAgbmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBuYW1lID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBuYW1lID09PSAndHVwbGUnIHx8XG4gICAgICAgIGJ5dGVzUmVnZXgudGVzdChuYW1lKSB8fFxuICAgICAgICBpbnRlZ2VyUmVnZXgudGVzdChuYW1lKSB8fFxuICAgICAgICBwcm90ZWN0ZWRLZXl3b3Jkc1JlZ2V4LnRlc3QobmFtZSkpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREYXRhTG9jYXRpb24odHlwZSwgaXNBcnJheSkge1xuICAgIHJldHVybiBpc0FycmF5IHx8IHR5cGUgPT09ICdieXRlcycgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ3R1cGxlJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/regex.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   execTyped: () => (/* binding */ execTyped),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   isTupleRegex: () => (/* binding */ isTupleRegex)\n/* harmony export */ });\n// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nfunction execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9yZWdleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2JhYmxlLW1hcmtldHMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vcmVnZXguanM/YzIzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBUaGlzIGxvb2tzIGNvb2wuIE5lZWQgdG8gY2hlY2sgdGhlIHBlcmZvcm1hbmNlIG9mIGBuZXcgUmVnRXhwYCB2ZXJzdXMgZGVmaW5lZCBpbmxpbmUgdGhvdWdoLlxuLy8gaHR0cHM6Ly90d2l0dGVyLmNvbS9HYWJyaWVsVmVyZ25hdWQvc3RhdHVzLzE2MjI5MDY4MzQzNDMzNjY2NTdcbmV4cG9ydCBmdW5jdGlvbiBleGVjVHlwZWQocmVnZXgsIHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcpO1xuICAgIHJldHVybiBtYXRjaD8uZ3JvdXBzO1xufVxuLy8gYGJ5dGVzPE0+YDogYmluYXJ5IHR5cGUgb2YgYE1gIGJ5dGVzLCBgMCA8IE0gPD0gMzJgXG4vLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNTVcbmV4cG9ydCBjb25zdCBieXRlc1JlZ2V4ID0gL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC87XG4vLyBgKHUpaW50PE0+YDogKHVuKXNpZ25lZCBpbnRlZ2VyIHR5cGUgb2YgYE1gIGJpdHMsIGAwIDwgTSA8PSAyNTZgLCBgTSAlIDggPT0gMGBcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS82djhocFxuZXhwb3J0IGNvbnN0IGludGVnZXJSZWdleCA9IC9edT9pbnQoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbmV4cG9ydCBjb25zdCBpc1R1cGxlUmVnZXggPSAvXlxcKC4rP1xcKS4qPyQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/regex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/version.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '1.2.3';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvYmFibGUtbWFya2V0cy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS92ZXJzaW9uLmpzP2RiYjUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yLjMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ox/node_modules/abitype/dist/esm/version.js\n");

/***/ })

};
;